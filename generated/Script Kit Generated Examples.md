## Generate Secure Password and Copy to Clipboard

```typescript
// Name: Generate Secure Password 
// Description: Generates a secure password and copies it to the clipboard
// Author: johnlindquist

import "@johnlindquist/kit"
import generator from "generate-password"

// Generate a secure password 
const password = generator.generate({
  length: 12, 
  numbers: true, 
  symbols: true,
  uppercase: true,
  lowercase: true,
  // Exclude similar characters 
  excludeSimilarCharacters: true, 
}) 

// Copy the password to the clipboard
await copy(password) 

// Display a notification 
await notify("Password copied to clipboard!")
```

## Convert Text to Speech and Save to MP3

```typescript
// Name: Text to Speech 
// Description: Converts text to speech and saves it as an MP3 file
// Author: johnlindquist

import "@johnlindquist/kit"
import OpenAI from "openai"
// You can sign up for an API key at https://beta.openai.com/signup/
const openai = new OpenAI({
  apiKey: await env("OPENAI_API_KEY"),
})

// Prompt the user for input text
const inputText = await arg("Enter text:")

// Convert the text to speech using OpenAI's API
const response = await openai.audio.speech.create({ 
  model: "tts-1",
  voice: "alloy", // You can find available voices at https://beta.openai.com/docs/api-reference/audio/create
  input: inputText,
})

// Convert the response to an ArrayBuffer
const arrayBuffer = await response.arrayBuffer()
// Convert the ArrayBuffer to a Buffer 
const buffer = Buffer.from(arrayBuffer) 

// Save the audio to an MP3 file
const audioFilePath = tmpPath("speech.mp3") 
await writeFile(audioFilePath, buffer)

// Display a message 
await div(md(`Audio saved to: ${audioFilePath}`))
```

## Create a New Git Branch 

```typescript
// Name: Create Git Branch
// Description: Creates a new Git branch in the current directory 
// Author: johnlindquist 

import "@johnlindquist/kit"

// Prompt the user for the branch name
const branchName = await arg("Enter branch name:")

// Create the branch
await $`git checkout -b ${branchName}`

// Display a message 
await div(md(`Created branch: ${branchName}`))
```

## Resize Images in Bulk 

```typescript
// Name: Resize Images
// Description: Resizes images in a selected directory
// Author: johnlindquist 

import "@johnlindquist/kit"
import sharp from "sharp"

// Prompt the user to select a directory
const directory = await path() 

// Get all image files in the directory
const imageFiles = await globby([`${directory}/*.{png,jpg,jpeg}`])

// Prompt the user for the desired width
const width = Number(await arg("Enter desired width:")) 

// Resize each image 
for (const imageFile of imageFiles) { 
  // Resize the image and save it to a new file with "-resized" appended to the name 
  await sharp(imageFile).resize({ width }).toFile(`${imageFile}-resized.jpg`)
} 

// Display a message
await div(md(`Resized ${imageFiles.length} images in ${directory}`)) 
```

## Get Weather Information

```typescript
// Name: Get Weather
// Description: Retrieves and displays weather information for a given location
// Author: johnlindquist 

import "@johnlindquist/kit"
import axios from "axios"

// Get the OpenWeatherMap API key from the environment
// You can get a free API key at https://openweathermap.org/api
const apiKey = await env("OPENWEATHERMAP_API_KEY")

// Prompt the user for a location (city name)
const location = await arg("Enter city:") 

// Fetch weather data from OpenWeatherMap API
const response = await axios.get( 
  `https://api.openweathermap.org/data/2.5/weather?q=${location}&appid=${apiKey}&units=metric` 
)

// Extract weather information from the response 
const { main, weather } = response.data 
const { temp, feels_like, humidity } = main 
const description = weather[0].description

// Display the weather information 
await div(md(`
## Weather in ${location}

* **Temperature:** ${temp}Â°C 
* **Feels like:** ${feels_like}Â°C 
* **Humidity:** ${humidity}%
* **Description:** ${description}
`))
``` 

## Create a New File from a Template

```typescript
// Name: Create from Template
// Description: Creates a new file from a template
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user to select a template file
const templateFile = await path({
  hint: "Select a template file", 
}) 

// Prompt the user to enter a file name
const fileName = await arg("Enter file name:")

// Read the template file contents
const templateContent = await readFile(templateFile, "utf8")

// Create a new file with the template content
await writeFile(fileName, templateContent) 

// Open the new file in the editor 
await edit(fileName) 
```

## Shorten a URL

```typescript
// Name: Shorten URL
// Description: Shortens a URL using the Bitly API
// Author: johnlindquist

import "@johnlindquist/kit"
import axios from "axios" 

// Get the Bitly access token from the environment 
// You can get an access token at https://app.bitly.com/settings/api/ 
const accessToken = await env("BITLY_ACCESS_TOKEN")

// Prompt the user to enter the URL to shorten
const longUrl = await arg({
  placeholder: "Enter URL to shorten:",
}) 

// Shorten the URL using the Bitly API 
const response = await axios.post( 
  `https://api-ssl.bitly.com/v4/shorten`,
  {
    long_url: longUrl,
  },
  {
    headers: { 
      Authorization: `Bearer ${accessToken}`,
    }, 
  }
) 

// Extract and copy the shortened URL 
const shortUrl = response.data.link 
await copy(shortUrl) 

// Display the shortened URL
await div(md(`# Shortened URL: ${shortUrl}`))
```

## Check Website Status

```typescript
// Name: Website Status
// Description: Checks the status of a website
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user to enter a website URL
const url = await arg("Enter website URL:")

// Check the website status
try {
  const response = await get(url, { timeout: 5000 }) 
  // Display the status code
  await div(md(`# Status: ${response.status}`)) 
} catch (error) {
  // Display an error message if the website is down 
  await div(md(`# Website is down!`))
}
```

## Convert Image to Base64

```typescript
// Name: Image to Base64
// Description: Converts an image to base64 encoding 
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt the user to select an image file
const imagePath = await path({
  hint: "Select an image file", 
})

// Read the image file as a Buffer
const imageBuffer = await readFile(imagePath)

// Convert the Buffer to a base64 encoded string
const base64Image = imageBuffer.toString("base64")

// Copy the base64 encoded string to the clipboard 
await copy(base64Image) 

// Display a confirmation message
await div(md(`## Base64 image copied to clipboard!`))
```

## Get System Information

```typescript 
// Name: System Information
// Description: Displays system information 
// Author: johnlindquist

import "@johnlindquist/kit"
import os from "os" 

// Get system information
const hostname = os.hostname() 
const platform = os.platform()
const release = os.release()
const cpuInfo = os.cpus()
const totalMemory = os.totalmem() 
const freeMemory = os.freemem() 

// Display the system information 
await div(
  md(`
## System Information 

* **Hostname:** ${hostname}
* **Platform:** ${platform}
* **Release:** ${release} 
* **CPU:** ${cpuInfo[0].model} 
* **Total Memory:** ${filesize(totalMemory)} 
* **Free Memory:** ${filesize(freeMemory)}
`)
)
```

## Create a Zip Archive

```typescript
// Name: Create Zip Archive
// Description: Creates a zip archive of a selected directory 
// Author: johnlindquist

import "@johnlindquist/kit"
import archiver from "archiver"

// Prompt the user to select a directory to archive
const directoryPath = await path()

// Create a write stream for the zip file
const output = createWriteStream(`${directoryPath}.zip`) 

// Create a new archiver instance 
const archive = archiver("zip", {
  zlib: { level: 9 }, // Set compression level
})

// Pipe the archive data to the output stream
archive.pipe(output)

// Add the selected directory to the archive
archive.directory(directoryPath, false) 

// Finalize the archive
await archive.finalize() 

// Display a notification 
await notify(`Zip archive created: ${directoryPath}.zip`)
```

## Search NPM Packages 

```typescript
// Name: Search NPM
// Description: Searches for NPM packages
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt the user to enter a search query
const query = await arg("Enter search query:") 

// Search for NPM packages using the npm registry API
const response = await get(`https://registry.npmjs.org/-/v1/search?text=${query}`) 

// Extract package information
const packages = response.data.objects.map((pkg) => ({
  name: pkg.package.name,
  description: pkg.package.description,
  value: pkg.package.links.npm,
}))

// Display the list of packages
await arg(
  {
    placeholder: "Select a package:", 
  },
  packages 
) 
```

## Translate Text

```typescript
// Name: Translate Text
// Description: Translates text using Google Translate API
// Author: johnlindquist

import "@johnlindquist/kit"
import { v2 as cloudinary } from "cloudinary" 

// Get the Google Translate API key from the environment
// You can get an API key at https://cloud.google.com/translate/docs/setup
const apiKey = await env("GOOGLE_TRANSLATE_API_KEY")

// Prompt the user to enter text to translate
const text = await arg("Enter text to translate:")

// Prompt the user to select the target language
const targetLanguage = await arg(
  "Select target language:",
  // Provide a list of language codes
  ["en", "es", "fr", "de", "it", "pt", "ru", "ja", "zh-CN"] 
)

// Translate the text using the Google Translate API 
const response = await get( 
  `https://translation.googleapis.com/language/translate/v2?key=${apiKey}`,
  { 
    params: {
      q: text,
      target: targetLanguage,
    },
  }
)

// Extract and display the translated text 
const translatedText = response.data.data.translations[0].translatedText
await div(md(`# Translated Text:\n\n${translatedText}`))
``` 

## Create Event on Google Calendar

```typescript
// Name: Create Google Calendar Event
// Description: Creates a new event on your Google Calendar
// Author: johnlindquist

import "@johnlindquist/kit"
import { google } from "googleapis"
import { JWT } from "google-auth-library"

// Get credentials for Google service account through environment variables
let serviceAccountEmail = await env("GOOGLE_SERVICE_ACCOUNT_EMAIL")
let serviceAccountKey = await env("GOOGLE_SERVICE_ACCOUNT_KEY")

// Define the scopes and client
let jwtClient = new JWT({
  email: serviceAccountEmail,
  key: serviceAccountKey,
  scopes: ["https://www.googleapis.com/auth/calendar"],
})

let calendar = google.calendar("v3")

async function createEvent(auth) {
  // Prompt the user for event details
  let summary = await arg("Event summary:") 
  let description = await arg("Event description:")
  let startTime = await arg("Start time (YYYY-MM-DDTHH:mm:ss):")
  let endTime = await arg("End time (YYYY-MM-DDTHH:mm:ss):")

  // Define the event
  let event = {
    summary,
    location: await arg("Location:"), 
    description,
    start: {
      dateTime: startTime,
      timeZone: "America/Los_Angeles",
    },
    end: {
      dateTime: endTime, 
      timeZone: "America/Los_Angeles",
    }, 
  }

  // Call the Calendar API to insert the event
  try {
    let { data: eventData } = await calendar.events.insert({
      auth,
      calendarId: "primary", 
      resource: event,
    })

    // Display a success message with a link to the created event
    await div(md(`# Event created: [${eventData.htmlLink}](${eventData.htmlLink})`))
  } catch (error) {
    // Display an error message if event creation fails
    await div(md(`# Error creating event: ${error}`))
  }
}
// Authorize the client and create the event
jwtClient.authorize((err) => {
  if (err) {
    console.log(err) 
    return
  }
  createEvent(jwtClient)
})
```

## Convert Markdown to HTML Email

```typescript
// Name: Markdown to HTML Email
// Description: Converts Markdown to HTML for email
// Author: johnlindquist

import "@johnlindquist/kit"
import MarkdownIt from "markdown-it"
import mjml2html from "mjml"

// Prompt for the email subject
const subject = await arg("Enter subject:")

// Open the editor with Markdown input
const markdown = await editor({
  placeholder: "Enter markdown content:",
})

// Initialize MarkdownIt with HTML enabled
const md = new MarkdownIt({
  html: true, 
})

// Convert Markdown to HTML
const htmlContent = md.render(markdown)

// Wrap the content in a basic MJML template for email
const mjmlTemplate = `
<mjml>
  <mj-body>
    <mj-section>
      <mj-column>
        <mj-text>
          ${htmlContent} 
        </mj-text>
      </mj-column>
    </mj-section>
  </mj-body>
</mjml>
`

// Convert MJML to HTML
const { html } = mjml2html(mjmlTemplate)

// Copy the HTML content to the clipboard
await copy(html)

// Display a success message
await div(md(`## HTML email content copied to clipboard!`))
```

## Convert CSV to JSON

```typescript
// Name: CSV to JSON
// Description: Converts a CSV file to JSON
// Author: johnlindquist

import "@johnlindquist/kit" 
import { parse } from "csv-parse"

// Prompt the user to select a CSV file 
const csvFilePath = await path({
  hint: "Select a CSV file",
})

// Read the contents of the selected file
const csvContent = await readFile(csvFilePath, "utf8")

// Parse the CSV data
const records = await new Promise<any[]>((resolve, reject) => {
  parse(csvContent, {
    columns: true, // Use first row as column headers
    skip_empty_lines: true, // Skip empty lines in the CSV
  }, (err, records) => {
    if (err) {
      reject(err)
    } else {
      resolve(records)
    }
  }) 
})

// Convert the parsed records to JSON
const jsonOutput = JSON.stringify(records, null, 2)

// Display the JSON output in the editor 
await editor(jsonOutput) 
``` 

## Create and Send a Tweet

```typescript
// Name: Tweet It!
// Description: Creates and sends a tweet
// Author: johnlindquist

import "@johnlindquist/kit" 
import Twitter from "twitter-lite"

// Get Twitter API keys from the environment
// You can get API keys at https://developer.twitter.com/en/portal/dashboard
const consumerKey = await env("TWITTER_CONSUMER_KEY")
const consumerSecret = await env("TWITTER_CONSUMER_SECRET")
const accessTokenKey = await env("TWITTER_ACCESS_TOKEN_KEY") 
const accessTokenSecret = await env("TWITTER_ACCESS_TOKEN_SECRET")

// Authenticate with Twitter API
const client = new Twitter({ 
  consumer_key: consumerKey,
  consumer_secret: consumerSecret,
  access_token_key: accessTokenKey,
  access_token_secret: accessTokenSecret, 
})

// Prompt the user for tweet content
const tweetContent = await arg("What's happening?")

// Post the tweet
try { 
  await client.post("statuses/update", { status: tweetContent }) 
  await div(md("# Tweet sent! ðŸŽ‰")) 
} catch (error) {
  await div(md(`# Error sending tweet: ${error}`)) 
} 
``` 

## Generate QR Code

```typescript
// Name: Generate QR Code
// Description: Generates a QR code for a given text or URL 
// Author: johnlindquist 

import "@johnlindquist/kit" 
import qrcode from "qrcode"

// Prompt the user for input text or URL 
const data = await arg("Enter text or URL:") 

// Generate the QR code
const qrCodeImage = await qrcode.toDataURL(data) 

// Display the QR code in a div
await div(`<img src="${qrCodeImage}" alt="QR Code" />`)
```

## Get Random Advice

```typescript
// Name: Get Advice
// Description: Displays random advice
// Author: johnlindquist 

import "@johnlindquist/kit" 

// Fetch random advice from the Advice Slip API 
const response = await get("https://api.adviceslip.com/advice")

// Extract the advice from the response
const advice = response.data.slip.advice

// Display the advice in a div 
await div(md(`# ${advice}`))
``` 

## Check for Broken Links in a Markdown File

```typescript
// Name: Check Links 
// Description: Checks for broken links in a Markdown file
// Author: johnlindquist 

import "@johnlindquist/kit"
import { isUrl } from "is-url-superb"

// Prompt the user to select a Markdown file 
const markdownFilePath = await path({ 
  hint: "Select a Markdown file",
})

// Read the contents of the Markdown file
const markdownContent = await readFile(markdownFilePath, "utf8")

// Extract links from the Markdown content
const linkRegex = /\[([^\]]+)\]\(([^)]+)\)/g 
let links: string[] = []
let match
while ((match = linkRegex.exec(markdownContent)) !== null) {
  links.push(match[2])
}

// Check each link 
const brokenLinks: string[] = [] 
for (const link of links) {
  // Check if it's a valid URL
  if (isUrl(link)) {
    try {
      // Try to fetch the URL with a timeout of 5 seconds 
      const response = await get(link, { timeout: 5000 })
      // If the status code is not 200, consider the link broken
      if (response.status !== 200) {
        brokenLinks.push(link)
      } 
    } catch (error) { 
      // If there's an error fetching the URL, consider the link broken
      brokenLinks.push(link) 
    }
  }
}

// Display the broken links 
if (brokenLinks.length > 0) {
  await div(
    md(`## Found ${brokenLinks.length} broken links:

${brokenLinks.map(link => `* ${link}`).join("\n")} 
`) 
  )
} else { 
  await div(md(`## No broken links found!`)) 
} 
```
## Send Email with Nodemailer

```typescript
// Name: Send Email
// Description: Sends an email using Nodemailer
// Author: johnlindquist

import "@johnlindquist/kit"
import nodemailer from "nodemailer"

// Get email credentials from the environment variables
const emailUser = await env("EMAIL_USER") 
const emailPassword = await env("EMAIL_PASSWORD")

// Prompt for the recipient's email address 
const to = await arg("Enter recipient email:")

// Create a Nodemailer transporter using SMTP
const transporter = nodemailer.createTransport({
  // You can find your SMTP settings for popular providers like Gmail, Outlook, etc. online
  host: "smtp.example.com", 
  port: 587,
  secure: false, 
  auth: {
    user: emailUser,
    pass: emailPassword,
  }, 
}) 

// Prompt for the email subject and body
const subject = await arg("Enter subject:")
const body = await textarea("Enter email body:")

// Send the email 
try { 
  await transporter.sendMail({
    from: emailUser, 
    to,
    subject, 
    html: body, // You can send plain text by setting text: body
  }) 
  await div(md(`# Email sent successfully! ðŸŽ‰`)) 
} catch (error) {
  await div(md(`# Error sending email: ${error}`))
}
``` 

## Create GitHub Repository 

```typescript
// Name: Create GitHub Repo
// Description: Creates a new GitHub repository
// Author: johnlindquist

import "@johnlindquist/kit"
import { Octokit } from "@octokit/rest"

// Authenticate with the GitHub API
const octokit = new Octokit({
  auth: await env("GITHUB_PERSONAL_ACCESS_TOKEN", {
    hint: `Grab a key from <a href="https://github.com/settings/tokens">here</a>`,
  }), 
}) 

// Prompt for repository name and description
const name = await arg("Enter repository name:")
const description = await arg("Enter repository description:") 

// Create the repository 
try { 
  await octokit.repos.createForAuthenticatedUser({
    name, 
    description,
    private: true, // You can set this to false for public repositories
  })
  await div(md(`# Repository ${name} created successfully!`)) 
} catch (error) {
  await div(md(`# Error creating repository: ${error}`))
}
``` 

## Get Current Location

```typescript
// Name: Get My Location
// Description: Retrieves and displays your current location 
// Author: johnlindquist

import "@johnlindquist/kit" 

// Get the user's current location 
let location: any = await new Promise((resolve, reject) => {
  navigator.geolocation.getCurrentPosition(resolve, reject)
})

// Extract latitude and longitude from the location object
const { latitude, longitude } = location.coords

// Display the location information
await div(md(`
## Your Location:

* Latitude: ${latitude}
* Longitude: ${longitude}

[Open in Google Maps](https://www.google.com/maps/search/?api=1&query=${latitude},${longitude})
`))
```

## Upload File to AWS S3

```typescript
// Name: Upload to S3
// Description: Uploads a file to AWS S3 
// Author: johnlindquist

import "@johnlindquist/kit"
import AWS from "aws-sdk"

// Get AWS credentials and bucket name from the environment variables
const awsAccessKeyId = await env("AWS_ACCESS_KEY_ID") 
const awsSecretAccessKey = await env("AWS_SECRET_ACCESS_KEY")
const awsBucketName = await env("AWS_BUCKET_NAME") 

// Prompt the user to select a file
const filePath = await path({ 
  hint: "Select a file to upload", 
}) 

// Read the file contents as a buffer 
const fileContent = await readFile(filePath)

// Create an S3 instance
const s3 = new AWS.S3({
  accessKeyId: awsAccessKeyId,
  secretAccessKey: awsSecretAccessKey,
})

// Upload the file to the specified S3 bucket 
try { 
  await s3.upload({
    Bucket: awsBucketName,
    Key: path.basename(filePath), 
    Body: fileContent,
  }).promise()
  await div(md(`# File uploaded successfully to ${awsBucketName}/${path.basename(filePath)}! ðŸŽ‰`))
} catch (error) {
  await div(md(`# Error uploading file: ${error}`))
}
``` 

## Convert Video to GIF

```typescript 
// Name: Video to GIF
// Description: Converts a video file to a GIF
// Author: johnlindquist

import "@johnlindquist/kit"
import { spawn } from "child_process"

// Prompt the user to select a video file
const videoFilePath = await path({
  hint: "Select a video file", 
})

// Prompt the user for the desired duration of the GIF (in seconds) 
const duration = Number(await arg("Enter GIF duration (seconds):"))

// Construct the FFmpeg command to convert the video to a GIF
const command = `ffmpeg -i "${videoFilePath}" -t ${duration} -vf "fps=10,scale=320:-1:flags=lanczos,split[s0][s1];[s0]palettegen[p];[s1][p]paletteuse" -loop 0 "${videoFilePath}.gif"`

// Execute the FFmpeg command
await new Promise<void>((resolve, reject) => { 
  const ffmpegProcess = spawn(command, { shell: true }) 

  ffmpegProcess.on("close", (code) => { 
    if (code === 0) { 
      resolve()
    } else {
      reject(new Error(`FFmpeg process exited with code ${code}`)) 
    }
  }) 
}) 

// Display a message
await div(md(`# GIF created: ${videoFilePath}.gif`)) 
``` 

## Generate Random Password with Options

```typescript 
// Name: Password Generator
// Description: Generates a random password with customizable options
// Author: johnlindquist

import "@johnlindquist/kit"
import generator from "generate-password"

// Function to generate the password based on user choices
const generatePassword = async () => {
  // Prompt for password length
  const length = Number(await arg("Enter desired length:"))

  // Prompt for inclusion of numbers
  const numbers = (await arg("Include numbers? [y/n]:")) === "y" ? true : false

  // Prompt for inclusion of symbols
  const symbols = (await arg("Include symbols? [y/n]:")) === "y" ? true : false

  // Generate the password using the provided options
  return generator.generate({
    length, 
    numbers, 
    symbols,
  });
} 

// Generate and display the password
const password = await generatePassword(); 
await div(md(`## Generated password:\n\n${password}`));
```

## Check GitHub Profile Stats

```typescript
// Name: GitHub Stats
// Description: Checks and displays statistics for your GitHub profile
// Author: johnlindquist

import "@johnlindquist/kit"
import { Octokit } from "@octokit/rest"

// Authenticate with GitHub
const octokit = new Octokit({
  auth: await env("GITHUB_PERSONAL_ACCESS_TOKEN", {
    hint: `Grab a key from <a href="https://github.com/settings/tokens">here</a>`,
  }),
}) 

// Get the authenticated user's data 
const { data: user } = await octokit.users.getAuthenticated() 

// Get the user's repositories
const repos = await octokit.repos.listForAuthenticatedUser({
  sort: "pushed",
  per_page: 100, 
})

// Calculate total stars and forks
let totalStars = 0
let totalForks = 0
repos.data.forEach(repo => {
  totalStars += repo.stargazers_count
  totalForks += repo.forks_count
}) 

// Display profile statistics
await div(md(`
## Your GitHub Stats

* **Username:** ${user.login}
* **Name:** ${user.name}
* **Followers:** ${user.followers}
* **Public Repos:** ${user.public_repos}
* **Total Stars:** ${totalStars}
* **Total Forks:** ${totalForks}
`))
```


## Get Latest News Headlines 

```typescript
// Name: Latest Headlines
// Description: Displays the latest news headlines from a selected source
// Author: johnlindquist

import "@johnlindquist/kit"
import { NewsAPI } from "newsapi"

// Get your API key from https://newsapi.org/
const NEWS_API_KEY = await env("NEWS_API_KEY")

// Initialize NewsAPI client
const newsapi = new NewsAPI(NEWS_API_KEY)

// Define a list of news sources
const sources = ["bbc-news", "cnn", "the-verge", "techcrunch", "reuters"]

// Prompt the user to select a news source 
const source = await arg("Select a news source:", sources)

// Fetch the latest headlines from the selected source 
const headlines = await newsapi.v2.topHeadlines({
  sources: source,
  language: "en", 
})

// Display the headlines as choices
const headlineChoices = headlines.articles.map(article => ({
  name: article.title,
  value: article.url,
  description: `${article.source.name} - ${article.publishedAt}`,
}))

const selectedUrl = await arg("Select a headline:", headlineChoices)

// Open the selected headline in the browser 
open(selectedUrl)
```

## Convert Text to Handwriting

```typescript
// Name: Text to Handwriting
// Description: Converts text to handwriting using the Handwrite.io API
// Author: johnlindquist

import "@johnlindquist/kit" 
import axios from "axios"

// Get the Handwrite.io API key from the environment
// Sign up for an API key at https://www.handwrite.io/
const HANDWRITE_IO_API_KEY = await env("HANDWRITE_IO_API_KEY")

// Prompt the user to enter text
const text = await arg({
  placeholder: "Enter text to convert to handwriting",
})

// Set handwriting style options
const handwritingStyle = await arg(
  "Select handwriting style:",
  ["REGULAR", "CURSIVE"]
)

// Convert text to handwriting using Handwrite.io API 
const response = await axios.post(
  "https://api.handwrite.io/render",
  {
    text,
    handwriting_id: handwritingStyle, 
  }, 
  {
    headers: {
      Authorization: `Bearer ${HANDWRITE_IO_API_KEY}`,
    },
  }
)

// Retrieve the URL of the generated image
const imageUrl = response.data.handwriting_url 

// Display the handwriting image in a div
await div(`<img src="${imageUrl}" alt="Handwriting" />`) 
```

## Send SMS Message with Twilio

```typescript
// Name: Send SMS
// Description: Sends an SMS message using Twilio
// Author: johnlindquist

import "@johnlindquist/kit" 
import twilio from "twilio" 

// Get Twilio credentials from the environment
// Sign up for an account and get your credentials at https://www.twilio.com/
const accountSid = await env("TWILIO_ACCOUNT_SID")
const authToken = await env("TWILIO_AUTH_TOKEN")

// Create a Twilio client
const client = twilio(accountSid, authToken) 

// Prompt the user to enter the recipient's phone number
const to = await arg("Enter phone number:") 

// Prompt the user to enter the message body
const body = await arg("Enter message:") 

// Send the SMS message
try {
  await client.messages.create({
    body,
    from: await env("TWILIO_PHONE_NUMBER"), // Your Twilio phone number
    to,
  })

  await div(md(`# Message sent successfully! ðŸŽ‰`))
} catch (error) {
  await div(md(`# Error sending message: ${error}`))
}
``` 

## Check Spelling and Grammar with LanguageTool

```typescript
// Name: Spell and Grammar Check
// Description: Checks the spelling and grammar of a text using the LanguageTool API
// Author: johnlindquist

import "@johnlindquist/kit" 
import axios from "axios"

// Prompt the user to enter the text to check 
const text = await textarea({
  placeholder: "Enter your text:",
})

// Make a request to the LanguageTool API 
const response = await axios.post(
  "https://languagetool.org/api/v2/check",
  {
    text,
    language: "en-US", // You can specify a different language code here
  }
)

// Extract suggestions from the response
const suggestions = response.data.matches

// Process and display each suggestion
let suggestionsMd = ""
for (const suggestion of suggestions) { 
  suggestionsMd += `### ${suggestion.message}
  
  * **Context:** ${suggestion.context.text} 
  * **Incorrect:** ${suggestion.context.text.slice(
    suggestion.context.offset,
    suggestion.context.offset + suggestion.context.length
  )}
  * **Replacements:** ${suggestion.replacements
    .map(replacement => replacement.value)
    .join(", ")}

---
  `
}

await div(md(suggestionsMd))
```

## Get Stock Prices

```typescript
// Name: Get Stock Price
// Description: Retrieves the current price of a stock using the Finnhub API
// Author: johnlindquist 

import "@johnlindquist/kit"
import axios from "axios"

// Get your API key at https://finnhub.io/
const FINNHUB_API_KEY = await env("FINNHUB_API_KEY")

// Prompt the user to enter a stock symbol
const stockSymbol = await arg("Enter stock symbol:") 

// Fetch stock price from the Finnhub API
const { data: quote } = await axios.get(
  `https://finnhub.io/api/v1/quote?symbol=${stockSymbol}&token=${FINNHUB_API_KEY}`
)

// Extract relevant data from the API response
const { c: currentPrice, d: change, dp: percentChange } = quote 

// Display the stock price and change information
await div(md(` 
## ${stockSymbol}

* **Current Price:** $${currentPrice.toFixed(2)} 
* **Change:** $${change.toFixed(2)} (${percentChange.toFixed(2)}%)
`)) 
``` 

## Create a Countdown Timer 

```typescript
// Name: Countdown Timer
// Description: Creates a countdown timer for a specified duration
// Author: johnlindquist 

import "@johnlindquist/kit"
import { fromEvent, interval, takeUntil, map } from "rxjs"

// Prompt the user for the duration of the timer (in minutes)
const durationMinutes = parseFloat(await arg("Enter duration (minutes):"))

// Calculate the total duration in milliseconds 
const totalMilliseconds = durationMinutes * 60 * 1000; 

// Create a countdown timer using RxJS Observables 
const countdown$ = interval(1000).pipe(
  map(tick => {
    const remainingMilliseconds = totalMilliseconds - tick * 1000;
    // Calculate remaining minutes and seconds
    const minutes = Math.floor(remainingMilliseconds / (1000 * 60))
    const seconds = Math.floor((remainingMilliseconds % (1000 * 60)) / 1000)
    // Return the formatted time string 
    return `${minutes.toString().padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`
  }),
  takeUntil(fromEvent(globalThis, "beforeExit")),
)

// Create a widget to display the countdown
const timerWidget = await widget(`
<div class="p-5 text-4xl">{{ timeRemaining }}</div>
`, {
  state: {
    timeRemaining: "Starting...",
  },
})

// Subscribe to the countdown and update the widget state
countdown$.subscribe(time => {
  timerWidget.setState({
    timeRemaining: time,
  })
})

// Handle widget close event
timerWidget.onClose(() => {
  // Optionally perform actions when the widget is closed 
  console.log("Timer widget closed")
})
```

## Generate Random Quote

```typescript 
// Name: Random Quote
// Description: Displays a random quote
// Author: johnlindquist 

import "@johnlindquist/kit" 
import axios from "axios" 

// Fetch a random quote from the Quotable API
const response = await axios.get("https://api.quotable.io/random") 

// Extract the quote content and author from the response 
const { content, author } = response.data

// Display the quote in a div
await div(md(`
## ${content}

â€” ${author}
`))
```
## Generate Color Palette from Image

```typescript
// Name: Generate Color Palette
// Description: Extracts a color palette from an image using Vibrant.js
// Author: johnlindquist

import "@johnlindquist/kit"
import Vibrant from "node-vibrant"

// Prompt the user to select an image file 
const imagePath = await path({
  hint: "Select an image",
})

// Analyze the image to get a color palette 
const palette = await Vibrant.from(imagePath).getPalette()

// Extract prominent colors from the palette 
const { Vibrant, Muted, DarkVibrant, LightVibrant } = palette;

// Create an array of color choices 
const colorChoices = [
  { name: "Vibrant", value: Vibrant.hex, className: `bg-[${Vibrant.hex}]` },
  { name: "Muted", value: Muted.hex, className: `bg-[${Muted.hex}]` }, 
  { name: "Dark Vibrant", value: DarkVibrant.hex, className: `bg-[${DarkVibrant.hex}]` },
  { name: "Light Vibrant", value: LightVibrant.hex, className: `bg-[${LightVibrant.hex}]` },
];

// Prompt the user to select a color from the palette
const selectedColor = await arg(
  {
    placeholder: "Select a color:", 
  },
  colorChoices
)

// Copy the selected color to the clipboard
await copy(selectedColor)

// Display a confirmation message
await div(md(`## Copied ${selectedColor} to clipboard!`))
```

## Check Website for Accessibility Issues

```typescript
// Name: Accessibility Check
// Description: Checks a website for accessibility issues using the Pa11y CLI
// Author: johnlindquist 

import "@johnlindquist/kit"

// Prompt for the website URL
const url = await arg("Enter website URL:")

// Run the Pa11y CLI command and capture the output 
let { stdout } = await $`pa11y ${url} --reporter json`

// Attempt to parse the JSON output 
let data = {}
try {
  data = JSON.parse(stdout)
} catch (error) {
  // Handle parsing errors
  console.error(`Error parsing Pa11y output: ${error}`) 
}

// Display the accessibility issues found by Pa11y 
if (data?.issues?.length > 0) {
  let issues = data.issues.map(issue => {
    return `- **${issue.code}:** ${issue.message} (${issue.type}) at ${issue.selector}`
  })
  await div(md(`# Accessibility issues found:\n\n${issues.join("\n")}`))
} else {
  await div(md(`# No accessibility issues found!`))
}
```

## Create a New Trello Card

```typescript
// Name: New Trello Card
// Description: Creates a new card on a Trello board
// Author: johnlindquist

import "@johnlindquist/kit"
import axios from "axios"

// Get your Trello API key and token from https://trello.com/app-key
const TRELLO_API_KEY = await env("TRELLO_API_KEY")
const TRELLO_API_TOKEN = await env("TRELLO_API_TOKEN") 

// Prompt the user to select a Trello board 
const boardId = await env("TRELLO_BOARD_ID", {
  hint: "Enter your Trello Board ID",
})

// Prompt for the card name and description
const cardName = await arg("Enter card name:")
const cardDescription = await arg("Enter card description:")

// Create a new Trello card using the API 
try {
  const response = await axios.post(
    "https://api.trello.com/1/cards", 
    {
      key: TRELLO_API_KEY,
      token: TRELLO_API_TOKEN,
      idList: await env("TRELLO_LIST_ID", {
        hint: "Enter your Trello List ID",
      }), // ID of the list to add the card to
      name: cardName,
      desc: cardDescription,
    }
  )
  await div(md(`# Card created successfully! ðŸŽ‰`)) 
} catch (error) {
  await div(md(`# Error creating card: ${error}`))
}
```

## Generate TypeScript Types from JSON

```typescript
// Name: JSON to Typescript
// Description: Generates TypeScript types from JSON data
// Author: johnlindquist

import "@johnlindquist/kit"
import { quicktype, InputData, JSONSchemaInput, TypeScriptTargetLanguage } from "quicktype-core" 

// Prompt the user to enter JSON data 
const jsonData = await editor({ 
  language: "json",
  placeholder: "Enter JSON data",
})

// Generate TypeScript types using quicktype-core
async function generateTypes(jsonData: string) {
  // Define input data and target language 
  const inputData = new InputData(JSON.parse(jsonData)) 
  const targetLanguage = new TypeScriptTargetLanguage()
  // Create a JSON schema input from the provided JSON data 
  const schemaInput = new JSONSchemaInput(inputData)
  // Generate TypeScript types
  await quicktype({
    inputData,
    lang: targetLanguage,
    rendererOptions: {
      "nice-property-names": "true", // Use camelCase for property names
    }, 
    sources: [schemaInput], 
  })
}

// Generate and display the TypeScript types
const typeScriptTypes = await generateTypes(jsonData)
await editor(typeScriptTypes) 
```

## Convert Text to Emoji

```typescript
// Name: Text to Emoji
// Description: Converts text to emojis using the emojilib library
// Author: johnlindquist

import "@johnlindquist/kit" 
import emojilib from "emojilib"

// Prompt the user to enter text
const text = await arg("Enter text to convert to emoji:")

// Convert text to emoji using emojilib
const emojiText = text
  .split(" ") 
  .map(word => {
    const emoji = emojilib.lib[word.toLowerCase()]?.char // Find emoji for the word 
    return emoji ? emoji : word // Use the original word if no emoji is found
  }) 
  .join(" ") 

// Copy the emoji text to the clipboard
await copy(emojiText)

// Display the emoji text
await div(md(`## ${emojiText}`))
```

## Get Time Zone Information

```typescript
// Name: Get Time Zone
// Description: Displays information about the current time zone
// Author: johnlindquist

import "@johnlindquist/kit"

// Get current time zone details 
const timeZone = Intl.DateTimeFormat().resolvedOptions().timeZone
const now = new Date() 
const timeZoneOffset = now.getTimezoneOffset() 
const timeZoneName = Intl.DateTimeFormat().resolvedOptions().timeZone

// Format the time zone offset 
const offsetHours = Math.abs(Math.floor(timeZoneOffset / 60)).toString().padStart(2, "0") 
const offsetMinutes = Math.abs(timeZoneOffset % 60).toString().padStart(2, "0")
const offsetSign = timeZoneOffset > 0 ? "-" : "+" 
const formattedOffset = `${offsetSign}${offsetHours}:${offsetMinutes}` 

// Display the time zone information
await div(md(`
## Time Zone Information

* **Time Zone:** ${timeZoneName} (${formattedOffset})
* **Offset (Minutes):** ${timeZoneOffset}
`))
```

## Check GitHub Repository Size

```typescript
// Name: Get Repo Size
// Description: Gets the size of a GitHub repository
// Author: johnlindquist

import "@johnlindquist/kit"
import { Octokit } from "@octokit/rest"

// Get the repository name from the user
const repo = await arg("Enter repository name (e.g., user/repo):")

// Authenticate with the GitHub API
const octokit = new Octokit({
  auth: await env("GITHUB_PERSONAL_ACCESS_TOKEN", { 
    hint: `Grab a key from <a href="https://github.com/settings/tokens">here</a>`,
  }),
}) 

try {
  // Split the repository name into owner and repo parts
  const [owner, repoName] = repo.split("/") 
  // Fetch repository information from the GitHub API
  const { data } = await octokit.repos.get({ owner, repo: repoName })

  // Display the repository size
  await div(md(`
## Repository Size

* **${repo}:** ${filesize(data.size * 1024)} // GitHub API returns size in KB, so multiply by 1024 to get bytes
`))
} catch (error) { 
  // Display an error message if the repository is not found
  await div(md(`# Error: ${error.message}`))
}
```


## Create ZIP Archive from Selected Files

```typescript
// Name: Create ZIP from Selection
// Description: Creates a ZIP archive of selected files
// Author: johnlindquist

import "@johnlindquist/kit"
import archiver from "archiver" 

// Get the selected files from Finder
const selectedFiles = await getSelectedFile(); 

// If no files are selected, prompt the user to select files
if (!selectedFiles) {
  await div(md(`# No files selected. Please select files in Finder and try again.`)) 
  exit()
}

// Prompt the user to choose a destination directory for the ZIP archive
const outputDir = await path({
  hint: "Select destination directory",
  onlyDirs: true, 
})

// Create a write stream for the zip file
const output = createWriteStream(path.join(outputDir, "archive.zip")) 

// Create a new archiver instance 
const archive = archiver("zip")

// Pipe the archive data to the output stream
archive.pipe(output)

// Add each selected file to the archive
selectedFiles.split("\n").forEach(file => {
  archive.file(file, { name: path.basename(file) })
}) 

// Finalize the archive
await archive.finalize()

// Display a notification confirming the archive creation
await notify("ZIP archive created!")
```

## Get Directions with Google Maps

```typescript
// Name: Get Directions
// Description: Gets directions between two locations using Google Maps
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user for the starting location
const origin = await arg("Enter starting location:") 

// Prompt the user for the destination location
const destination = await arg("Enter destination:") 

// Construct the Google Maps directions URL
const url = `https://www.google.com/maps/dir/?api=1&origin=${encodeURIComponent(
  origin
)}&destination=${encodeURIComponent(destination)}` 

// Open the directions in the default browser 
await open(url)
```

##  Check for Available Updates for NPM Packages

```typescript
// Name: Check for Updates
// Description: Checks for available updates for NPM packages in the current project
// Author: johnlindquist

import "@johnlindquist/kit"
import { execa } from "execa" 

// Get the current working directory
const cwd = process.cwd()

// Run the 'npm outdated' command and capture its output 
const { stdout } = await execa("npm", ["outdated"], { cwd, shell: true })

// If there's any output, display it in the editor
if (stdout.trim()) { 
  await editor({
    value: stdout, 
    language: "json", 
    enter: "Exit",
  }) 
} else {
  // Otherwise, display a message indicating no updates were found
  await div(md("# No updates found!"))
} 
```

## Convert Image to WebP

```typescript 
// Name: Convert Image to WebP
// Description: Converts an image to WebP format using Sharp 
// Author: johnlindquist 

import "@johnlindquist/kit"
import sharp from "sharp"

// Prompt the user to select an image file
const imagePath = await path({
  hint: "Select an image file",
})

// Convert the image to WebP format 
try {
  await sharp(imagePath)
    .webp({ quality: 80 }) // Adjust the quality as needed 
    .toFile(`${imagePath}.webp`) 

  await div(md(`## Image converted to WebP: ${imagePath}.webp`))
} catch (error) { 
  await div(md(`# Error converting image: ${error}`))
}
```

## Create a New Asana Task

```typescript 
// Name: New Asana Task 
// Description: Creates a new task on Asana
// Author: johnlindquist

import "@johnlindquist/kit" 
import axios from "axios"

// Get the Asana API key from the environment 
// You can get your API key from https://app.asana.com/0/developer-console
const ASANA_API_KEY = await env("ASANA_API_KEY") 

// Prompt the user to enter the task name
const taskName = await arg("Enter task name:") 

// Prompt the user to enter a description for the task (optional)
let taskDescription = await arg({ 
  placeholder: "Enter task description (optional):", 
  hint: "(Hit Enter to skip)",
})

// If the user skips the description, set it to an empty string 
if (taskDescription === undefined) {
  taskDescription = "";
}

// Prompt the user to select an Asana workspace 
const workspaceId = await env("ASANA_WORKSPACE_ID", { 
  hint: "Enter your Asana Workspace ID", 
})

// Prompt the user to select a project within the workspace
const projectId = await env("ASANA_PROJECT_ID", {
  hint: "Enter your Asana Project ID", 
})

// Create a new Asana task using the API 
try { 
  const response = await axios.post( 
    "https://app.asana.com/api/1.0/tasks",
    {
      data: {
        workspace: workspaceId, 
        projects: [projectId],
        name: taskName,
        notes: taskDescription, 
      },
    },
    {
      headers: { 
        Authorization: `Bearer ${ASANA_API_KEY}`,
      },
    }
  ) 
  await div(md(`# Task created successfully! ðŸŽ‰`)) 
} catch (error) {
  await div(md(`# Error creating task: ${error}`)) 
}
```

## Get Cryptocurrency Prices

```typescript
// Name: Crypto Prices
// Description: Displays current prices of popular cryptocurrencies 
// Author: johnlindquist

import "@johnlindquist/kit"
import axios from "axios"

// Fetch cryptocurrency prices from CoinGecko API 
const response = await axios.get(
  "https://api.coingecko.com/api/v3/simple/price",
  {
    params: {
      // List of cryptocurrencies to fetch prices for
      ids: "bitcoin,ethereum,dogecoin,litecoin", 
      // Specify the currency for display
      vs_currencies: "usd", 
    },
  } 
)

// Extract price data from the response
const { bitcoin, ethereum, dogecoin, litecoin } = response.data

// Display the prices in a div
await div(md(`
## Crypto Prices (USD)

* **Bitcoin:** $${bitcoin.usd} 
* **Ethereum:** $${ethereum.usd} 
* **Dogecoin:** $${dogecoin.usd} 
* **Litecoin:** $${litecoin.usd}
`))
``` 

## Get Lyrics for a Song

```typescript
// Name: Get Lyrics
// Description: Retrieves lyrics for a song using the Genius API
// Author: johnlindquist

import "@johnlindquist/kit"
import axios from "axios"
import { encode } from "js-base64"

// Get the Genius API token from the environment
// You can get a token at https://genius.com/developers
const GENIUS_API_TOKEN = await env("GENIUS_API_TOKEN")

// Prompt the user to enter the song title and artist 
const songTitle = await arg("Enter song title:")
const songArtist = await arg("Enter artist:") 

// Search for the song on Genius using the API 
const searchResponse = await axios.get(
  "https://api.genius.com/search",
  {
    headers: {
      Authorization: `Bearer ${GENIUS_API_TOKEN}`,
    },
    params: {
      q: `${songTitle} ${songArtist}`, 
    },
  } 
)

// Extract the song ID from the search results 
const songId = searchResponse.data.response.hits[0].result.id 

// Get the lyrics for the song using the song ID
const lyricsResponse = await axios.get(
  `https://api.genius.com/songs/${songId}`,
  { 
    headers: {
      Authorization: `Bearer ${GENIUS_API_TOKEN}`,
    }, 
  }
) 

// Extract the lyrics URL from the response
const lyricsUrl = lyricsResponse.data.response.song.url 

// Fetch the lyrics content using the lyrics URL 
const lyricsHtml = (await get(lyricsUrl)).data

// Extract the lyrics from the HTML content using Cheerio 
const $ = cheerio.load(lyricsHtml)
const lyrics = $(".lyrics").text().trim()

// Display the lyrics in the editor 
await editor(lyrics)
```
## Check for Outdated NPM Packages and Update

```typescript
// Name: Update Packages
// Description: Checks for outdated NPM packages and prompts to update them
// Author: johnlindquist

import "@johnlindquist/kit"
import { execa } from "execa"

// Get the current working directory
const cwd = process.cwd()

// Run `npm outdated` command to get outdated packages
const { stdout: outdatedOutput } = await execa("npm", ["outdated"], { cwd, shell: true })

// If there are no outdated packages, display a message and exit
if (outdatedOutput.trim() === "") {
  await div(md("# All packages are up to date! ðŸŽ‰"))
  exit()
}

// Parse the outdated packages information from the command output
const outdatedPackages = outdatedOutput
  .trim()
  .split("\n")
  .slice(1) // Skip the header row
  .map(line => {
    const [packageName, currentVersion, wantedVersion, latestVersion] = line.trim().split(/\s+/)
    return {
      name: `${packageName} (${currentVersion} -> ${wantedVersion})`,
      value: packageName,
      description: `Latest: ${latestVersion}` 
    }
  })

// Prompt the user to select packages to update
const packagesToUpdate = await select(
  {
    placeholder: "Select packages to update (use cmd/ctrl to select multiple)",
    enter: "Update Selected",
  },
  outdatedPackages
)

// Update the selected packages using `npm update`
if (packagesToUpdate.length > 0) {
  await term({
    command: `npm update ${packagesToUpdate.join(" ")}`, // Construct the update command
    cwd,
    height: 140,
    enter: `Exit`,
  })
  await div(md(`# Updated ${packagesToUpdate.length} packages!`)) 
}
```

## Create and Push a Git Commit

```typescript 
// Name: Commit Changes
// Description: Creates a Git commit with a message and pushes it to the remote repository
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the commit message
const commitMessage = await arg("Enter commit message:")

// Get the current Git branch name
const { stdout: branchName } = await exec("git rev-parse --abbrev-ref HEAD") 

// Add all changes to the staging area
await $`git add .`

// Commit the changes with the provided message 
await $`git commit -m "${commitMessage}"` 

// Push the commit to the remote repository
await $`git push origin ${branchName.trim()}`

// Display a notification
await notify("Changes committed and pushed!") 
```

## Generate TypeScript Project with Create React App

```typescript
// Name: Create React App (TypeScript)
// Description: Generates a new React project using Create React App with TypeScript
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user to enter the project name
const projectName = await arg("Enter project name:")

// Create a new React project using Create React App with the TypeScript template
await term({
  command: `npx create-react-app ${projectName} --template typescript`,
  cwd: home("dev"), // Create the project in the "dev" directory
  height: 200,
  enter: "Open Project",
})

// Open the project directory in VS Code
await exec(`code ${path.join(home("dev"), projectName)}`)
```

## Convert Text to Speech with Different Voices

```typescript
// Name: Text to Speech (Multiple Voices)
// Description: Converts text to speech with a choice of voices 
// Author: johnlindquist

import "@johnlindquist/kit" 
import OpenAI from "openai"

// You can sign up for an API key at https://beta.openai.com/signup/ 
const openai = new OpenAI({
  apiKey: await env("OPENAI_API_KEY"), 
}) 

// Prompt the user to enter input text
const inputText = await arg("Enter text:")

// Define a list of voices
const voices = ["alloy", "echo", "fable", "onyx", "nova", "shimmer"]

// Prompt the user to choose a voice 
const selectedVoice = await arg(
  "Select voice:",
  voices,
)

// Convert the text to speech using OpenAI's API with the selected voice
const response = await openai.audio.speech.create({
  model: "tts-1",
  voice: selectedVoice, 
  input: inputText, 
})

// Convert the response to an ArrayBuffer 
const arrayBuffer = await response.arrayBuffer()
// Convert the ArrayBuffer to a Buffer
const buffer = Buffer.from(arrayBuffer) 

// Save the audio to an MP3 file
const audioFilePath = tmpPath("speech.mp3") 
await writeFile(audioFilePath, buffer) 

// Display a message 
await div(md(`Audio saved to: ${audioFilePath}`))
```

## Get Random Dad Joke and Display in Widget

```typescript 
// Name: Dad Joke Widget
// Description: Displays a random dad joke in a widget
// Author: johnlindquist 

import "@johnlindquist/kit"

// Function to fetch a dad joke from the icanhazdadjoke API 
const getDadJoke = async (): Promise<string> => { 
  const response = await get("https://icanhazdadjoke.com/", {
    headers: {
      Accept: "text/plain", 
    }, 
  }) 
  return response.data
}

// Create a widget to display the dad joke 
const jokeWidget = await widget(
  `<div class="p-4 text-2xl">{{joke}}</div>`, 
  {
    width: 400,
    height: 150,
    state: {
      joke: await getDadJoke(),
    },
  } 
)

// Handle widget click event to refresh the joke 
jokeWidget.onClick(async () => {
  jokeWidget.setState({ joke: await getDadJoke() }) 
}) 

// Handle widget close event 
jokeWidget.onClose(() => { 
  console.log("Joke widget closed")
}) 
```

## Convert Currency

```typescript
// Name: Currency Converter
// Description: Converts currency using the Open Exchange Rates API 
// Author: johnlindquist

import "@johnlindquist/kit" 
import axios from "axios" 

// Get your Open Exchange Rates API key at https://openexchangerates.org/signup/free
const OPEN_EXCHANGE_RATES_APP_ID = await env("OPEN_EXCHANGE_RATES_APP_ID")

// Define a list of currencies
const currencies = ["USD", "EUR", "GBP", "JPY", "CAD", "AUD", "CHF"] 

// Prompt for the base currency
const baseCurrency = await arg("Enter base currency (e.g., USD):", currencies)

// Prompt for the target currency 
const targetCurrency = await arg("Enter target currency (e.g., EUR):", currencies)

// Prompt for the amount to convert
const amount = parseFloat(await arg("Enter amount:"))

// Fetch the latest exchange rates from the Open Exchange Rates API
const response = await axios.get(`https://openexchangerates.org/api/latest.json?app_id=${OPEN_EXCHANGE_RATES_APP_ID}`)

// Calculate the converted amount 
const baseRate = response.data.rates[baseCurrency] 
const targetRate = response.data.rates[targetCurrency]
const convertedAmount = (amount / baseRate) * targetRate 

// Display the converted amount
await div(md(`
## Currency Conversion

${amount} ${baseCurrency} = ${convertedAmount.toFixed(2)} ${targetCurrency} 
`))
```

##  Create a New Google Doc

```typescript
// Name: Create Google Doc
// Description: Creates a new Google Doc using the Google Docs API 
// Author: johnlindquist 

import "@johnlindquist/kit"
import { google } from "googleapis" 
import { JWT } from "google-auth-library"

// Get credentials for Google service account through environment variables
let serviceAccountEmail = await env("GOOGLE_SERVICE_ACCOUNT_EMAIL")
let serviceAccountKey = await env("GOOGLE_SERVICE_ACCOUNT_KEY") 

// Define the scopes and client 
let jwtClient = new JWT({ 
  email: serviceAccountEmail,
  key: serviceAccountKey, 
  scopes: ["https://www.googleapis.com/auth/documents"], 
}) 

let docs = google.docs("v1")

async function createDoc(auth) {
  // Prompt for document title 
  const title = await arg("Enter document title:")

  try {
    // Create a new Google Doc using the API
    const { data } = await docs.documents.create({
      auth,
      requestBody: {
        title,
      },
    }) 

    // Display the newly created document's URL
    await div(md(`# Document created: [${data.documentId}](https://docs.google.com/document/d/${data.documentId}/edit)`)) 
  } catch (error) {
    // Display an error message if document creation fails
    await div(md(`# Error creating document: ${error}`))
  }
}
// Authorize the client and create the document
jwtClient.authorize((err) => {
  if (err) {
    console.log(err) 
    return
  }
  createDoc(jwtClient) 
})
```

## Resize and Compress Images

```typescript
// Name: Compress Images
// Description: Compresses images in bulk using Sharp
// Author: johnlindquist

import "@johnlindquist/kit"
import sharp from "sharp"

// Prompt the user to select a directory
const directory = await path()

// Get all image files in the selected directory 
const imageFiles = await globby([`${directory}/*.{png,jpg,jpeg,gif,webp}`])

// Prompt the user for the desired output format 
const outputFormat = await arg(
  "Select output format:",
  ["jpeg", "png", "webp", "tiff", "avif", "heif"] 
)

// Resize and compress each image
for (const imageFile of imageFiles) {
  const outputPath = `${imageFile.replace(/\.[^/.]+$/, "")}-compressed.${outputFormat}`
  
  try {
    // Resize the image if it's larger than 1280px wide, otherwise keep the original size
    let resizedImage = sharp(imageFile);
    const metadata = await resizedImage.metadata();
    if (metadata.width > 1280) {
      resizedImage = resizedImage.resize(1280); 
    }

    // Compress the image based on the selected output format
    switch (outputFormat) { 
      case "jpeg":
        await resizedImage.jpeg({ quality: 80 }).toFile(outputPath)
        break
      case "png": 
        await resizedImage.png({ quality: 80 }).toFile(outputPath) 
        break 
      case "webp":
        await resizedImage.webp({ quality: 80 }).toFile(outputPath)
        break
      case "tiff": 
        await resizedImage.tiff({ quality: 80 }).toFile(outputPath) 
        break 
      case "avif":
        await resizedImage.avif({ quality: 80 }).toFile(outputPath)
        break 
      case "heif":
        await resizedImage.heif({ quality: 80 }).toFile(outputPath)
        break 
    } 
    console.log(`Compressed ${imageFile} to ${outputPath}`)
  } catch (error) {
    console.error(`Error compressing ${imageFile}: ${error}`)
  }
}

// Display a success message
await div(md(`## Compressed ${imageFiles.length} images to ${outputFormat} format!`))
```

## Create a GitHub Gist from Clipboard

```typescript
// Name: Gist from Clipboard
// Description: Creates a GitHub Gist from clipboard content
// Author: johnlindquist 

import "@johnlindquist/kit" 

// Get the content from the clipboard 
const clipboardContent = await paste()

// If the clipboard is empty, display a message and exit
if (!clipboardContent) { 
  await div(md(`# Clipboard is empty. Please copy some content and try again.`)) 
  exit()
} 

// Prompt for Gist description
const description = await arg("Enter a description for your Gist (optional):") 

// Determine the file extension based on the first line of the clipboard content
let fileExtension = ""
const firstLine = clipboardContent.trim().split("\n")[0]
if (firstLine.startsWith("```")) { 
  fileExtension = firstLine.slice(3).trim() // Extract the language from the code fence 
} else {
  fileExtension = "txt" // Default to .txt if no code fence is found 
}

// Create a Gist using the clipboard content and description 
const { html_url: gistUrl } = await createGist(clipboardContent, {
  fileName: `gist.${fileExtension}`, 
  description,
})

// Open the created Gist in the browser
open(gistUrl) 
``` 

##  Send Slack Message

```typescript
// Name: Send Slack Message 
// Description: Sends a message to a Slack channel using the Slack API
// Author: johnlindquist

import "@johnlindquist/kit" 
import { WebClient } from "@slack/web-api"

// Get the Slack API token from the environment
// Get your API token at https://api.slack.com/apps
const slackToken = await env("SLACK_API_TOKEN")

// Initialize the Slack Web Client 
const slackClient = new WebClient(slackToken) 

// Prompt the user to enter the channel name 
const channel = await arg("Enter channel name (e.g., #general):")

// Prompt the user to enter the message to send
const message = await arg("Enter message:")

// Send the message to the specified Slack channel
try {
  await slackClient.chat.postMessage({
    channel,
    text: message, 
  })
  await div(md(`# Message sent to ${channel} successfully! ðŸŽ‰`))
} catch (error) { 
  await div(md(`# Error sending message: ${error}`)) 
}
```

## Generate PDF from HTML

```typescript
// Name: HTML to PDF
// Description: Converts HTML content to PDF using Puppeteer 
// Author: johnlindquist

import "@johnlindquist/kit"
import puppeteer from "puppeteer"

// Prompt the user for the HTML content
const htmlContent = await editor({
  language: "html", 
  placeholder: "Enter HTML content:", 
})

// Launch a headless browser instance using Puppeteer
const browser = await puppeteer.launch()
const page = await browser.newPage()

// Set the HTML content of the page
await page.setContent(htmlContent)

// Generate the PDF from the HTML content
const pdfBuffer = await page.pdf() 

// Close the browser instance
await browser.close() 

// Prompt for the output file path 
const pdfFilePath = await path({
  hint: "Select PDF output path", 
})

// Write the PDF buffer to the selected file
await writeFile(pdfFilePath, pdfBuffer)

// Display a notification
await notify(`PDF saved to: ${pdfFilePath}`)
```

## Get Random Fact

```typescript
// Name: Random Fact
// Description: Displays a random fact 
// Author: johnlindquist

import "@johnlindquist/kit"

// Fetch a random fact from the Numbers API
const fact = await get("http://numbersapi.com/random/trivia?json").then(
  response => response.data.text, // Extract the fact text from the response 
)

// Display the fact in a div
await div(md(`# ${fact}`))
```

## Convert Image to ASCII Art

```typescript
// Name: Image to ASCII 
// Description: Converts an image to ASCII art using Jimp
// Author: johnlindquist

import "@johnlindquist/kit"
import Jimp from "jimp" 

// Prompt the user to select an image file 
const imagePath = await path({ 
  hint: "Select an image file", 
}) 

// Convert the image to ASCII art using Jimp
Jimp.read(imagePath)
  .then(image => { 
    // Resize the image to a maximum width of 100 characters
    image.resize(100, Jimp.AUTO) 
    // Convert the image to ASCII art
    return image.print( 
      Jimp.FONT_SANS_8_BLACK, // Use a monospace font for best results
      0,
      0,
      { 
        text: image.bitmap.data, 
        alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,
        alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE,
      },
      image.bitmap.width, 
      image.bitmap.height 
    )
  })
  .then(asciiImage => {
    // Convert the ASCII art image to a string
    return asciiImage.toString() 
  }) 
  .then(asciiArt => {
    // Display the ASCII art in the editor
    editor(asciiArt)
  })
  .catch(error => {
    // Display an error message if there's an error processing the image
    console.error(error)
  })
```

##  Get Trending GitHub Repositories

```typescript 
// Name: Trending GitHub Repos
// Description: Displays a list of trending GitHub repositories
// Author: johnlindquist 

import "@johnlindquist/kit"
import { Octokit } from "@octokit/rest"

// Authenticate with the GitHub API
const octokit = new Octokit({
  auth: await env("GITHUB_PERSONAL_ACCESS_TOKEN", {
    hint: `Grab a key from <a href="https://github.com/settings/tokens">here</a>`,
  }),
})

// Prompt for the programming language
const language = await arg("Enter language (e.g., javascript, python):", { 
  // Set the prompt width to be smaller, suitable for a single word input
  width: PROMPT.WIDTH.XS
}) 

try {
  // Get the trending repositories for the specified language 
  const response = await octokit.repos.listForAuthenticatedUser({
    language: language, 
    sort: "stars", 
  })

  // Extract repository information
  const repositories = response.data.map(repo => ({
    name: repo.full_name,
    value: repo.html_url,
    description: repo.description, 
  })) 

  // Display the trending repositories as choices
  await arg(
    {
      placeholder: "Select a repository:", 
      height: PROMPT.HEIGHT.XL, // Set a larger prompt height to display more choices
    }, 
    repositories 
  )
} catch (error) {
  // Handle any errors that occur
  await div(md(`# Error: ${error.message}`)) 
}
```
## Resize Image with Custom Dimensions

```typescript
// Name: Resize Image
// Description: Resizes an image to custom dimensions using Sharp
// Author: johnlindquist

import "@johnlindquist/kit" 
import sharp from "sharp" 

// Prompt the user to select an image file
const imagePath = await path({
  hint: "Select an image file",
})

// Prompt for the desired width and height 
const width = Number(await arg("Enter desired width (pixels):")) 
const height = Number(await arg("Enter desired height (pixels):"))

// Resize the image using Sharp 
try {
  await sharp(imagePath)
    .resize(width, height)
    .toFile(`${imagePath}-resized.jpg`)

  await div(md(`## Image resized to ${width}x${height} pixels!`))
} catch (error) {
  await div(md(`# Error resizing image: ${error}`)) 
}
```

## Create and Share a CodePen

```typescript
// Name: Create CodePen 
// Description: Creates a new CodePen and copies the URL to the clipboard 
// Author: johnlindquist 

import "@johnlindquist/kit" 
import axios from "axios"
// Get your CodePen API token at https://codepen.io/settings/api/
const CODEPEN_API_TOKEN = await env("CODEPEN_API_TOKEN")

// Prompt the user to enter HTML, CSS, and JS code
const html = await editor({
  language: "html",
  placeholder: "Enter HTML:", 
})
const css = await editor({ 
  language: "css", 
  placeholder: "Enter CSS:", 
})
const js = await editor({ 
  language: "javascript", 
  placeholder: "Enter JavaScript:",
})

// Create a new pen using the CodePen API
try {
  const response = await axios.post(
    "https://cpv2api.com/pens", 
    {
      data: { 
        title: await arg("Enter pen title:"),
        html,
        css, 
        js, 
        private: false, // Set to true for a private pen 
      },
    },
    {
      headers: {
        Authorization: `Bearer ${CODEPEN_API_TOKEN}`,
      },
    } 
  )
  const penUrl = response.data.data.links.html

  // Copy the pen URL to the clipboard
  await copy(penUrl)

  // Display a success message with the pen URL
  await div(md(`## CodePen created: [${penUrl}](${penUrl})`)) 
} catch (error) {
  // Display an error message if pen creation fails 
  await div(md(`# Error creating CodePen: ${error}`)) 
} 
```

## Download a File with Progress Bar

```typescript 
// Name: Download File with Progress
// Description: Downloads a file from a URL and displays a progress bar 
// Author: johnlindquist

import "@johnlindquist/kit"
import axios from "axios" 

// Prompt for the file URL to download 
const fileUrl = await arg({
  placeholder: "Enter file URL:", 
})

// Prompt for the destination path 
const outputPath = await path({
  hint: "Select save location",
}) 

// Download the file using Axios, displaying a progress bar
await div( 
  {
    html: md(`# Downloading...`), 
    // Configure the progress bar 
    progressBar: true, 
    // Disable resizing to prevent visual glitches
    resize: false,
    // Set a larger height to accommodate the progress bar
    height: 120,
  },
  async () => {
    await axios({ 
      method: "get",
      url: fileUrl,
      responseType: "stream", 
    }) 
      .then(response => {
        // Create a write stream to the output file 
        const writer = createWriteStream(outputPath) 
        // Pipe the download stream to the file writer
        response.data.pipe(writer) 
        // Monitor download progress
        let total = 0
        response.data.on("data", (chunk) => { 
          total += chunk.length 
          // Update progress bar
          setProgress(Math.round((total / response.headers["content-length"]) * 100)) 
        })
        // Resolve the promise when the download is complete
        return new Promise((resolve, reject) => { 
          writer.on("finish", resolve)
          writer.on("error", reject) 
        }) 
      }) 
      .then(() => {
        // Display a success message after download
        submit("Download complete!") 
      }) 
      .catch(error => { 
        // Handle download errors
        console.error("Download error:", error) 
      })
  }
)
```

## Check if a Website Uses a Specific Technology

```typescript
// Name: Detect Technology
// Description: Checks if a website uses a specific technology using Wappalyzer
// Author: johnlindquist

import "@johnlindquist/kit" 
import wappalyzer from "wappalyzer"

// Prompt the user for the website URL 
const url = await arg("Enter website URL:")

// Prompt for the technology to search for
const technology = await arg("Enter technology to detect (e.g., React, WordPress):")

// Create a new Wappalyzer instance 
const wappalyzerInstance = new wappalyzer()

try {
  // Analyze the website
  await wappalyzerInstance.init()
  const results = await wappalyzerInstance.analyze(url) 

  // Check if the specified technology is present
  const isTechnologyUsed = results.technologies.some(
    tech => tech.name.toLowerCase() === technology.toLowerCase() 
  ) 

  // Display the result
  if (isTechnologyUsed) { 
    await div(md(`# ${url} uses ${technology}!`))
  } else { 
    await div(md(`# ${url} does not appear to use ${technology}.`))
  }
} catch (error) { 
  // Handle any errors that occur during analysis 
  await div(md(`# Error analyzing website: ${error}`)) 
} finally {
  // Destroy the Wappalyzer instance 
  await wappalyzerInstance.destroy() 
}
```

## Create a New Notion Page

```typescript
// Name: Create Notion Page
// Description: Creates a new page in a Notion database
// Author: johnlindquist

import "@johnlindquist/kit"
import { Client } from "@notionhq/client"

// You can get your integration token at https://www.notion.so/my-integrations
const notionToken = await env("NOTION_INTEGRATION_TOKEN")
const databaseId = await env("NOTION_DATABASE_ID", {
  hint: "Enter your Notion Database ID",
})

// Initialize the Notion client
const notion = new Client({ auth: notionToken })

// Prompt for the page title and content
const pageTitle = await arg("Enter page title:")
const pageContent = await textarea({ 
  placeholder: "Enter page content (Markdown supported):",
}) 

// Create a new page in the specified Notion database
try {
  await notion.pages.create({
    parent: {
      database_id: databaseId,
    }, 
    properties: {
      title: {
        title: [{ text: { content: pageTitle } }],
      }, 
    },
    children: [ 
      { 
        object: "block",
        type: "paragraph", 
        paragraph: {
          rich_text: [
            { 
              type: "text", 
              text: { 
                content: pageContent,
              }, 
            }, 
          ], 
        }, 
      }, 
    ], 
  }) 
  await div(md(`# Notion page created successfully! ðŸŽ‰`)) 
} catch (error) {
  await div(md(`# Error creating page: ${error}`)) 
} 
``` 

##  Generate Shortened URL with Bitly and Display as QR Code

```typescript
// Name: Bitly QR Code Generator
// Description: Shortens a URL using Bitly and generates a QR code 
// Author: johnlindquist

import "@johnlindquist/kit"
import axios from "axios" 
import qrcode from "qrcode"

// Get the Bitly access token from the environment
// You can get an access token at https://app.bitly.com/settings/api/
const BITLY_ACCESS_TOKEN = await env("BITLY_ACCESS_TOKEN") 

// Prompt the user to enter the URL to shorten 
const longUrl = await arg({
  placeholder: "Enter URL to shorten:",
})

// Shorten the URL using the Bitly API 
try {
  const response = await axios.post(
    "https://api-ssl.bitly.com/v4/shorten",
    {
      long_url: longUrl,
    }, 
    {
      headers: {
        Authorization: `Bearer ${BITLY_ACCESS_TOKEN}`,
      },
    }
  )
  const shortUrl = response.data.link 
  
  // Generate the QR code for the shortened URL
  const qrCodeImage = await qrcode.toDataURL(shortUrl) 

  // Display the QR code in a div 
  await div(`
  ## Shortened URL: ${shortUrl}

  <img src="${qrCodeImage}" alt="QR Code" />
  `)
} catch (error) { 
  await div(md(`# Error shortening URL: ${error}`))
} 
```

## Check Your Public IP Address

```typescript
// Name: Check IP Address
// Description: Displays your public IP address using ipify 
// Author: johnlindquist

import "@johnlindquist/kit"

// Fetch the public IP address using the ipify API 
const ipAddress = await get("https://api.ipify.org?format=json").then( 
  response => response.data.ip, // Extract the IP address from the response
)

// Display the IP address in a div 
await div(md(`## Your Public IP Address:\n\n${ipAddress}`))
``` 


## Convert Timestamp to Date

```typescript
// Name: Timestamp to Date
// Description: Converts a Unix timestamp to a human-readable date
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the Unix timestamp 
const timestamp = Number(await arg("Enter timestamp:")) 

// Convert the timestamp to a Date object
const date = new Date(timestamp * 1000) 

// Format the date
const formattedDate = date.toLocaleDateString()

// Display the formatted date
await div(md(`# ${formattedDate}`)) 
```

## Search and Replace Text in Files

```typescript 
// Name: Find and Replace
// Description: Searches for and replaces text in files using ripgrep
// Author: johnlindquist 

import "@johnlindquist/kit"

// Prompt the user to enter the search pattern (supports regular expressions) 
const searchPattern = await arg("Enter search pattern:") 

// Prompt for the replacement text
const replacementText = await arg("Enter replacement text:")

// Prompt the user to select a directory to search within
const directory = await path({ 
  hint: "Select a directory",
})

// Run the ripgrep command with the provided search pattern, replacement text, and directory
await term({
  // Construct the ripgrep command using string interpolation
  command: `rg '${searchPattern}' -r '${directory}' --replace '${replacementText}'`, 
  // Set the terminal height
  height: 180, 
  // Customize the Enter key label
  enter: "Close Terminal",
})

// Display a success notification
await notify("Find and replace complete!")
```

## Download YouTube Video

```typescript
// Name: Download YouTube Video
// Description: Downloads a YouTube video using ytdl-core
// Author: johnlindquist

import "@johnlindquist/kit"
import ytdl from "ytdl-core"

// Prompt the user for the YouTube video URL
const youtubeUrl = await arg("Enter YouTube video URL:")

// Extract the video ID from the URL
const videoId = youtubeUrl.split("v=")[1].split("&")[0]

// Download the video using ytdl-core
const videoPath = path.join(home("Downloads"), `${videoId}.mp4`)
ytdl(youtubeUrl, { quality: "highest" }) 
  .pipe(createWriteStream(videoPath))
  .on("finish", async () => {
    await div(md(`# Video downloaded: ${videoPath}`))
  })
  .on("error", async (error: any) => {
    await div(md(`# Error downloading video: ${error}`))
  }) 
```

## Create a Countdown Timer Widget

```typescript
// Name: Countdown Widget
// Description: Displays a countdown timer in a widget
// Author: johnlindquist 

import "@johnlindquist/kit"
import { interval } from "rxjs"

// Prompt for the duration of the timer in seconds 
const durationSeconds = parseFloat(await arg("Enter duration (seconds):")) 

// Create a countdown timer using RxJS intervals
const countdown$ = interval(1000).pipe(
  map(tick => {
    // Calculate the remaining time in seconds
    const timeLeft = durationSeconds - tick; 

    // Format the remaining time as minutes and seconds 
    const minutes = Math.floor(timeLeft / 60)
    const seconds = Math.floor(timeLeft % 60)
    return `${minutes.toString().padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`
  }), 
  take(durationSeconds + 1), // Stop the timer after the specified duration 
) 

// Create a widget to display the countdown timer 
const timerWidget = await widget(`
  <div class="p-4 text-4xl">{{ timeRemaining }}</div>
`, {
  width: 300, 
  height: 150,
  state: {
    timeRemaining: durationSeconds,
  },
})

// Subscribe to the countdown and update the widget's state 
countdown$.subscribe(time => {
  timerWidget.setState({ timeRemaining: time })
})

// Optional: Handle widget close event 
timerWidget.onClose(() => {
  console.log("Timer widget closed")
})
``` 

## Get a Random Chuck Norris Joke and Say It

```typescript
// Name: Chuck Norris Joke
// Description: Tells a random Chuck Norris joke
// Author: johnlindquist

import "@johnlindquist/kit"

// Fetch a random Chuck Norris joke from the API
const joke = await get("https://api.chucknorris.io/jokes/random").then(
  response => response.data.value // Extract the joke from the response 
)

// Speak the joke using the text-to-speech function
say(joke)

// Display the joke in a div 
await div(md(`# ${joke}`)) 
```

##  Create a Trello Board from a Template

```typescript
// Name: Create Trello Board
// Description: Creates a new Trello board from a template 
// Author: johnlindquist

import "@johnlindquist/kit" 
import axios from "axios"

// Get your Trello API key and token from https://trello.com/app-key 
const TRELLO_API_KEY = await env("TRELLO_API_KEY")
const TRELLO_API_TOKEN = await env("TRELLO_API_TOKEN")

// Prompt the user to select a Trello board template file (JSON format) 
const templateFilePath = await path({
  hint: "Select Trello board template (JSON)", 
})

// Read the contents of the template file
const templateContent = await readJson(templateFilePath) 

// Create a new Trello board using the API and the provided template 
try { 
  const response = await axios.post(
    "https://api.trello.com/1/boards/", 
    {
      key: TRELLO_API_KEY,
      token: TRELLO_API_TOKEN,
      name: await arg("Enter board name:"), 
      ...templateContent, // Include the template data in the request
    }
  ) 
  await div(md(`# Board created successfully! ðŸŽ‰`))
} catch (error) { 
  await div(md(`# Error creating board: ${error}`)) 
}
```

##  Check for Unused NPM Packages

```typescript
// Name: Find Unused Packages 
// Description: Finds unused NPM packages in the current project using depcheck
// Author: johnlindquist

import "@johnlindquist/kit" 
import depcheck from "depcheck" 

// Run depcheck to analyze the project's dependencies
const { dependencies, devDependencies } = await depcheck(process.cwd(), { 
  // Ignore specific files or directories during the analysis 
  ignoreDirs: ["build", "dist"],
  // Specify additional parsers for custom file types
  parsers: { 
    "**/*.jsx": depcheck.parser.jsx,
  },
  detectors: [
    // Use all built-in detectors 
    depcheck.detector.requireCallExpression,
    depcheck.detector.importDeclaration,
  ],
  // Skip calculation of spec files
  specials: [], 
})

// Combine unused dependencies and devDependencies
const unusedPackages = [...dependencies, ...devDependencies]

// If there are unused packages, display them as choices for removal
if (unusedPackages.length > 0) {
  const packageChoices = unusedPackages.map(pkg => ({
    name: pkg, 
    value: pkg, 
  }))

  const packagesToRemove = await select(
    {
      placeholder: "Select packages to remove (use cmd/ctrl to select multiple)", 
      enter: "Uninstall Selected", 
    }, 
    packageChoices
  ) 

  if (packagesToRemove.length > 0) {
    // Uninstall the selected packages using `npm uninstall`
    await term({
      command: `npm uninstall ${packagesToRemove.join(" ")}`,
      height: 140,
      enter: "Exit",
    }) 
    // Display a success notification 
    await notify("Unused packages uninstalled!") 
  }
} else {
  // If no unused packages are found, display a message 
  await div(md(`# No unused packages found! ðŸŽ‰`))
}
```
## Generate a New UUID and Copy to Clipboard

```typescript
// Name: Generate UUID
// Description: Generates a new UUID and copies it to the clipboard
// Author: johnlindquist

import "@johnlindquist/kit"

// Generate a new UUID
const newUUID = global.uuid() 

// Copy the UUID to the clipboard 
await copy(newUUID)

// Display a notification
await notify("UUID copied to clipboard!") 
``` 

## Create a Markdown Table from Data

```typescript
// Name: Create Markdown Table 
// Description: Creates a Markdown table from user-provided data
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user for table data (comma-separated values) 
const tableData = await textarea({
  placeholder: `Enter data (comma-separated):
  
  e.g.,
  Name, Age, City 
  John, 30, New York
  Jane, 25, London
  `,
})

// Split the input into rows
const rows = tableData.trim().split("\n") 

// Extract headers from the first row
const headers = rows.shift().split(",").map(header => header.trim())

// Create the Markdown table header row 
let markdownTable = `| ${headers.join(" | ")} |\n` 
markdownTable += `| ${headers.map(() => "---").join(" | ")} |\n` 

// Create Markdown table rows from the data
rows.forEach(row => {
  const columns = row.split(",").map(column => column.trim())
  markdownTable += `| ${columns.join(" | ")} |\n` 
})

// Display the Markdown table in the editor 
await editor(markdownTable) 
``` 

##  Download and Extract a ZIP File

```typescript 
// Name: Download and Extract ZIP
// Description: Downloads and extracts a ZIP file from a URL
// Author: johnlindquist 

import "@johnlindquist/kit" 

// Prompt the user for the ZIP file URL 
const zipFileUrl = await arg("Enter ZIP file URL:")

// Prompt the user for the output directory 
const outputDir = await path({
  hint: "Select output directory",
  onlyDirs: true, 
})

// Download and extract the ZIP file
await download(zipFileUrl, outputDir, {
  extract: true, 
})

// Display a notification
await notify("ZIP file downloaded and extracted!")
```

## Get System Uptime

```typescript
// Name: System Uptime
// Description: Displays the system uptime
// Author: johnlindquist

import "@johnlindquist/kit"
import os from "os"

// Get the system uptime in seconds
const uptimeSeconds = os.uptime() 

// Format the uptime into days, hours, minutes, and seconds 
const days = Math.floor(uptimeSeconds / (60 * 60 * 24))
const hours = Math.floor((uptimeSeconds % (60 * 60 * 24)) / (60 * 60))
const minutes = Math.floor((uptimeSeconds % (60 * 60)) / 60)
const seconds = Math.floor(uptimeSeconds % 60)

// Display the formatted uptime in a div
await div(
  md(`
## System Uptime:

* **Days:** ${days} 
* **Hours:** ${hours}
* **Minutes:** ${minutes}
* **Seconds:** ${seconds} 
`)) 
```

##  Create a New Google Sheet

```typescript
// Name: Create Google Sheet
// Description: Creates a new Google Sheet using the Google Sheets API 
// Author: johnlindquist

import "@johnlindquist/kit"
import { google } from "googleapis"
import { JWT } from "google-auth-library"

// Get credentials for Google service account through environment variables 
let serviceAccountEmail = await env("GOOGLE_SERVICE_ACCOUNT_EMAIL")
let serviceAccountKey = await env("GOOGLE_SERVICE_ACCOUNT_KEY")

// Define the scopes and client
let jwtClient = new JWT({
  email: serviceAccountEmail,
  key: serviceAccountKey, 
  scopes: ["https://www.googleapis.com/auth/spreadsheets"],
})

// Initialize the Google Sheets API client 
let sheets = google.sheets("v4")

async function createSheet(auth) {
  // Prompt for the sheet title
  const title = await arg("Enter sheet title:") 

  try {
    // Create the spreadsheet using the Google Sheets API 
    const response = await sheets.spreadsheets.create({
      auth,
      requestBody: { 
        properties: { 
          title,
        }, 
      },
    })

    // Display a success message with the spreadsheet URL
    await div(md(`# Spreadsheet created: [${response.data.spreadsheetUrl}](${response.data.spreadsheetUrl})`))
  } catch (error) {
    // Display an error message if spreadsheet creation fails
    await div(md(`# Error creating spreadsheet: ${error}`)) 
  } 
} 
// Authorize the client and create the spreadsheet
jwtClient.authorize((err) => {
  if (err) { 
    console.log(err)
    return 
  }
  createSheet(jwtClient) 
})
```

## Download File with cURL

```typescript 
// Name: Download with cURL 
// Description: Downloads a file using cURL and displays the download progress
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the URL of the file to download 
const fileUrl = await arg("Enter file URL:")

// Prompt for the output file path
const outputPath = await path({
  hint: "Select output path", 
})

// Execute the cURL command with progress bar and output to the specified file 
const downloadProcess = exec(`curl -o "${outputPath}" -# "${fileUrl}"`, {
  // shell: true, // Run the command in a shell
  // Pass the process's stdout to the main process's stdout
  // This allows us to display the download progress in the terminal
  stdio: "inherit",
})

// Wait for the download process to complete
await downloadProcess; 

// Display a notification when the download is finished
await notify("File downloaded!") 
```

## Send a Message to a Discord Channel

```typescript
// Name: Send Discord Message 
// Description: Sends a message to a Discord channel using the discord.js library 
// Author: johnlindquist

import "@johnlindquist/kit"
import Discord from "discord.js" 

// Get your Discord bot token from https://discord.com/developers/applications
const DISCORD_BOT_TOKEN = await env("DISCORD_BOT_TOKEN")

// Prompt for the channel ID
const channelId = await env("DISCORD_CHANNEL_ID", {
  hint: "Enter your Discord Channel ID",
})

// Create a new Discord client instance
const client = new Discord.Client({
  intents: [Discord.GatewayIntentBits.Guilds], // Specify the required intents
})

client.on("ready", async () => {
  // Get the channel object using the provided channel ID 
  const channel = await client.channels.fetch(channelId)

  // Prompt the user for the message content 
  const message = await arg("Enter message:") 

  // Send the message to the channel
  try {
    if (channel.isTextBased()) {
      await (channel as Discord.TextChannel).send(message)
      await div(md(`# Message sent successfully! ðŸŽ‰`))
    }
  } catch (error) {
    await div(md(`# Error sending message: ${error}`))
  } finally {
    // Disconnect the client after sending the message
    client.destroy()
  }
})

// Log in the client using the bot token
client.login(DISCORD_BOT_TOKEN)
```


## Create a New Markdown File with Front Matter

```typescript
// Name: New Markdown with Front Matter
// Description: Creates a new Markdown file with customizable front matter 
// Author: johnlindquist 

import "@johnlindquist/kit"

// Prompt for the file name
const fileName = await arg("Enter file name:")

// Prompt for the title, description, and tags 
const title = await arg("Enter title:") 
const description = await arg("Enter description:") 
const tags = await arg("Enter tags (comma-separated):")

// Create the front matter 
const frontMatter = `--- 
title: ${title}
description: ${description}
tags: [${tags}] 
--- 
`

// Create the file with the front matter 
await writeFile(fileName, frontMatter)

// Open the file in the editor 
await edit(fileName)
```

## Check Website Performance with PageSpeed Insights

```typescript 
// Name: PageSpeed Insights
// Description: Analyzes a website's performance using Google's PageSpeed Insights API 
// Author: johnlindquist

import "@johnlindquist/kit"
import axios from "axios"

// Prompt for the website URL 
const url = await arg("Enter website URL:") 

// Make a request to the PageSpeed Insights API 
const response = await axios.get(
  `https://www.googleapis.com/pagespeedonline/v5/runPagespeed?url=${url}&strategy=mobile` 
  // You can change the strategy to "desktop" for desktop analysis
) 

// Extract relevant data from the response 
const { data } = response 
const { title, loadingExperience, lighthouseResult } = data
const { overall_category: performanceCategory } = loadingExperience
const { categories } = lighthouseResult

// Display the website performance summary
await div(md(`
## PageSpeed Insights for ${title}

* **Overall Performance:** ${performanceCategory} 

### Category Scores:

* **Performance:** ${categories.performance.score * 100} 
* **Accessibility:** ${categories.accessibility.score * 100}
* **Best Practices:** ${categories["best-practices"].score * 100}
* **SEO:** ${categories.seo.score * 100} 
* **PWA:** ${categories.pwa.score * 100}
`))
```

## Upload Image to Imgur

```typescript
// Name: Upload to Imgur
// Description: Uploads an image to Imgur and copies the link to the clipboard
// Author: johnlindquist

import "@johnlindquist/kit"
import axios from "axios"

// Get your Imgur Client ID from https://api.imgur.com/oauth2/addclient
const IMGUR_CLIENT_ID = await env("IMGUR_CLIENT_ID")

// Prompt the user to select an image file
const imagePath = await path({
  hint: "Select an image",
})

// Read the image file as a Buffer
const imageBuffer = await readFile(imagePath)

// Convert the Buffer to a base64 encoded string
const base64Image = imageBuffer.toString("base64")

// Upload the image to Imgur using the API
try {
  const response = await axios.post( 
    "https://api.imgur.com/3/image",
    { image: base64Image },
    {
      headers: {
        Authorization: `Client-ID ${IMGUR_CLIENT_ID}`,
      },
    } 
  )

  // Copy the image link to the clipboard
  await copy(response.data.data.link)

  // Display a success message 
  await div(md(`## Image uploaded to Imgur!\n\nLink copied to clipboard: ${response.data.data.link}`))
} catch (error) {
  // Handle upload errors
  await div(md(`# Error uploading image: ${error}`))
}
```

## Generate Random Kanye West Quote

```typescript
// Name: Kanye Quote
// Description: Displays a random Kanye West quote
// Author: johnlindquist 

import "@johnlindquist/kit"

// Fetch a random Kanye West quote from the Kanye.rest API 
const quote = await get("https://api.kanye.rest/").then(
  response => response.data.quote
)

// Display the quote in a stylish div using Tailwind CSS classes
await div(
  `<div class="p-5 rounded-lg shadow-md bg-gradient-to-r from-yellow-400 to-pink-600">
    <p class="text-white text-xl font-bold">${quote}</p> 
  </div>`,
  // Add a class to the container for additional styling (optional)
  "container-class"
) 
```

## Get a List of Your Spotify Playlists

```typescript 
// Name: Spotify Playlists
// Description: Lists your Spotify playlists
// Author: johnlindquist

import "@johnlindquist/kit"
import SpotifyWebApi from "spotify-web-api-node" 

// Get your Spotify client ID and secret from https://developer.spotify.com/dashboard/applications
const SPOTIFY_CLIENT_ID = await env("SPOTIFY_CLIENT_ID")
const SPOTIFY_CLIENT_SECRET = await env("SPOTIFY_CLIENT_SECRET")

// Create a Spotify API client
const spotifyApi = new SpotifyWebApi({
  clientId: SPOTIFY_CLIENT_ID, 
  clientSecret: SPOTIFY_CLIENT_SECRET, 
  redirectUri: "http://localhost:8888/callback", // You can use any valid redirect URI here 
})

// Retrieve an access token for the Spotify API
const { body: { access_token: accessToken } } = await spotifyApi.clientCredentialsGrant()

// Set the access token on the API client
spotifyApi.setAccessToken(accessToken) 

// Fetch the user's playlists
const { body: { items: playlists } } = await spotifyApi.getUserPlaylists(
  // Get the username from the environment variables or prompt for it
  await env("SPOTIFY_USERNAME", { hint: "Enter your Spotify Username:" }),
  { limit: 50 } // Specify the maximum number of playlists to retrieve
) 

// Create an array of playlist choices
const playlistChoices = playlists.map(playlist => ({
  name: playlist.name, 
  description: `by ${playlist.owner.display_name} - ${playlist.tracks.total} tracks`,
  value: playlist.external_urls.spotify,
}))

// Prompt the user to select a playlist 
const playlistUrl = await arg(
  "Select a playlist:",
  playlistChoices
) 

// Open the selected playlist in the browser
await open(playlistUrl) 
```

## Generate a New SSH Key Pair

```typescript
// Name: Generate SSH Key 
// Description: Generates a new SSH key pair 
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user to enter a name for the key pair
const keyName = await arg("Enter key name:")

// Generate the SSH key pair using the `ssh-keygen` command
await term({ 
  // Construct the command using string interpolation
  command: `ssh-keygen -t rsa -b 4096 -C "${keyName}" -f ~/.ssh/${keyName}`, 
  height: 160, // Set a suitable height for the terminal window 
  enter: "Exit Terminal",
}) 

// Display a success message
await div(md(`# SSH key pair generated!`)) 
``` 

## Download and Display a File from Dropbox

```typescript
// Name: Download from Dropbox
// Description: Downloads a file from Dropbox and displays its contents
// Author: johnlindquist

import "@johnlindquist/kit" 
import { Dropbox } from "dropbox" 

// Get your Dropbox API token at https://www.dropbox.com/developers/apps
const DROPBOX_API_TOKEN = await env("DROPBOX_API_TOKEN")

// Initialize the Dropbox client 
const dbx = new Dropbox({ accessToken: DROPBOX_API_TOKEN }) 

// Prompt the user to select a file from their Dropbox account 
const filePath = await arg(
  {
    placeholder: "Enter Dropbox file path (e.g., /MyFile.txt):",
  }, 
  async (input) => {
    // Search for files matching the user's input
    const { result: { matches } } = await dbx.filesSearchV2({
      query: input,
    }) 

    return matches.map(match => ({ 
      name: match.metadata.name, 
      value: match.metadata.path_lower,
      description: match.metadata.path_display, 
    }))
  }
) 

try {
  // Download the selected file from Dropbox
  const { result: { fileBinary, metadata } } = await dbx.filesDownload({ path: filePath })

  // Determine the file type based on the file extension
  const fileExtension = path.extname(metadata.name).toLowerCase() 
  let language = "text"
  if (fileExtension === ".js") {
    language = "javascript" 
  } else if (fileExtension === ".ts") {
    language = "typescript"
  } else if (fileExtension === ".json") { 
    language = "json"
  } 

  // Display the file content in the editor with syntax highlighting 
  await editor({
    value: fileBinary.toString(), 
    language,
  })
} catch (error) { 
  // Handle download errors
  await div(md(`# Error downloading file: ${error}`)) 
}
``` 

## Get a List of Available Wi-Fi Networks

```typescript
// Name: Available Wi-Fi Networks 
// Description: Lists available Wi-Fi networks and their signal strengths 
// Author: johnlindquist

import "@johnlindquist/kit" 

// Execute the `airport` command to retrieve Wi-Fi network information 
const { stdout } = await exec("airport -s")

// Process the output of the airport command to extract network details
const networks = stdout
  .split("\n")
  .slice(1) // Remove the header line 
  .map(line => {
    // Extract SSID and signal strength (RSSI) 
    const [ssid, bssid, rssi, channel, ht, security] = line.trim().split(/\s+/) 
    return {
      name: `${ssid} (${rssi})`, 
      value: ssid, 
      description: `Channel: ${channel}, Security: ${security}`,
    }
  })

// Display the list of available networks 
await arg({ placeholder: "Available Wi-Fi Networks:" }, networks)
```

## Convert Text to Speech and Play Audio

```typescript
// Name: Speak Text
// Description: Converts text to speech and plays the audio 
// Author: johnlindquist

import "@johnlindquist/kit"
import OpenAI from "openai"

// Get the OpenAI API key from the environment
// You can sign up for an API key at https://beta.openai.com/signup/ 
const openai = new OpenAI({
  apiKey: await env("OPENAI_API_KEY"),
})

// Prompt the user to enter text
const inputText = await arg("Enter text to speak:")

// Convert the text to speech using the OpenAI API
const response = await openai.audio.speech.create({
  model: "tts-1", 
  voice: "alloy", // You can find available voices at https://beta.openai.com/docs/api-reference/audio/create 
  input: inputText,
})

// Convert the response to an ArrayBuffer 
const arrayBuffer = await response.arrayBuffer()

// Convert the ArrayBuffer to a Buffer
const buffer = Buffer.from(arrayBuffer) 

// Play the audio directly from the buffer
playAudioFile(buffer) 

// Display the input text in a div
await div(md(`# You said:\n\n${inputText}`)) 
```

## Create a New Branch and Switch to It

```typescript 
// Name: New Git Branch and Checkout 
// Description: Creates a new Git branch and immediately switches to it
// Author: johnlindquist 

import "@johnlindquist/kit"

// Prompt the user for the new branch name
const branchName = await arg("Enter new branch name:")

// Create the new branch and switch to it using the `git checkout -b` command 
await $`git checkout -b ${branchName}`

// Display a success message
await div(md(`# Switched to branch: ${branchName}`))
```

## Download and Display Image from URL

```typescript
// Name: Download and View Image 
// Description: Downloads an image from a URL and displays it 
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user for the image URL
const imageUrl = await arg({
  placeholder: "Enter image URL:", 
}) 

// Download the image data as a Buffer
const imageBuffer = await download(imageUrl)

// Display the image in a div 
await div(`<img src="data:image/jpeg;base64,${imageBuffer.toString("base64")}" alt="Downloaded Image" />`) 
```

## Generate a PDF from a Markdown File

```typescript
// Name: Markdown to PDF
// Description: Converts a Markdown file to PDF using Pandoc 
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user to select a Markdown file 
const markdownFilePath = await path({
  hint: "Select a Markdown file",
})

// Prompt the user for the output PDF file path
const pdfFilePath = await path({ 
  hint: "Select PDF output path",
})

// Execute the Pandoc command to convert the Markdown file to PDF 
await $`pandoc "${markdownFilePath}" -o "${pdfFilePath}"`

// Display a notification
await notify(`PDF generated: ${pdfFilePath}`) 
```

## Search and Open a File with fzf

```typescript 
// Name: Open File with fzf
// Description: Searches for and opens a file using fzf 
// Author: johnlindquist

import "@johnlindquist/kit"

// Find files using fzf and return the selected file path
const filePath = await new Promise<string>(resolve => {
  // Run the `fd` command to find all files and pipe the output to `fzf`
  const find = exec("fd -H | fzf", { shell: true })

  // Listen for the "close" event of the child process, which indicates fzf has exited 
  find.on("close", code => { 
    // Resolve the promise with the selected file path, which is available in the `find.stdout` buffer
    resolve(find.stdout?.toString().trim())
  })
})

// If a file was selected, open it in the default application
if (filePath) {
  await open(filePath)
}
```

## Generate a Random Joke and Tell It

```typescript
// Name: Random Joke
// Description: Tells a random joke
// Author: johnlindquist

import "@johnlindquist/kit"
import axios from "axios"

// Define the URL for the JokeAPI endpoint 
const jokeApiUrl = "https://v2.jokeapi.dev/joke/Any?safe-mode"

// Fetch a random joke from the JokeAPI
const response = await axios.get(jokeApiUrl)

// Extract the joke setup and delivery from the response 
const { setup, delivery } = response.data

// Construct the full joke 
const joke = setup ? `${setup} ${delivery}` : delivery

// Speak the joke using text-to-speech 
say(joke)

// Display the joke in a div 
await div(md(`# ${joke}`))
```
## Send a WhatsApp Message

```typescript
// Name: Send WhatsApp Message 
// Description: Sends a message to a WhatsApp contact
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user to enter the phone number
const phoneNumber = await arg("Enter phone number (with country code):")

// Construct the WhatsApp URL with the phone number and message
const message = await arg("Enter your message:");
const url = `https://wa.me/${phoneNumber}?text=${encodeURIComponent(message)}`

// Open the WhatsApp URL in the default browser
open(url) 
```

## Create a New Meeting in Zoom

```typescript
// Name: Schedule Zoom Meeting
// Description: Creates a new Zoom meeting using the Zoom API 
// Author: johnlindquist

import "@johnlindquist/kit"
import axios from "axios"

// Get your Zoom JWT API key and secret from https://marketplace.zoom.us/develop/create
const ZOOM_API_KEY = await env("ZOOM_API_KEY") 
const ZOOM_API_SECRET = await env("ZOOM_API_SECRET") 

// Generate a JWT token for authentication
const payload = {
  iss: ZOOM_API_KEY,
  exp: new Date().getTime() + 60 * 60 * 1000, // Token expires in 1 hour
}
const token = jwt.sign(payload, ZOOM_API_SECRET)

// Prompt for meeting details 
const topic = await arg("Enter meeting topic:")
const startTime = await arg( 
  "Enter meeting start time (YYYY-MM-DDTHH:mm:ss):", 
  {
    // Pre-fill the input field with the current date and time
    input: new Date().toISOString().slice(0, 19), 
  }
) 
const duration = parseInt(await arg("Enter meeting duration (minutes):")) 

// Create a Zoom meeting using the API
try {
  const response = await axios.post(
    "https://api.zoom.us/v2/users/me/meetings",
    { 
      topic,
      type: 2, // Scheduled meeting
      start_time: startTime,
      duration, 
      timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
    }, 
    {
      headers: { 
        Authorization: `Bearer ${token}`, 
      },
    }
  )

  const meetingJoinUrl = response.data.join_url

  // Copy the meeting join URL to the clipboard
  await copy(meetingJoinUrl)

  // Display the meeting details and join URL 
  await div(
    md(`
## Zoom Meeting Created

* **Topic:** ${topic} 
* **Start Time:** ${startTime}
* **Duration:** ${duration} minutes
* **Join URL:** ${meetingJoinUrl} (Copied to clipboard) 
`)
  ) 
} catch (error) { 
  await div(md(`# Error creating meeting: ${error}`))
} 
```

## Get Information About a Domain Name

```typescript
// Name: Domain Info
// Description: Retrieves information about a domain name using the whois library
// Author: johnlindquist

import "@johnlindquist/kit"
import whois from "whois-json"

// Prompt the user to enter a domain name
const domainName = await arg("Enter domain name:") 

try { 
  // Get domain information using the whois library
  const domainInfo = await whois(domainName)

  // Display the domain information in a structured format
  let formattedInfo = ""
  for (const [key, value] of Object.entries(domainInfo)) { 
    formattedInfo += `* **${key}:** ${value}\n`
  }
  await div(md(`## Domain Information:\n\n${formattedInfo}`))
} catch (error) {
  // Handle any errors that occur during the lookup
  await div(md(`# Error retrieving domain information: ${error}`))
}
```

## Create a New Google Calendar

```typescript
// Name: Create Google Calendar
// Description: Creates a new Google Calendar using the Google Calendar API
// Author: johnlindquist

import "@johnlindquist/kit"
import { google } from "googleapis"
import { JWT } from "google-auth-library"

// Get credentials for Google service account through environment variables
let serviceAccountEmail = await env("GOOGLE_SERVICE_ACCOUNT_EMAIL")
let serviceAccountKey = await env("GOOGLE_SERVICE_ACCOUNT_KEY") 

// Define the scopes and client
let jwtClient = new JWT({
  email: serviceAccountEmail,
  key: serviceAccountKey, 
  scopes: ["https://www.googleapis.com/auth/calendar"],
})

let calendar = google.calendar("v3")

async function createCalendar(auth) {
  // Prompt the user for the calendar name
  const calendarName = await arg("Enter calendar name:") 

  try {
    // Create a new Google Calendar using the API
    let { data: calendarData } = await calendar.calendars.insert({ 
      auth, 
      requestBody: { 
        summary: calendarName, 
      }, 
    })
    // Display a success message with the calendar ID 
    await div(md(`# Calendar created: ${calendarData.id}`))
  } catch (error) {
    // Display an error message if calendar creation fails
    await div(md(`# Error creating calendar: ${error}`))
  }
}
// Authorize the client and create the calendar 
jwtClient.authorize((err) => { 
  if (err) {
    console.log(err) 
    return
  }
  createCalendar(jwtClient) 
})
```

## Convert Text to Morse Code

```typescript 
// Name: Text to Morse Code
// Description: Converts text to Morse code using the morse library 
// Author: johnlindquist

import "@johnlindquist/kit" 
import morse from "morse" 

// Prompt for the text to convert
const text = await arg("Enter text:")

// Convert the text to Morse code using the `morse` library
const morseCode = morse.encode(text)

// Display the Morse code in a div 
await div(md(`## Morse Code:\n\n${morseCode}`))
```

## Get the Definition of a Word

```typescript
// Name: Define Word
// Description: Retrieves the definition of a word using the Dictionary API
// Author: johnlindquist

import "@johnlindquist/kit" 
import axios from "axios" 

// Prompt the user to enter a word
const word = await arg("Enter a word:") 

// Fetch the word definition from the Dictionary API 
const response = await axios.get(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`) 
const definition = response.data[0].meanings[0].definitions[0].definition

// Display the definition in a div
await div(md(`
## Definition of "${word}":

${definition}
`))
```

## Create a New Google Keep Note

```typescript 
// Name: Create Google Keep Note
// Description: Creates a new note in Google Keep using the Google Keep API
// Author: johnlindquist

import "@johnlindquist/kit" 
import { google } from "googleapis" 
import { JWT } from "google-auth-library" 

// Get credentials for Google service account through environment variables 
let serviceAccountEmail = await env("GOOGLE_SERVICE_ACCOUNT_EMAIL")
let serviceAccountKey = await env("GOOGLE_SERVICE_ACCOUNT_KEY") 

// Define the scopes and client
let jwtClient = new JWT({ 
  email: serviceAccountEmail,
  key: serviceAccountKey,
  scopes: ["https://www.googleapis.com/auth/notes"],
}) 

let keep = google.keep("v1")

async function createNote(auth) {
  // Prompt for the note's text content
  const text = await textarea({
    placeholder: "Enter your note:",
  })

  try {
    // Create a new note in Google Keep using the API
    let { data: noteData } = await keep.notes.create({
      auth, 
      requestBody: {
        text, 
      },
    }) 

    // Display a success message with the note ID
    await div(md(`# Note created: ${noteData.name.split("/").pop()}`))
  } catch (error) { 
    // Display an error message if note creation fails
    await div(md(`# Error creating note: ${error}`))
  }
}
// Authorize the client and create the note 
jwtClient.authorize((err) => { 
  if (err) {
    console.log(err) 
    return
  }
  createNote(jwtClient) 
})
```



## Generate Password and Save to 1Password

```typescript
// Name: Generate and Save Password 
// Description: Generates a secure password and saves it to 1Password
// Author: johnlindquist

import "@johnlindquist/kit"
import generator from "generate-password";
import opn from "open";

// Prompt for the website or service the password is for
const website = await arg("Enter website or service:");

// Generate a secure password
const password = generator.generate({
  length: 24,
  numbers: true,
  symbols: true, 
  uppercase: true, 
  lowercase: true,
});

// Construct the 1Password URL for adding a new login item
const op1Url = `op1://create/login/${encodeURIComponent(website)}/${encodeURIComponent(password)}`;

// Open the 1Password URL to add the new login item 
opn(op1Url); 

// Display a notification confirming the password generation and save attempt
await notify("Password generated and sent to 1Password!"); 
```

## Check for Typos in Text

```typescript
// Name: Spell Check
// Description: Checks the spelling of text using cspell
// Author: johnlindquist

import "@johnlindquist/kit"
import { cspell } from "cspell"

// Prompt for text input
const text = await textarea({ placeholder: "Enter text to check:" })

// Check the spelling of the provided text using cspell
const { issues } = await cspell.checkText(text)

// Create an array of suggestions for each misspelled word
let suggestionsMd = ``
for (let issue of issues) { 
  suggestionsMd += `### ${issue.text}
  
  * **Suggestions:** ${issue.suggestions.join(", ")} 
  * **Line:** ${issue.row} 
  * **Column:** ${issue.col}
  
  ---

  `
}

// Display the spelling suggestions in a div
await div(md(suggestionsMd))
```

## Create a New GitHub Issue

```typescript
// Name: Create GitHub Issue
// Description: Creates a new issue on a GitHub repository
// Author: johnlindquist 

import "@johnlindquist/kit"
import { Octokit } from "@octokit/rest"

// Get the repository name from the user, splitting it into owner and repo
const [owner, repo] = (await arg("Enter repository name (e.g., user/repo):")).split("/")

// Prompt for the issue title and body 
const title = await arg("Enter issue title:") 
const body = await textarea({
  placeholder: "Enter issue body (Markdown supported):", 
})

// Authenticate with the GitHub API 
const octokit = new Octokit({ 
  auth: await env("GITHUB_PERSONAL_ACCESS_TOKEN", { 
    hint: `Grab a key from <a href="https://github.com/settings/tokens">here</a>`,
  }), 
})

try { 
  // Create the issue on the specified repository using the GitHub API
  const response = await octokit.issues.create({
    owner,
    repo, 
    title,
    body,
  })

  // Open the created issue in the browser
  open(response.data.html_url)
} catch (error) { 
  // Display an error message if issue creation fails
  await div(md(`# Error creating issue: ${error}`))
}
```

## Get the Latest XKCD Comic

```typescript
// Name: XKCD Comic 
// Description: Displays the latest XKCD comic
// Author: johnlindquist

import "@johnlindquist/kit"
import axios from "axios"

// Fetch the latest XKCD comic data from the API
const { data } = await axios.get("https://xkcd.com/info.0.json")

// Extract the comic image URL and title
const { img, title, alt } = data 

// Display the comic in a div with the title as a caption
await div(`
<figure class="flex flex-col items-center">
  <img src="${img}" alt="${alt}" class="max-w-full rounded-lg shadow-md">
  <figcaption class="mt-2 text-center text-gray-500 text-sm">${title}</figcaption> 
</figure>
`)
```

## Generate a Random Inspirational Quote and Set as Wallpaper

```typescript
// Name: Inspirational Wallpaper
// Description: Sets a random inspirational quote as your desktop wallpaper
// Author: johnlindquist

import "@johnlindquist/kit"
import axios from "axios"

// Fetch a random inspirational quote from the ZenQuotes API
const { data: { q: quote, a: author } } = await axios.get( 
  "https://zenquotes.io/api/random" 
) 

// Create an image with the quote using Jimp
const image = new Jimp(1920, 1080, "#ffffff") // Adjust the dimensions for your desktop resolution
const font = await Jimp.loadFont(Jimp.FONT_SANS_64_BLACK) // Choose a suitable font and size
const textWidth = Jimp.measureText(font, quote) 
const textHeight = Jimp.measureTextHeight(font, quote, image.bitmap.width)

// Calculate coordinates for centered text placement 
const xPos = image.bitmap.width / 2 - textWidth / 2
const yPos = image.bitmap.height / 2 - textHeight / 2

// Add the quote text to the image
image.print(font, xPos, yPos, quote) 

// Save the image to a temporary file
const imagePath = tmpPath("quote.jpg")
await image.writeAsync(imagePath) 

// Set the image as the desktop wallpaper using the `wallpaper` command
await exec(`wallpaper "${imagePath}"`) 

// Display a notification confirming the wallpaper change
await notify("Wallpaper updated!") 
``` 

##  Generate Code Snippet with GitHub Copilot 

```typescript
// Name: Copilot Code
// Description: Generates code snippets using GitHub Copilot
// Author: johnlindquist

import "@johnlindquist/kit"
// This is where you'll write your prompt for Copilot
const prompt = await arg("Enter a prompt for Copilot:") 

// Trigger Copilot to generate code based on the provided prompt
await editor.setCodeHint(prompt)

// Open the editor to view the generated code 
await editor({
  language: "javascript",
  placeholder: "// Copilot will insert suggestions here...",
})
```

##  Check for Updates to Script Kit and Update

```typescript 
// Name: Update Script Kit 
// Description: Checks for updates to Script Kit and prompts to update 
// Author: johnlindquist

import "@johnlindquist/kit"
import axios from "axios"

// Fetch the latest release information from the Script Kit GitHub repository 
const { data: release } = await axios.get("https://api.github.com/repos/johnlindquist/kit/releases/latest")

// Extract the latest release version
const latestVersion = release.tag_name

// Get the current Script Kit version from the environment 
const currentVersion = await env("KIT_APP_VERSION")

// Compare versions to check for updates 
if (latestVersion !== currentVersion) {
  // If an update is available, prompt the user to update 
  const updateConfirmation = await arg(
    `A new version of Script Kit is available (${latestVersion}). Update now?`, 
    ["Yes", "No"] 
  )

  // If the user chooses to update, download the latest release from GitHub and install it
  if (updateConfirmation === "Yes") {
    // TODO: Implement the download and installation logic for the update
    // You can use the 'download' function from the Kit SDK to download the latest release 
    await div(md(`# Downloading and updating Script Kit...`))
  }
} else {
  // Display a message if no updates are found
  await div(md(`# Script Kit is up to date!`))
} 
``` 

## Generate and Insert Lorem Ipsum Text

```typescript
// Name: Lorem Ipsum Generator
// Description: Generates and inserts Lorem Ipsum text
// Author: johnlindquist

import "@johnlindquist/kit"
import { loremIpsum } from "lorem-ipsum"

// Prompt for the number of paragraphs 
const numParagraphs = parseInt(await arg("Enter number of paragraphs:"))

// Prompt for the number of sentences per paragraph 
const sentencesPerParagraph = parseInt(await arg("Enter sentences per paragraph:"))

// Generate Lorem Ipsum text using the provided options
const loremText = loremIpsum({
  count: numParagraphs,
  units: "paragraphs", 
  sentenceLowerBound: sentencesPerParagraph,
  sentenceUpperBound: sentencesPerParagraph,
}) 

// Insert the generated text at the current cursor position 
await setSelectedText(loremText)
``` 

## Check Website for Broken Links

```typescript
// Name: Broken Link Checker
// Description: Checks a website for broken links using the broken-link-checker library
// Author: johnlindquist

import "@johnlindquist/kit"
import BrokenLinkChecker from "broken-link-checker"

// Prompt for the website URL to check 
const urlToCheck = await arg("Enter website URL:") 

// Create an array to store broken links 
let brokenLinks: { url: string; status: string }[] = []; 

// Initialize the Broken Link Checker
const brokenLinkChecker = new BrokenLinkChecker(
  {
    url: urlToCheck, 
  }, 
  {
    // Handle link check results 
    link: (result) => {
      if (result.broken) { 
        brokenLinks.push({ url: result.url.original, status: result.brokenReason })
      } 
    },
    // Handle completion of the check
    end: () => {
      // Process and display the broken links
      let brokenLinksMd = ``
      if (brokenLinks.length > 0) {
        brokenLinks.forEach(link => {
          brokenLinksMd += `- [${link.url}](${link.url}): ${link.status}\n` 
        })
        div(md(`### Broken Links Found:

${brokenLinksMd}`)) 
      } else { 
        // Display a message if no broken links are found
        div(md(`### No Broken Links Found! ðŸŽ‰`))
      } 
    },
  }
)
```

## Get Current Bitcoin Price

```typescript
// Name: Bitcoin Price
// Description: Displays the current Bitcoin price in USD
// Author: johnlindquist

import "@johnlindquist/kit"

// Fetch the current Bitcoin price from the CoinDesk API
const bitcoinPrice = await get("https://api.coindesk.com/v1/bpi/currentprice.json").then( 
  (response) => response.data.bpi.USD.rate_float, // Extract the Bitcoin price in USD from the response
)

// Display the price in a div with a large font size 
await div(`
<div class="p-4 text-4xl">
  <p>Bitcoin: $${bitcoinPrice.toFixed(2)}</p>
</div>
`, "container-class")
```

## Create a New File with User Input

```typescript
// Name: Create File
// Description: Creates a new file with content from the editor
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the file name
const fileName = await arg("Enter file name:")

// Open the editor to allow the user to enter the file content
const content = await editor({
  placeholder: "Enter file content:", 
}) 

// Create the file with the entered content
await writeFile(fileName, content) 

// Display a notification
await notify(`File created: ${fileName}`)
```

## Get a Random Programming Joke and Tweet It

```typescript
// Name: Tweet Programming Joke
// Description: Fetches a random programming joke and tweets it
// Author: johnlindquist

import "@johnlindquist/kit"
import axios from "axios"
import Twitter from "twitter-lite"

// Get Twitter API keys from environment variables
// You can get API keys at https://developer.twitter.com/en/portal/dashboard 
const consumerKey = await env("TWITTER_CONSUMER_KEY")
const consumerSecret = await env("TWITTER_CONSUMER_SECRET") 
const accessTokenKey = await env("TWITTER_ACCESS_TOKEN_KEY") 
const accessTokenSecret = await env("TWITTER_ACCESS_TOKEN_SECRET")

// Initialize the Twitter client
const twitterClient = new Twitter({ 
  consumer_key: consumerKey, 
  consumer_secret: consumerSecret, 
  access_token_key: accessTokenKey,
  access_token_secret: accessTokenSecret,
}) 

// Fetch a random programming joke from JokeAPI
const jokeResponse = await axios.get("https://v2.jokeapi.dev/joke/Programming?safe-mode") 

// Extract the joke from the response 
const joke = jokeResponse.data.setup
  ? `${jokeResponse.data.setup} ${jokeResponse.data.delivery}` // If it's a two-part joke 
  : jokeResponse.data.joke; // If it's a single-part joke 

// Post the joke as a tweet 
try {
  await twitterClient.post("statuses/update", { status: joke })
  await div(md(`# Joke tweeted successfully! ðŸ˜‚`))
} catch (error) {
  await div(md(`# Error tweeting joke: ${error}`))
} 
```

##  Generate a QR Code from Clipboard Text

```typescript
// Name: QR Code from Clipboard
// Description: Generates a QR code for text on the clipboard 
// Author: johnlindquist

import "@johnlindquist/kit"
import qrcode from "qrcode"

// Get the text content from the clipboard
const text = await paste() 

// If the clipboard is empty, display a message and exit 
if (!text) {
  await div(md(`# Clipboard is empty! Please copy some text and try again.`))
  exit()
}

// Generate the QR code as a data URL
const qrCodeImage = await qrcode.toDataURL(text)

// Display the QR code in a div
await div(`<img src="${qrCodeImage}" alt="QR Code" />`)
```

##  Get a List of Files in a Google Drive Folder

```typescript
// Name: List Google Drive Files 
// Description: Displays a list of files in a Google Drive folder
// Author: johnlindquist

import "@johnlindquist/kit"
import { google } from "googleapis"
import { JWT } from "google-auth-library" 

// Get credentials for Google service account through environment variables
let serviceAccountEmail = await env("GOOGLE_SERVICE_ACCOUNT_EMAIL")
let serviceAccountKey = await env("GOOGLE_SERVICE_ACCOUNT_KEY") 

// Define the scopes and client
let jwtClient = new JWT({
  email: serviceAccountEmail, 
  key: serviceAccountKey, 
  scopes: ["https://www.googleapis.com/auth/drive.readonly"],
})

// Initialize the Google Drive API client 
let drive = google.drive("v3")

async function listFiles(auth) { 
  // Prompt for the Google Drive folder ID
  const folderId = await arg(
    "Enter Google Drive folder ID:", 
    {
      // Set a smaller width for the prompt
      width: PROMPT.WIDTH.SM
    }
  )
  try {
    // List files in the specified folder
    const response = await drive.files.list({
      auth, 
      q: `'${folderId}' in parents and trashed = false`, // Only list files in the specified folder that are not in the trash
      fields: "files(id, name)", // Only retrieve the file ID and name 
      pageSize: 100, // Limit the number of results per page
    })

    // Extract file information
    const files = response.data.files.map(file => ({ 
      name: file.name,
      value: file.id, 
    }))

    // Display the list of files as choices
    await arg("Select a file:", files) 
  } catch (error) {
    // Handle any errors that occur
    await div(md(`# Error: ${error.message}`)) 
  } 
} 
// Authorize the client and list the files 
jwtClient.authorize((err) => { 
  if (err) {
    console.log(err) 
    return 
  } 
  listFiles(jwtClient) 
}) 
``` 

## Get System CPU Usage

```typescript
// Name: CPU Usage
// Description: Displays the current CPU usage 
// Author: johnlindquist

import "@johnlindquist/kit"
import os from "os"

// Function to get CPU usage
const getCpuUsage = (): Promise<number> => {
  return new Promise(resolve => {
    // Get the CPU usage over a 1-second interval 
    const start = os.cpus().map(cpu => cpu.times) 
    setTimeout(() => {
      const end = os.cpus().map(cpu => cpu.times) 
      const totalIdle = end.reduce((acc, cpu, i) => acc + cpu.idle - start[i].idle, 0) 
      const totalTick = end.reduce((acc, cpu, i) => acc + Object.values(cpu).reduce((sum, t) => sum + t, 0) - Object.values(start[i]).reduce((sum, t) => sum + t, 0), 0);
      const usage = 100 - Math.round((100 * totalIdle) / totalTick)
      resolve(usage)
    }, 1000)
  })
}

// Create a widget to display the CPU usage
const cpuWidget = await widget(
  `<div class="p-4 text-2xl">{{cpuUsage}}%</div>`,
  {
    width: 100, 
    height: 50, 
    // Set alwaysOnTop to true to keep the widget visible
    alwaysOnTop: true,
    state: {
      cpuUsage: 0,
    }, 
  }
) 

// Update the widget with the current CPU usage every 2 seconds
setInterval(async () => {
  cpuWidget.setState({ cpuUsage: await getCpuUsage() }) 
}, 2000) 
```

##  Create a New Google Slides Presentation

```typescript
// Name: Create Google Slides
// Description: Creates a new Google Slides presentation using the Google Slides API
// Author: johnlindquist

import "@johnlindquist/kit"
import { google } from "googleapis" 
import { JWT } from "google-auth-library"

// Get credentials for Google service account through environment variables 
let serviceAccountEmail = await env("GOOGLE_SERVICE_ACCOUNT_EMAIL") 
let serviceAccountKey = await env("GOOGLE_SERVICE_ACCOUNT_KEY")

// Define the scopes and client 
let jwtClient = new JWT({
  email: serviceAccountEmail, 
  key: serviceAccountKey, 
  scopes: ["https://www.googleapis.com/auth/presentations"],
})

let slides = google.slides("v1")

async function createPresentation(auth) {
  // Prompt for the presentation title
  const title = await arg("Enter presentation title:") 

  try { 
    // Create a new Google Slides presentation using the API
    let { data } = await slides.presentations.create({ 
      auth,
      requestBody: {
        title,
      }, 
    })
    // Display the newly created presentation URL
    await div(md(`# Presentation created: [${data.presentationId}](https://docs.google.com/presentation/d/${data.presentationId}/edit)`))
  } catch (error) {
    // Display an error message if presentation creation fails
    await div(md(`# Error creating presentation: ${error}`))
  } 
}
// Authorize the client and create the presentation 
jwtClient.authorize((err) => { 
  if (err) { 
    console.log(err) 
    return
  }
  createPresentation(jwtClient) 
})
```

##  Check if a Domain is Available 

```typescript 
// Name: Check Domain Availability
// Description: Checks if a domain name is available using the whois library 
// Author: johnlindquist

import "@johnlindquist/kit"
import whois from "whois-json"

// Prompt for the domain name to check 
const domainName = await arg("Enter domain name:") 

try {
  // Get domain information using the whois library 
  const domainInfo = await whois(domainName) 

  // Check if the domain is available based on the registrar information
  if (domainInfo.registrar) { 
    // If the registrar is found, the domain is likely taken 
    await div(md(`# Domain ${domainName} is already registered.`))
  } else {
    // If no registrar is found, the domain might be available 
    await div(md(`# Domain ${domainName} might be available!`)) 
  } 
} catch (error) {
  // Handle errors, which might indicate the domain is available or there's an issue with the lookup
  await div(md(`# Domain ${domainName} might be available! Error: ${error}`))
}
```

## Generate a Random Password and Display as QR Code

```typescript
// Name: Password QR Code
// Description: Generates a random password and displays it as a QR code 
// Author: johnlindquist

import "@johnlindquist/kit"
import generator from "generate-password" 
import qrcode from "qrcode"

// Generate a secure password
const password = generator.generate({
  length: 16,
  numbers: true, 
  symbols: true,
  uppercase: true,
  lowercase: true, 
})

// Generate a QR code for the password
const qrCodeImage = await qrcode.toDataURL(password)

// Display the password and QR code in a div
await div(
  md(`
## Generated Password:

\`\`\`
${password}
\`\`\`

<img src="${qrCodeImage}" alt="QR Code" />
`)
)
```

## Upload a File to Google Drive

```typescript
// Name: Upload to Google Drive
// Description: Uploads a file to Google Drive using the Google Drive API
// Author: johnlindquist

import "@johnlindquist/kit"
import { google } from "googleapis"
import { JWT } from "google-auth-library"

// Get credentials for Google service account through environment variables
let serviceAccountEmail = await env("GOOGLE_SERVICE_ACCOUNT_EMAIL")
let serviceAccountKey = await env("GOOGLE_SERVICE_ACCOUNT_KEY")

// Define the scopes and client 
let jwtClient = new JWT({
  email: serviceAccountEmail, 
  key: serviceAccountKey,
  scopes: ["https://www.googleapis.com/auth/drive.file"],
}) 

let drive = google.drive("v3") 

async function uploadFile(auth) {
  // Prompt the user to select a file to upload 
  const filePath = await path() 

  // Read the file content
  const fileContent = await readFile(filePath) 

  try {
    // Upload the file to Google Drive using the API 
    const response = await drive.files.create( 
      { 
        auth,
        requestBody: {
          name: path.basename(filePath),
          parents: [
            await env("GOOGLE_DRIVE_FOLDER_ID", { hint: "Enter your Google Drive folder ID" }), // Specify the destination folder ID 
          ], 
        }, 
        media: {
          mimeType: mime.getType(filePath), 
          body: fileContent, 
        },
      }
    )

    // Display a success message with the file URL
    await div(md(`# File uploaded: [${response.data.webViewLink}](${response.data.webViewLink})`)) 
  } catch (error) { 
    // Handle any upload errors 
    await div(md(`# Error uploading file: ${error}`))
  } 
}
// Authorize the client and upload the file
jwtClient.authorize((err) => {
  if (err) { 
    console.log(err)
    return 
  } 
  uploadFile(jwtClient) 
})
```

## Send a Direct Message on Twitter

```typescript
// Name: Send Twitter DM 
// Description: Sends a direct message to a Twitter user 
// Author: johnlindquist

import "@johnlindquist/kit" 
import Twitter from "twitter-lite"

// Get Twitter API keys from the environment 
// You can get API keys at https://developer.twitter.com/en/portal/dashboard 
const consumerKey = await env("TWITTER_CONSUMER_KEY")
const consumerSecret = await env("TWITTER_CONSUMER_SECRET") 
const accessTokenKey = await env("TWITTER_ACCESS_TOKEN_KEY") 
const accessTokenSecret = await env("TWITTER_ACCESS_TOKEN_SECRET")

// Initialize the Twitter client 
const client = new Twitter({
  consumer_key: consumerKey,
  consumer_secret: consumerSecret, 
  access_token_key: accessTokenKey,
  access_token_secret: accessTokenSecret, 
}) 

// Prompt the user for the recipient's username
const recipient = await arg("Enter recipient's Twitter username:")

// Prompt for the message 
const message = await arg("Enter message:") 

try {
  // Send a direct message to the specified user
  await client.post("direct_messages/events/new", {
    event: {
      type: "message_create", 
      message_create: { 
        target: {
          recipient_id: (
            await client.get("users/show", { screen_name: recipient })
          ).id_str,
        }, 
        message_data: {
          text: message, 
        },
      }, 
    },
  })
  await div(md(`# Direct message sent to @${recipient}!`)) 
} catch (error) {
  await div(md(`# Error sending direct message: ${error}`)) 
}
```

##  Download Instagram Photos

```typescript
// Name: Download Instagram Photos
// Description: Downloads photos from an Instagram profile 
// Author: johnlindquist

import "@johnlindquist/kit"
import { IgApiClient } from "instagram-private-api"

// Create a new Instagram API client 
const ig = new IgApiClient() 

// Prompt for Instagram username 
const username = await arg("Enter Instagram username:") 

// Log in to Instagram
// You'll need to provide your own Instagram username and password
await ig.state.generateDevice(await env("INSTAGRAM_USERNAME"))
await ig.account.login(
  await env("INSTAGRAM_USERNAME"), 
  await env("INSTAGRAM_PASSWORD", { secret: true }) 
)

// Get user ID from username
const userId = await ig.user.getIdByUsername(username)

// Get user's media feed
const feed = await ig.feed.user(userId).items();

// Prompt the user to select photos to download
const photoChoices = feed.map((photo, index) => ({
  name: photo.caption?.text.slice(0, 30) || `Photo ${index + 1}`, 
  value: photo.image_versions2.candidates[0].url, // URL of the original photo 
  preview: `<img src="${photo.image_versions2.candidates[0].url}" width="400" />`, 
}))

const photoUrls = await select(
  {
    placeholder: "Select photos to download:",
  },
  photoChoices,
) 

// Download the selected photos
for (const url of photoUrls) { 
  await download(url, home("Downloads"))
  console.log(`Downloaded: ${url}`) 
}
// Display a notification
await notify(`Downloaded ${photoUrls.length} photos!`)
```


## Generate and Save a Color Palette

```typescript
// Name: Save Color Palette
// Description: Generates a color palette and saves it as a JSON file
// Author: johnlindquist

import "@johnlindquist/kit"
import Vibrant from "node-vibrant"

// Prompt the user to select an image file
const imagePath = await path({
  hint: "Select an image", 
})

// Analyze the image using Vibrant.js to extract a color palette
const palette = await Vibrant.from(imagePath).getPalette() 

// Extract the color swatches from the palette 
const swatches = Object.entries(palette).map(([name, swatch]) => { 
  return {
    name,
    hex: swatch.hex,
    rgb: swatch.rgb.join(", "), // Join the RGB values with commas
    population: swatch.population,
  }
})

// Prompt the user to enter a filename for the palette 
const fileName = await arg("Enter file name for the palette:")

// Create a JSON file with the extracted color swatches 
await writeJson(fileName, swatches, { spaces: 2 }) 

// Display a notification
await notify(`Color palette saved as: ${fileName}`)
```

## Create a New GitHub Pull Request

```typescript 
// Name: Create Pull Request
// Description: Creates a new pull request on GitHub
// Author: johnlindquist

import "@johnlindquist/kit"
import { Octokit } from "@octokit/rest"

// Authenticate with the GitHub API
const octokit = new Octokit({ 
  auth: await env("GITHUB_PERSONAL_ACCESS_TOKEN", {
    hint: `Grab a key from <a href="https://github.com/settings/tokens">here</a>`,
  }),
})

// Prompt for the repository information
const [owner, repo] = (await arg("Enter repository name (e.g., user/repo):")).split("/") 

// Prompt for the pull request details
const title = await arg("Enter pull request title:") 
const head = await arg("Enter head branch:") 
const base = await arg("Enter base branch:")
const body = await textarea({ placeholder: "Enter pull request body (optional):" })

try { 
  // Create a pull request using the GitHub API 
  const { data } = await octokit.pulls.create({
    owner, 
    repo, 
    title,
    head,
    base,
    body, 
  }) 

  // Display a notification and open the pull request in the browser 
  await notify("Pull request created!")
  await open(data.html_url) 
} catch (error) { 
  // Handle any errors during pull request creation
  await div(md(`# Error creating pull request: ${error.message}`)) 
}
```

##  Check Website Load Time

```typescript
// Name: Check Website Load Time
// Description: Measures the load time of a website using the 'performance' API
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user for the website URL
const websiteUrl = await arg("Enter website URL:")

// Measure the website's load time using the `performance` API
const startTime = performance.now()
await get(websiteUrl) 
const endTime = performance.now() 
const loadTime = endTime - startTime

// Display the load time in milliseconds
await div(md(`# Load time: ${loadTime.toFixed(2)}ms`))
```

## Create a New File and Append Text

```typescript
// Name: Append to File
// Description: Creates a new file (or appends to an existing one) and appends text from the editor
// Author: johnlindquist 

import "@johnlindquist/kit"

// Prompt for the file path 
const filePath = await path() 

// Prompt for the text to append, opening the editor with an appropriate placeholder
const content = await editor({
  placeholder: `Enter content to append to ${filePath}`,
})

// Append the content to the file
await appendFile(filePath, content)

// Display a notification
await notify(`Content appended to: ${filePath}`)
```

##  Convert a Video to MP3

```typescript
// Name: Extract Audio
// Description: Extracts audio from a video file and saves it as an MP3 
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt the user to select a video file 
const videoFilePath = await path({
  hint: "Select a video file", 
}) 

// Construct the FFmpeg command to extract the audio and convert it to MP3
const command = `ffmpeg -i "${videoFilePath}" -vn -acodec libmp3lame -q:a 2 "${videoFilePath.replace(/\.[^/.]+$/, "")}.mp3"`

// Execute the FFmpeg command in the terminal 
await term({ 
  command,
  height: 140, 
  enter: "Close Terminal",
})

// Display a notification 
await notify("Audio extracted to MP3!")
```

##  Get a Random Wikipedia Article Summary

```typescript
// Name: Random Wikipedia Summary
// Description: Displays a random Wikipedia article summary
// Author: johnlindquist

import "@johnlindquist/kit"
import axios from "axios" 

// Fetch a random Wikipedia article summary from the API
const { data: { extract, title, content_urls: { desktop: { page } } } } = await axios.get( 
  "https://en.wikipedia.org/api/rest_v1/page/random/summary"
) 

// Prompt the user to choose an action
const choice = await arg("Choose an action:", ["Read Summary", "Open Page"]) 

// If the user selects "Read Summary", display the summary in a div
if (choice === "Read Summary") { 
  await div(md(`
## ${title}

${extract}
`))
} else if (choice === "Open Page") {
  // If the user selects "Open Page", open the article in their browser 
  await open(page) 
} 
```

##  Generate a Random Joke and Send It to a Discord Channel

```typescript
// Name: Discord Joke Bot
// Description: Sends a random joke to a Discord channel 
// Author: johnlindquist

import "@johnlindquist/kit" 
import axios from "axios" 
import Discord from "discord.js" 

// Get your Discord bot token at https://discord.com/developers/applications 
const DISCORD_BOT_TOKEN = await env("DISCORD_BOT_TOKEN")

// Prompt for the Discord channel ID 
const channelId = await env("DISCORD_CHANNEL_ID", {
  hint: "Enter your Discord Channel ID", 
})

// Create a new Discord client instance
const client = new Discord.Client({
  intents: [Discord.GatewayIntentBits.Guilds, Discord.GatewayIntentBits.GuildMessages],
}) 

client.on("ready", async () => {
  // Get the channel object using the provided channel ID 
  const channel = await client.channels.fetch(channelId) 

  // Fetch a random joke from the JokeAPI
  const jokeResponse = await axios.get("https://v2.jokeapi.dev/joke/Any?safe-mode") 

  // Extract the joke from the response
  const joke = jokeResponse.data.setup
    ? `${jokeResponse.data.setup}\n\n${jokeResponse.data.delivery}` // If it's a two-part joke 
    : jokeResponse.data.joke // If it's a single-part joke

  // Send the joke to the Discord channel
  try {
    if (channel.isTextBased()) {
      await (channel as Discord.TextChannel).send(joke)
      await div(md(`# Joke sent to ${channel}! ðŸ˜‚`)) 
    }
  } catch (error) { 
    await div(md(`# Error sending joke: ${error}`))
  } finally {
    // Disconnect the client after sending the joke
    client.destroy() 
  } 
})

// Log in the client using the bot token
client.login(DISCORD_BOT_TOKEN) 
``` 

## Get a List of Spotify Devices

```typescript
// Name: Spotify Devices
// Description: Lists your available Spotify devices and allows you to select one
// Author: johnlindquist

import "@johnlindquist/kit"
import SpotifyWebApi from "spotify-web-api-node" 

// Get your Spotify Client ID and Secret from https://developer.spotify.com/dashboard/applications
const SPOTIFY_CLIENT_ID = await env("SPOTIFY_CLIENT_ID")
const SPOTIFY_CLIENT_SECRET = await env("SPOTIFY_CLIENT_SECRET")

// Create a Spotify API client
const spotifyApi = new SpotifyWebApi({
  clientId: SPOTIFY_CLIENT_ID, 
  clientSecret: SPOTIFY_CLIENT_SECRET,
  redirectUri: "http://localhost:8888/callback", // You can use any valid redirect URI here
})

// Retrieve an access token
const { body: { access_token: accessToken } } = await spotifyApi.clientCredentialsGrant() 
spotifyApi.setAccessToken(accessToken)

// Get a list of available Spotify devices
const { body: { devices } } = await spotifyApi.getMyDevices()

// Create choices from the available devices 
const deviceChoices = devices.map(device => ({ 
  name: `${device.name} (${device.type})`, 
  value: device.id, 
  description: device.is_active ? "Active" : "Inactive", 
}))

// Prompt the user to select a device 
const deviceId = await arg("Select a Spotify device:", deviceChoices)

// Display the selected device ID
await div(md(`# Selected Device ID: ${deviceId}`))
```

## Send a Test Email 

```typescript
// Name: Send Test Email
// Description: Sends a test email using Nodemailer
// Author: johnlindquist

import "@johnlindquist/kit"
import nodemailer from "nodemailer" 

// Prompt the user for their email credentials 
const emailUser = await env("EMAIL_USER") 
const emailPassword = await env("EMAIL_PASSWORD") 

// Create a Nodemailer transporter using SMTP
const transporter = nodemailer.createTransport({ 
  // Configure SMTP settings for your email provider (e.g., Gmail, Outlook) 
  host: "smtp.example.com",
  port: 587, 
  secure: false,
  auth: {
    user: emailUser,
    pass: emailPassword, 
  },
})

// Send a test email to the user's email address 
try {
  await transporter.sendMail({ 
    from: emailUser,
    to: emailUser, 
    subject: "Test Email from Script Kit",
    text: "This is a test email sent from a Script Kit script.", 
  }) 
  await div(md(`# Test email sent successfully! ðŸŽ‰`))
} catch (error) {
  await div(md(`# Error sending test email: ${error}`))
}
```

## Create a New File from a Template with Replacements

```typescript 
// Name: Create File from Template with Replacements
// Description: Creates a new file from a template, replacing placeholders with user input 
// Author: johnlindquist 

import "@johnlindquist/kit"

// Prompt the user to select a template file 
const templateFile = await path({ 
  hint: "Select a template file",
})

// Read the template file contents 
const templateContent = await readFile(templateFile, "utf8")

// Prompt for the placeholder values 
const placeholder1 = await arg("Enter value for placeholder 1:") 
const placeholder2 = await arg("Enter value for placeholder 2:")

// Replace placeholders in the template with the entered values
const newFileContent = templateContent 
  .replace("{{placeholder1}}", placeholder1)
  .replace("{{placeholder2}}", placeholder2) 

// Prompt for the new file's name
const fileName = await arg("Enter file name:") 

// Create the new file with the replaced content
await writeFile(fileName, newFileContent)

// Open the newly created file in the editor 
await edit(fileName) 
```

## Get a List of Your GitHub Repositories

```typescript
// Name: My GitHub Repositories
// Description: Lists your GitHub repositories and allows you to select one to open
// Author: johnlindquist 

import "@johnlindquist/kit" 
import { Octokit } from "@octokit/rest"

// Authenticate with the GitHub API
const octokit = new Octokit({
  auth: await env("GITHUB_PERSONAL_ACCESS_TOKEN", {
    hint: `Grab a key from <a href="https://github.com/settings/tokens">here</a>`, 
  }),
})

// Fetch a list of the authenticated user's repositories
const repos = await octokit.repos.listForAuthenticatedUser({ sort: "pushed", per_page: 100 })

// Create choices from the repositories 
const repoChoices = repos.data.map(repo => ({
  name: repo.full_name,
  value: repo.html_url,
  description: repo.description, 
})) 

// Prompt the user to select a repository from the list 
const selectedRepoUrl = await arg("Select a repository:", repoChoices)

// Open the selected repository in the browser
open(selectedRepoUrl)
```

##  Check Your Local Weather

```typescript
// Name: Check Weather
// Description: Displays the current weather for your location
// Author: johnlindquist

import "@johnlindquist/kit"
import axios from "axios"

// Get your OpenWeatherMap API key from https://openweathermap.org/api 
const OPENWEATHERMAP_API_KEY = await env("OPENWEATHERMAP_API_KEY")

// Get the user's current location
let location = await new Promise((resolve, reject) => { 
  navigator.geolocation.getCurrentPosition(
    (position) => {
      resolve({ latitude: position.coords.latitude, longitude: position.coords.longitude }) 
    },
    reject,
    { 
      // Request high accuracy location
      enableHighAccuracy: true, 
      // Set a timeout for the location request (in milliseconds)
      timeout: 5000, 
      // Use cached location data if available (maximum age in milliseconds)
      maximumAge: 0,
    } 
  ); 
})

// Fetch weather data from OpenWeatherMap using the user's location
const response = await axios.get(`https://api.openweathermap.org/data/2.5/weather?lat=${location.latitude}&lon=${location.longitude}&appid=${OPENWEATHERMAP_API_KEY}&units=metric`)

// Extract weather information from the response
const { name: city, main, weather } = response.data 
const { temp, feels_like: feelsLike, humidity } = main
const description = weather[0].description 

// Display the weather information 
await div(
  md(`
  ## Weather in ${city}

  * Temperature: ${temp}Â°C 
  * Feels Like: ${feelsLike}Â°C 
  * Humidity: ${humidity}% 
  * Description: ${description}
  `)
)
``` 

##  Generate a Random Kanye West Quote and Post to Twitter

```typescript
// Name: Tweet Kanye Quote
// Description: Tweets a random Kanye West quote
// Author: johnlindquist 

import "@johnlindquist/kit"
import axios from "axios" 
import Twitter from "twitter-lite"

// Get Twitter API keys from the environment
// You can get API keys at https://developer.twitter.com/en/portal/dashboard 
const consumerKey = await env("TWITTER_CONSUMER_KEY") 
const consumerSecret = await env("TWITTER_CONSUMER_SECRET")
const accessTokenKey = await env("TWITTER_ACCESS_TOKEN_KEY") 
const accessTokenSecret = await env("TWITTER_ACCESS_TOKEN_SECRET")

// Initialize the Twitter client 
const twitterClient = new Twitter({
  consumer_key: consumerKey, 
  consumer_secret: consumerSecret, 
  access_token_key: accessTokenKey, 
  access_token_secret: accessTokenSecret,
})

// Fetch a random Kanye West quote
const quote = await get("https://api.kanye.rest/").then(
  response => response.data.quote
)

// Post the quote as a tweet
try {
  await twitterClient.post("statuses/update", { status: quote }) 
  await div(md(`# Kanye quote tweeted: ${quote}`))
} catch (error) {
  await div(md(`# Error tweeting quote: ${error}`))
}
```

## Get a List of Files Modified Today

```typescript
// Name: Files Modified Today
// Description: Lists files modified today in the current directory
// Author: johnlindquist 

import "@johnlindquist/kit"

// Get the current date
const today = new Date()
today.setHours(0, 0, 0, 0) // Set the time to the beginning of the day

// Get a list of files in the current directory 
const files = await readdir(".")

// Filter the list to only include files modified today
const modifiedToday = files.filter(async file => {
  const stats = await stat(file)
  return stats.mtimeMs > today.getTime()
})

// If files were modified today, display them as choices
if (modifiedToday.length > 0) { 
  await arg({
    placeholder: "Files modified today:",
    enter: "Select File",
  }, modifiedToday) 
} else { 
  // Otherwise, display a message
  await div(md("# No files modified today."))
}
``` 

## Generate TypeScript Types from a GraphQL Schema

```typescript
// Name: GraphQL to TypeScript
// Description: Generates TypeScript types from a GraphQL schema using the graphql-codegen CLI 
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user to enter a GraphQL schema URL 
const schemaUrl = await arg({
  placeholder: "Enter GraphQL schema URL:",
})

// Prompt the user to select an output directory for the generated types 
const outputDir = await path({
  hint: "Select output directory", 
  onlyDirs: true,
})

// Construct the graphql-codegen command 
const command = `npx graphql-codegen --schema ${schemaUrl} --target typescript --generates ${outputDir}/types.ts`

// Execute the graphql-codegen command in the terminal
await term({
  command, 
  height: 140,
  enter: "Exit Terminal",
})

// Display a notification
await notify("TypeScript types generated!")
```

##  Compress a PDF File

```typescript
// Name: Compress PDF
// Description: Compresses a PDF file using the ilovepdf.com API
// Author: johnlindquist

import "@johnlindquist/kit"
import axios from "axios"
import FormData from "form-data"

// Get the ilovepdf.com public API key from https://developer.ilovepdf.com/ 
const publicKey = await env("ILOVEPDF_PUBLIC_KEY")

// Prompt the user to select a PDF file
const pdfFilePath = await path({
  hint: "Select a PDF file",
})

// Construct the ilovepdf.com API endpoint URL 
const apiUrl = "https://api.ilovepdf.com/v1/start"

// Create a FormData instance to send the file
const formData = new FormData() 
formData.append("task", JSON.stringify({ tool: "compress" }))
formData.append("file", createReadStream(pdfFilePath), {
  filename: path.basename(pdfFilePath), 
})

// Initiate the compression task 
const startResponse = await axios.post(apiUrl, formData, {
  headers: {
    ...formData.getHeaders(),
    Authorization: `Bearer ${publicKey}`,
  },
}) 

// Get the task ID from the response
const taskId = startResponse.data.server_filename 

// Construct the URL for getting the compressed file
const downloadUrl = `https://api.ilovepdf.com/v1/download/${taskId}`

// Download the compressed PDF file
const compressedPdfBuffer = await download(downloadUrl, undefined, { 
  headers: {
    Authorization: `Bearer ${publicKey}`,
  },
})

// Save the compressed PDF file to the Downloads directory 
const compressedPdfPath = path.join(home("Downloads"), `${path.basename(pdfFilePath)}-compressed.pdf`) 
await writeFile(compressedPdfPath, compressedPdfBuffer)

// Display a notification 
await notify(`PDF compressed and saved to: ${compressedPdfPath}`) 
```

## Get a List of Open Windows

```typescript
// Name: List Windows
// Description: Lists all open windows 
// Author: johnlindquist

import "@johnlindquist/kit"

// Get a list of open windows
const windows = await getWindows()

// Create choices from the window list 
const windowChoices = windows.map(window => ({
  name: window.title, 
  value: window, 
  description: window.process, 
}))

// Prompt the user to select a window
const selectedWindow = await arg(
  {
    placeholder: "Select a window:", 
    enter: "Get Info", 
  },
  windowChoices
)

// Display information about the selected window
await div(md(`
## Window Information

* **Title:** ${selectedWindow.title}
* **Process:** ${selectedWindow.process} 
* **Index:** ${selectedWindow.index}
`))
```

## Get System Memory Usage

```typescript
// Name: Memory Usage
// Description: Displays the current memory usage 
// Author: johnlindquist

import "@johnlindquist/kit"
import os from "os"

// Function to calculate memory usage percentage 
const getMemoryUsage = () => { 
  const totalMemory = os.totalmem() 
  const freeMemory = os.freemem()
  const usedMemory = totalMemory - freeMemory
  const usagePercentage = (usedMemory / totalMemory) * 100 

  return usagePercentage.toFixed(2)
}

// Create a widget to display the memory usage 
const memoryWidget = await widget(
  `<div class="p-4 text-2xl">{{memoryUsage}}%</div>`, 
  {
    width: 100, 
    height: 50,
    alwaysOnTop: true,
    state: {
      memoryUsage: getMemoryUsage(),
    }, 
  } 
) 

// Update the widget's state with the latest memory usage every second
setInterval(() => {
  memoryWidget.setState({ memoryUsage: getMemoryUsage() }) 
}, 1000)
```

## Create and Share a Public GitHub Repository

```typescript 
// Name: Create Public GitHub Repo 
// Description: Creates a new public GitHub repository
// Author: johnlindquist

import "@johnlindquist/kit"
import { Octokit } from "@octokit/rest" 

// Authenticate with the GitHub API 
const octokit = new Octokit({
  auth: await env("GITHUB_PERSONAL_ACCESS_TOKEN", {
    hint: `Grab a key from <a href="https://github.com/settings/tokens">here</a>`,
  }), 
}) 

// Prompt for the repository name and description
const name = await arg("Enter repository name:") 
const description = await arg("Enter repository description:")

// Create the public repository 
try {
  const response = await octokit.repos.createForAuthenticatedUser({
    name,
    description,
    private: false, // Set to false for a public repository
  }) 
  // Display the repository URL and copy it to the clipboard
  const repoUrl = response.data.html_url 
  await copy(repoUrl) 
  await div(
    md(`
    ## Public Repository Created:

    - [${repoUrl}](${repoUrl}) (copied to clipboard)
    `)
  )
} catch (error) { 
  // Handle any errors that may occur during repository creation 
  await div(md(`# Error creating repository: ${error.message}`))
} 
```

## Check Website Uptime

```typescript
// Name: Check Uptime
// Description: Checks the uptime of a website using the 'is-up' library 
// Author: johnlindquist

import "@johnlindquist/kit" 
import isUp from "is-up" 

// Prompt the user to enter the website URL 
const urlToCheck = await arg("Enter website URL:")

// Check the website uptime using the 'is-up' library 
if (await isUp(urlToCheck)) { 
  // Display a success message if the website is up
  await div(md(`# ${urlToCheck} is up! âœ…`)) 
} else { 
  // Display an error message if the website is down 
  await div(md(`# ${urlToCheck} is down! âŒ`))
}
```

## Send a Message to a Telegram Chat

```typescript
// Name: Send Telegram Message 
// Description: Sends a message to a Telegram chat using the telegraf library
// Author: johnlindquist

import "@johnlindquist/kit"
import { Telegraf } from "telegraf"

// Get the Telegram bot token from the environment 
// Create a new bot and get your token at https://t.me/BotFather
const TELEGRAM_BOT_TOKEN = await env("TELEGRAM_BOT_TOKEN")

// Create a new Telegraf instance using the bot token
const bot = new Telegraf(TELEGRAM_BOT_TOKEN)

// Prompt the user to enter the chat ID 
const chatId = await env("TELEGRAM_CHAT_ID", { hint: "Enter the Telegram Chat ID" })

// Prompt for the message
const message = await arg("Enter your message:") 

// Start the bot and send the message
bot.launch().then(async () => {
  try {
    // Send the message to the specified chat
    await bot.telegram.sendMessage(chatId, message)
    await div(md(`# Message sent successfully!`)) 
  } catch (error) { 
    await div(md(`# Error sending message: ${error}`))
  } finally {
    // Stop the bot after sending the message
    bot.stop() 
  } 
}) 
``` 

## Get and Set the System Clipboard

```typescript
// Name: Clipboard Manager
// Description: Gets the current clipboard content and allows setting new content
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the current clipboard content 
let clipboardContent = await clipboard.readText() 

// Prompt the user to choose an action
let action = await arg("Choose an action:", ["View Clipboard", "Set Clipboard"])

if (action === "View Clipboard") {
  // Display the current clipboard content in the editor 
  await editor(clipboardContent)
} else if (action === "Set Clipboard") { 
  // Prompt the user for new clipboard content
  const newContent = await arg("Enter new clipboard content:") 
  // Set the new content to the clipboard
  await clipboard.writeText(newContent)
  // Display a notification
  await notify("Clipboard updated!")
}
```

## Get a List of Running Processes

```typescript
// Name: Process Viewer
// Description: Lists running processes and their details
// Author: johnlindquist

import "@johnlindquist/kit"

// Get a list of running processes 
const processes = await getProcesses()

// Create choices from the process list, including process ID, name, and path
const processChoices = processes.map(process => ({
  name: `${process.pid} - ${process.name}`,
  value: process, 
  description: process.path,
})) 

// Prompt the user to select a process 
const selectedProcess = await arg({ placeholder: "Select a process:" }, processChoices)

// Display detailed information about the selected process
await div(
  md(`
## Process Information:

* **PID:** ${selectedProcess.pid}
* **Name:** ${selectedProcess.name}
* **Path:** ${selectedProcess.path}
* **CPU Usage:** ${selectedProcess.cpu}%
* **Memory Usage:** ${filesize(selectedProcess.memory)}
`)
)
```

## Convert a Web Page to a PDF

```typescript
// Name: Webpage to PDF
// Description: Converts a webpage to PDF using Puppeteer
// Author: johnlindquist

import "@johnlindquist/kit"
import puppeteer from "puppeteer"

// Prompt the user for the webpage URL 
const webpageUrl = await arg("Enter webpage URL:")

// Launch a headless browser instance using Puppeteer 
const browser = await puppeteer.launch({ headless: "new" })
const page = await browser.newPage()

// Navigate to the specified webpage
await page.goto(webpageUrl, { waitUntil: "networkidle0" }) // Wait for the network to be idle before generating the PDF 

// Generate the PDF from the webpage
const pdfBuffer = await page.pdf()

// Close the browser instance 
await browser.close()

// Prompt the user to select a directory to save the PDF 
const outputDir = await path({
  hint: "Select output directory", 
  onlyDirs: true,
}) 

// Save the PDF to the selected directory with a timestamped file name
const timestamp = new Date().toISOString().replace(/[:.-]/g, "_")
const pdfFilePath = path.join(outputDir, `webpage-${timestamp}.pdf`)
await writeFile(pdfFilePath, pdfBuffer)

// Display a notification 
await notify(`PDF saved to: ${pdfFilePath}`)
```

## Upload a File to Amazon S3 with Progress

```typescript
// Name: Upload to S3 with Progress
// Description: Uploads a file to Amazon S3 with a progress bar 
// Author: johnlindquist

import "@johnlindquist/kit" 
import AWS from "aws-sdk"

// Get AWS credentials and bucket name from environment variables 
const awsAccessKeyId = await env("AWS_ACCESS_KEY_ID") 
const awsSecretAccessKey = await env("AWS_SECRET_ACCESS_KEY")
const awsBucketName = await env("AWS_BUCKET_NAME")

// Prompt the user to select a file 
const filePath = await path({ 
  hint: "Select a file to upload",
}) 

// Create a div to display the progress bar
const progressDiv = await div({ 
  html: md(`# Uploading...`),
  progressBar: true, 
  resize: false, 
  height: 120, 
}) 

// Create an S3 instance 
const s3 = new AWS.S3({
  accessKeyId: awsAccessKeyId,
  secretAccessKey: awsSecretAccessKey,
})

// Read the file contents as a buffer 
const fileContent = await readFile(filePath) 

// Upload the file to the specified S3 bucket with progress tracking
s3.upload( 
  {
    Bucket: awsBucketName,
    Key: path.basename(filePath), 
    Body: fileContent,
  }, 
  (err, data) => {
    if (err) { 
      console.error("Error uploading file:", err) 
      progressDiv.setState({ html: md(`# Upload failed!`) }) 
    } else {
      console.log("File uploaded successfully:", data.Location)
      // Update the progress div to indicate completion 
      progressDiv.setState({ html: md(`# Upload complete! ðŸŽ‰`) }) 
    } 
  }
)
  .on("httpUploadProgress", (progress) => { 
    // Update the progress bar based on upload progress
    setProgress(Math.round((progress.loaded / progress.total) * 100))
  }) 
```

## Create and Send a Tweet with Image

```typescript
// Name: Tweet with Image 
// Description: Creates a tweet with an image using the Twitter API
// Author: johnlindquist 

import "@johnlindquist/kit"
import Twitter from "twitter-lite" 

// Get Twitter API keys from environment variables
// You can get API keys at https://developer.twitter.com/en/portal/dashboard 
const consumerKey = await env("TWITTER_CONSUMER_KEY")
const consumerSecret = await env("TWITTER_CONSUMER_SECRET")
const accessTokenKey = await env("TWITTER_ACCESS_TOKEN_KEY") 
const accessTokenSecret = await env("TWITTER_ACCESS_TOKEN_SECRET")

// Initialize the Twitter client 
const client = new Twitter({ 
  consumer_key: consumerKey,
  consumer_secret: consumerSecret,
  access_token_key: accessTokenKey, 
  access_token_secret: accessTokenSecret, 
})

// Prompt the user to select an image file
const imagePath = await path({ 
  hint: "Select an image",
})

// Read the image file as a Buffer 
const imageBuffer = await readFile(imagePath)

// Upload the image to Twitter 
const mediaUploadResponse = await client.post("media/upload", { media_data: imageBuffer.toString("base64") }) 

// Prompt for the tweet content
const status = await arg("Enter tweet text:")

// Post the tweet with the uploaded image
try {
  await client.post("statuses/update", {
    status, 
    media_ids: mediaUploadResponse.media_id_string,
  }) 
  await div(md(`# Tweet sent! ðŸŽ‰`)) 
} catch (error) {
  await div(md(`# Error sending tweet: ${error}`)) 
}
```

##  Get a List of Files in a Directory, Sorted by Size

```typescript
// Name: List Files by Size 
// Description: Lists files in a directory, sorted by size
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user to select a directory
const directoryPath = await path({
  hint: "Select a directory",
  onlyDirs: true, 
})

// Get the list of files in the selected directory 
const files = await readdir(directoryPath) 

// Get the size of each file and create an array of objects with name, size, and formatted size
const filesWithSizes = await Promise.all(
  files.map(async file => {
    const { size } = await stat(path.join(directoryPath, file))
    return {
      name: file,
      size,
      formattedSize: filesize(size),
    } 
  }) 
)

// Sort the files by size in descending order 
filesWithSizes.sort((a, b) => b.size - a.size)

// Create an array of choices from the sorted file list, including formatted size information
const fileChoices = filesWithSizes.map(file => ({
  name: file.name,
  value: path.join(directoryPath, file.name),
  description: file.formattedSize,
}))

// Prompt the user to select a file from the sorted list
await arg({ placeholder: "Select a file (sorted by size):" }, fileChoices) 
```

## Create a New Branch in a Git Repository and Push It

```typescript 
// Name: Create and Push Git Branch 
// Description: Creates a new branch and pushes it to the remote repository
// Author: johnlindquist 

import "@johnlindquist/kit" 

// Prompt for the new branch name
const branchName = await arg("Enter new branch name:") 

// Create the new branch 
await $`git checkout -b ${branchName}`

// Push the new branch to the remote repository 
await $`git push origin ${branchName}`

// Display a success message 
await div(md(`## Created and pushed branch: ${branchName}`))
```


## Get System Battery Information

```typescript
// Name: Battery Info
// Description: Displays the current battery status and information
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the battery information
const battery = await global.getBattery()

// Format the battery information
const batteryInfo = `
## Battery Info

* **Level:** ${Math.round(battery.level * 100)}%
* **Charging:** ${battery.isCharging ? "Yes" : "No"}
* **Time Remaining:** ${battery.timeRemaining ? `${Math.round(battery.timeRemaining / 60)} minutes` : "Calculating..."} 
* **AC Connected:** ${battery.isPlugged ? "Yes" : "No"}
`

// Display the battery information in a div
await div(md(batteryInfo)) 
```

## Generate a QR Code for the Current URL in Browser

```typescript
// Name: QR Code for Current URL 
// Description: Generates a QR code for the URL of the active browser tab
// Author: johnlindquist

import "@johnlindquist/kit"
import qrcode from "qrcode" 

// Get the URL of the active browser tab
const currentUrl = await getActiveTab() 

// Generate a QR code for the current URL
const qrCodeImage = await qrcode.toDataURL(currentUrl) 

// Display the QR code in a div
await div(`<img src="${qrCodeImage}" alt="QR Code" />`)
``` 

## Find and Replace Text in a String

```typescript
// Name: Find and Replace Text
// Description: Finds and replaces text in a string using String.prototype.replaceAll()
// Author: johnlindquist 

import "@johnlindquist/kit"

// Prompt for the input text 
const text = await arg("Enter text:")

// Prompt for the text to search for 
const searchText = await arg("Enter text to find:") 

// Prompt for the replacement text
const replaceText = await arg("Enter replacement text:")

// Replace all occurrences of the search text with the replacement text
const newText = text.replaceAll(searchText, replaceText)

// Display the updated text in the editor 
await editor(newText)
```

##  Send a Message to a Telegram Group

```typescript
// Name: Send Telegram Group Message 
// Description: Sends a message to a Telegram group using the telegraf library
// Author: johnlindquist

import "@johnlindquist/kit"
import { Telegraf } from "telegraf" 

// Get the Telegram bot token from the environment
// You can create a bot and get a token at https://t.me/BotFather 
const TELEGRAM_BOT_TOKEN = await env("TELEGRAM_BOT_TOKEN")

// Prompt the user to enter the group chat ID
const chatId = await env("TELEGRAM_GROUP_CHAT_ID", {
  hint: "Enter the Telegram Group Chat ID",
}) 

// Create a new Telegraf instance
const bot = new Telegraf(TELEGRAM_BOT_TOKEN) 

// Prompt the user for the message 
const message = await arg("Enter message:") 

// Start the bot and send the message 
bot.launch().then(async () => {
  try {
    // Send the message to the specified group chat 
    await bot.telegram.sendMessage(chatId, message)
    await div(md(`# Message sent to the group successfully! ðŸŽ‰`)) 
  } catch (error) { 
    await div(md(`# Error sending message: ${error}`)) 
  } finally {
    // Stop the bot after sending the message
    bot.stop()
  } 
})
```

##  Check for Available System Updates

```typescript
// Name: Check for System Updates 
// Description: Checks for available system updates and notifies the user
// Author: johnlindquist

import "@johnlindquist/kit"

// Run the 'softwareupdate --list' command to check for available updates
const { stdout } = await exec("softwareupdate --list")

// Search for the string indicating available updates
if (stdout.includes("Software Update found the following new or updated software:")) {
  // Display a notification if updates are available
  await notify("System updates are available!")
  // Optionally, open the Software Update settings 
  await exec("open -a 'Software Update'")
} else {
  // Display a message if no updates are found
  await div(md(`# No system updates found.`))
} 
``` 

## Resize and Convert Images in Bulk

```typescript 
// Name: Batch Image Resizer and Converter
// Description: Resizes and converts images in bulk using Sharp
// Author: johnlindquist

import "@johnlindquist/kit"
import sharp from "sharp"

// Prompt the user to select a directory 
const directoryPath = await path({
  hint: "Select a directory",
  onlyDirs: true,
})

// Get all image files in the directory 
const imageFiles = await globby([`${directoryPath}/*.{png,jpg,jpeg,gif,webp}`]) 

// Prompt the user to enter the desired width
const width = parseInt(await arg("Enter desired width (pixels):"))

// Prompt the user for the desired output format 
const outputFormat = await arg(
  "Select output format:", 
  ["jpeg", "png", "webp"] 
) 

// Process each image
for (const imageFile of imageFiles) {
  const outputPath = `${imageFile.replace(/\.[^/.]+$/, "")}-resized.${outputFormat}`

  try {
    // Resize the image using Sharp
    let resizedImage = sharp(imageFile).resize(width)

    // Convert to the specified output format
    switch (outputFormat) {
      case "jpeg":
        await resizedImage.jpeg({ quality: 80 }).toFile(outputPath) 
        break 
      case "png":
        await resizedImage.png({ quality: 80 }).toFile(outputPath) 
        break
      case "webp": 
        await resizedImage.webp({ quality: 80 }).toFile(outputPath) 
        break 
    }
    console.log(`Resized and converted ${imageFile} to ${outputPath}`)
  } catch (error) { 
    console.error(`Error processing ${imageFile}: ${error}`)
  } 
} 

// Display a success message 
await div(md(`## Resized and converted ${imageFiles.length} images!`))
``` 

## Get Information about an IP Address

```typescript
// Name: IP Address Lookup 
// Description: Gets information about an IP address using the ip-api.com API 
// Author: johnlindquist

import "@johnlindquist/kit"
import axios from "axios"

// Prompt the user to enter an IP address 
const ipAddress = await arg({
  placeholder: "Enter IP address:",
})

try {
  // Get information about the IP address using the ip-api.com API 
  const response = await axios.get(`http://ip-api.com/json/${ipAddress}`)

  // Extract the relevant data from the response 
  const {
    status, 
    country, 
    countryCode,
    region,
    regionName, 
    city, 
    zip,
    lat, 
    lon, 
    timezone, 
    isp, 
    org, 
    as,
    query, 
  } = response.data 

  // If the lookup was successful, display the information in a div
  if (status === "success") {
    await div(
      md(`
## IP Address Information:

* **IP Address:** ${query}
* **Country:** ${country} (${countryCode})
* **Region:** ${regionName} (${region})
* **City:** ${city}
* **Zip Code:** ${zip}
* **Latitude:** ${lat}
* **Longitude:** ${lon} 
* **Time Zone:** ${timezone}
* **ISP:** ${isp} 
* **Organization:** ${org}
* **AS:** ${as} 
    `)
    )
  } else {
    // Display an error message if the lookup failed
    await div(md(`# Error: ${response.data.message}`))
  }
} catch (error) { 
  // Handle any errors that occur during the API request
  await div(md(`# Error: ${error}`))
}
```


## Upload a File to Dropbox

```typescript
// Name: Upload to Dropbox
// Description: Uploads a file to a specified Dropbox path
// Author: johnlindquist

import "@johnlindquist/kit"
import { Dropbox } from "dropbox"

// Get your Dropbox API token at https://www.dropbox.com/developers/apps
const DROPBOX_API_TOKEN = await env("DROPBOX_API_TOKEN") 

// Initialize the Dropbox client
const dbx = new Dropbox({ accessToken: DROPBOX_API_TOKEN })

// Prompt the user to select a file to upload
const filePath = await path()

// Prompt for the destination path in Dropbox 
const destinationPath = await arg("Enter Dropbox destination path (e.g., /MyFolder/MyFile.txt):")

// Read the file contents
const fileContent = await readFile(filePath) 

try {
  // Upload the file to Dropbox 
  await dbx.filesUpload({
    path: destinationPath, 
    contents: fileContent,
    mode: { ".tag": "overwrite" }, // Overwrite the file if it already exists 
  })
  // Display a success notification 
  await notify(`File uploaded to Dropbox: ${destinationPath}`) 
} catch (error) {
  // Handle any errors that may occur during the upload process
  await div(md(`# Error uploading file: ${error.message}`)) 
}
```

## Convert Text to Speech and Play in a Widget

```typescript 
// Name: Text to Speech Widget
// Description: Converts text to speech and plays it in a widget
// Author: johnlindquist

import "@johnlindquist/kit"
import OpenAI from "openai"

// Get the OpenAI API key from the environment 
// You can sign up for an API key at https://beta.openai.com/signup/
const openai = new OpenAI({ 
  apiKey: await env("OPENAI_API_KEY"),
})

// Prompt for text input
const inputText = await arg("Enter text to speak:") 

// Convert the text to speech using OpenAI's API 
const response = await openai.audio.speech.create({
  model: "tts-1",
  voice: "alloy",
  input: inputText, 
}) 

// Convert the response to an ArrayBuffer
const arrayBuffer = await response.arrayBuffer() 
// Convert the ArrayBuffer to a Buffer
const buffer = Buffer.from(arrayBuffer)

// Create a temporary file path for the audio
const audioFilePath = tmpPath("speech.mp3") 
// Write the audio buffer to the temporary file 
await writeFile(audioFilePath, buffer) 

// Create a widget to play the audio file 
const audioWidget = await widget(`
  <audio controls> 
    <source src="${audioFilePath}" type="audio/mpeg">
  </audio>
`, {
  width: 300, 
  height: 80,
})

// Optionally, auto-play the audio when the widget loads
audioWidget.onInit(() => {
  // Execute JavaScript in the widget to start playing the audio
  audioWidget.executeJavaScript(`document.querySelector("audio").play()`)
})
```

## Generate a Color Palette from an Image and Display in a Widget

```typescript
// Name: Color Palette Widget
// Description: Generates a color palette from an image and displays it in a widget
// Author: johnlindquist

import "@johnlindquist/kit" 
import Vibrant from "node-vibrant"

// Prompt the user to select an image file
const imagePath = await path({
  hint: "Select an image",
})

// Get the color palette from the image using Vibrant.js 
const palette = await Vibrant.from(imagePath).getPalette()

// Create a string of HTML to display the color swatches 
let swatchesHTML = ""
for (const [name, swatch] of Object.entries(palette)) {
  swatchesHTML += `<div class="w-16 h-16 rounded-md" style="background-color: ${swatch.hex};"></div>`
}

// Create a widget to display the color palette
await widget(`
<div class="flex flex-row gap-2 p-4"> 
  ${swatchesHTML} 
</div> 
`, {
  width: 400,
  height: 100, 
  // Allow the user to resize the widget to see more colors
  resizable: true,
})
```

##  Get a List of Your Recent Files

```typescript
// Name: Recent Files
// Description: Lists your recent files and allows you to open them
// Author: johnlindquist

import "@johnlindquist/kit" 

// Get the user's recent files from the operating system
const recentFiles = await global.getRecentFiles()

// Create an array of choices for the recent files
const fileChoices = recentFiles.map((file) => ({
  name: file.name, 
  value: file.path, 
  description: `Last opened: ${file.lastOpened}`,
  // Add a preview to display the file's icon 
  preview: `<img src="${file.icon}" width="32" height="32" />`,
}))

// Prompt the user to select a file to open
const filePath = await arg("Open recent file:", fileChoices)

// Open the selected file in its default application 
open(filePath)
```

## Create a New Directory and Open it in VS Code

```typescript
// Name: Create and Open Directory
// Description: Creates a new directory and opens it in VS Code
// Author: johnlindquist 

import "@johnlindquist/kit"

// Prompt the user for the directory name
const directoryName = await arg({
  placeholder: "Enter directory name:",
  hint: "(The directory will be created in the current directory)", 
}) 

// Create the directory
await mkdir(directoryName)

// Open the newly created directory in VS Code 
await exec(`code ${directoryName}`) 
```

##  Convert Text to Speech and Upload to Google Drive

```typescript
// Name: Text to Speech to Drive 
// Description: Converts text to speech and uploads the audio file to Google Drive 
// Author: johnlindquist 

import "@johnlindquist/kit"
import OpenAI from "openai" 
import { google } from "googleapis" 
import { JWT } from "google-auth-library" 

// Get credentials for Google service account
let serviceAccountEmail = await env("GOOGLE_SERVICE_ACCOUNT_EMAIL")
let serviceAccountKey = await env("GOOGLE_SERVICE_ACCOUNT_KEY")

// Define the scopes and client
let jwtClient = new JWT({
  email: serviceAccountEmail,
  key: serviceAccountKey,
  scopes: ["https://www.googleapis.com/auth/drive.file"],
})

let drive = google.drive("v3") 

// Get the OpenAI API key
const openai = new OpenAI({
  apiKey: await env("OPENAI_API_KEY"),
})

// Prompt for text input 
const inputText = await arg("Enter text to convert to speech:")

// Convert text to speech using the OpenAI API 
const response = await openai.audio.speech.create({
  model: "tts-1",
  voice: "alloy", // Select a voice
  input: inputText,
}) 

// Convert the response to a Buffer 
const audioBuffer = Buffer.from(await response.arrayBuffer()) 

async function uploadAudio(auth) {
  // Prompt for the destination file name in Google Drive 
  const fileName = await arg({
    placeholder: "Enter file name for the audio (e.g., speech.mp3):",
  })

  try {
    // Upload the audio to Google Drive 
    const uploadResponse = await drive.files.create({ 
      auth, 
      requestBody: {
        name: fileName,
        parents: [await env("GOOGLE_DRIVE_FOLDER_ID", { hint: "Enter your Google Drive Folder ID" })],
      }, 
      media: { 
        mimeType: "audio/mpeg", // Set the correct MIME type for MP3
        body: audioBuffer, 
      }, 
    })
    // Display the uploaded file's URL
    await div(md(`# Audio uploaded: [${uploadResponse.data.webViewLink}](${uploadResponse.data.webViewLink})`))
  } catch (error) {
    await div(md(`# Error uploading audio: ${error}`))
  } 
} 
// Authorize the Google client and upload the audio
jwtClient.authorize((err) => {
  if (err) {
    console.log(err) 
    return 
  }
  uploadAudio(jwtClient)
})
```

## Send a Message to a Slack Channel with a File Attachment

```typescript
// Name: Send Slack Message with File
// Description: Sends a message to a Slack channel with a file attachment
// Author: johnlindquist

import "@johnlindquist/kit" 
import { WebClient } from "@slack/web-api"

// Get the Slack API token from the environment 
const slackToken = await env("SLACK_API_TOKEN") 

// Initialize the Slack Web Client
const slackClient = new WebClient(slackToken) 

// Prompt for the channel name and message
const channel = await arg("Enter channel name (e.g., #general):") 
const message = await arg("Enter message:") 

// Prompt the user to select a file to attach 
const filePath = await path({
  hint: "Select a file to attach",
})

// Send the message with the file attachment
try { 
  await slackClient.files.upload({
    channels: channel,
    initial_comment: message,
    file: createReadStream(filePath), 
  })
  await div(md(`# Message with file sent to ${channel} successfully! ðŸŽ‰`))
} catch (error) { 
  await div(md(`# Error sending message: ${error}`)) 
} 
``` 

## Create a New Todoist Task

```typescript
// Name: New Todoist Task
// Description: Creates a new task in Todoist
// Author: johnlindquist

import "@johnlindquist/kit"
import axios from "axios";

// Get your Todoist API token from https://todoist.com/prefs/integrations
const TODOIST_API_TOKEN = await env("TODOIST_API_TOKEN");

// Prompt for the task content
const taskContent = await arg("Enter task content:")

// Prompt for the project name 
const project = await arg("Enter project (optional, hit Enter to skip):", {
  strict: false,
});

// Fetch the user's projects to provide as choices 
const projectsResponse = await axios.get("https://api.todoist.com/rest/v1/projects", {
  headers: {
    Authorization: `Bearer ${TODOIST_API_TOKEN}`,
  },
});

// Prompt for a due date (optional)
const dueDate = await arg("Enter due date (YYYY-MM-DD, optional):", {
  strict: false, 
});

let projectId = null;
if (project) {
  // Find the project ID based on the entered project name 
  projectId = projectsResponse.data.find(p => p.name === project)?.id
}

// Create the new task
try { 
  await axios.post(
    "https://api.todoist.com/rest/v1/tasks",
    {
      content: taskContent,
      due_date: dueDate, 
      project_id: projectId, 
    },
    {
      headers: {
        Authorization: `Bearer ${TODOIST_API_KEY}`,
      },
    }
  ) 
  await div(md(`# Task created successfully! ðŸŽ‰`)) 
} catch (error) { 
  await div(md(`# Error creating task: ${error}`)) 
} 
```

## Resize Images to Fit a Specific Size

```typescript
// Name: Fit Image
// Description: Resizes an image to fit a specific size, maintaining aspect ratio, using Sharp 
// Author: johnlindquist

import "@johnlindquist/kit"
import sharp from "sharp"

// Prompt for the image path 
const imagePath = await path({
  hint: "Select an image file", 
})

// Prompt for the desired width and height
const width = parseInt(await arg("Enter maximum width (pixels):")) 
const height = parseInt(await arg("Enter maximum height (pixels):"))

// Resize the image using Sharp, fitting it within the specified dimensions while maintaining aspect ratio 
await sharp(imagePath)
  .resize({
    width, 
    height,
    fit: sharp.fit.inside, // Use the 'inside' fit option to ensure the image fits within the specified dimensions
  }) 
  .toFile(`${imagePath}-resized.jpg`)
```

## Get the Latest Commit Message from a Git Repository

```typescript
// Name: Get Latest Commit Message
// Description: Retrieves the latest commit message from the current Git repository
// Author: johnlindquist 

import "@johnlindquist/kit" 

// Execute the `git log` command to get the latest commit message 
const { stdout } = await exec("git log -1 --pretty=%B") 

// Display the commit message in the editor 
await editor(stdout) 
``` 

## Convert a Web Page to a Screenshot

```typescript 
// Name: Webpage Screenshot
// Description: Captures a screenshot of a webpage using Puppeteer 
// Author: johnlindquist

import "@johnlindquist/kit"
import puppeteer from "puppeteer" 

// Prompt the user for the webpage URL
const webpageUrl = await arg("Enter webpage URL:") 

// Launch a headless browser instance 
const browser = await puppeteer.launch({ headless: "new" })
const page = await browser.newPage() 

// Navigate to the specified URL
await page.goto(webpageUrl, { waitUntil: "networkidle0" }) // Wait for the network to be idle before taking the screenshot

// Capture a screenshot of the entire page 
const screenshotBuffer = await page.screenshot({ fullPage: true }) 

// Close the browser
await browser.close()

// Prompt the user to select a directory to save the screenshot
const outputDir = await path({ 
  hint: "Select output directory",
  onlyDirs: true,
})

// Save the screenshot to the selected directory 
const screenshotPath = path.join(outputDir, `screenshot-${new Date().toISOString().replace(/[:.-]/g, "_")}.png`)
await writeFile(screenshotPath, screenshotBuffer)

// Display a notification
await notify(`Screenshot saved to: ${screenshotPath}`) 
```

## Scan a Document and Extract Text with Tesseract OCR

```typescript
// Name: Scan and Extract Text 
// Description: Scans a document using the system scanner and extracts text using Tesseract OCR
// Author: johnlindquist

import "@johnlindquist/kit"
import Tesseract from "tesseract.js"

// Prompt the user to choose a scanning mode
const scanMode = await arg("Select scan mode:", ["Color", "Grayscale", "Black and White"])

// Initiate the system scan process with the chosen mode 
const scannedImagePath = await global.scanDocument(scanMode) 

// Recognize text from the scanned image using Tesseract OCR
const { data: { text } } = await Tesseract.recognize(scannedImagePath)

// Display the extracted text in the editor
await editor({ 
  value: text,
  language: "text",
})
``` 

## Generate a Random Quote and Display in a Stylish Widget

```typescript
// Name: Quote Widget
// Description: Displays a random quote in a stylish widget
// Author: johnlindquist

import "@johnlindquist/kit"
import axios from "axios"

// Fetch a random quote from the Quotable API 
const { data: { content, author } } = await axios.get("https://api.quotable.io/random")

// Create a widget to display the quote 
await widget(`
<div class="flex flex-col items-center p-4 rounded-lg shadow-md bg-gradient-to-r from-purple-500 to-pink-500"> 
  <p class="text-white text-xl font-bold">"{{quote}}"</p>
  <p class="text-gray-200 mt-4">- {{author}}</p>
</div>
`, { 
  width: 500,
  height: 180,
  state: {
    quote: content,
    author: author,
  }, 
  // Set the widget to be draggable
  draggable: true,
})
```

## Get a List of Your Google Calendar Events

```typescript
// Name: List Google Calendar Events 
// Description: Displays upcoming events from your Google Calendar 
// Author: johnlindquist

import "@johnlindquist/kit"
import { google } from "googleapis" 
import { JWT } from "google-auth-library"

// Get credentials for Google service account through environment variables
let serviceAccountEmail = await env("GOOGLE_SERVICE_ACCOUNT_EMAIL")
let serviceAccountKey = await env("GOOGLE_SERVICE_ACCOUNT_KEY")

// Define the scopes and client 
let jwtClient = new JWT({ 
  email: serviceAccountEmail,
  key: serviceAccountKey,
  scopes: ["https://www.googleapis.com/auth/calendar.readonly"], 
})

let calendar = google.calendar("v3")

async function listEvents(auth) {
  try {
    // List upcoming events from the user's primary calendar 
    const response = await calendar.events.list({ 
      auth,
      calendarId: "primary",
      timeMin: new Date().toISOString(), // Get events starting from now
      maxResults: 10, // Limit the number of results 
      singleEvents: true,
      orderBy: "startTime", 
    }) 

    // Create choices from the retrieved events
    const eventChoices = response.data.items.map(event => ({
      name: event.summary,
      value: event, 
      description: `${event.start.dateTime} - ${event.end.dateTime}`,
    }))

    // Prompt the user to select an event
    const selectedEvent = await arg(
      {
        placeholder: "Select an event:",
      }, 
      eventChoices
    )

    // Display detailed information about the selected event 
    await div(md(`
## Event Details: 

* **Summary:** ${selectedEvent.summary} 
* **Location:** ${selectedEvent.location || "N/A"}
* **Start Time:** ${selectedEvent.start.dateTime}
* **End Time:** ${selectedEvent.end.dateTime} 
* **Description:** ${selectedEvent.description || "N/A"}
`))
  } catch (error) {
    // Handle any errors that occur 
    await div(md(`# Error: ${error.message}`)) 
  } 
}
// Authorize the client and list events 
jwtClient.authorize((err) => {
  if (err) {
    console.log(err)
    return
  } 
  listEvents(jwtClient) 
}) 
``` 



## Get a Random Wikipedia Article and Summarize it

```typescript
// Name: Random Wikipedia Summary
// Description: Fetches a random Wikipedia article and summarizes it using OpenAI
// Author: johnlindquist

import "@johnlindquist/kit"
import axios from "axios"
import OpenAI from "openai"

// Get your OpenAI API key at https://beta.openai.com/account/api-keys
const openai = new OpenAI({
  apiKey: await env("OPENAI_API_KEY"), 
})

// Fetch a random Wikipedia article 
const response = await axios.get("https://en.wikipedia.org/api/rest_v1/page/random/summary")

// Extract the article title and content 
const { extract, title, content_urls: { desktop: { page: articleUrl } } } = response.data

// Prompt the user to choose an action: open the article or summarize it
const action = await arg("Choose an action:", ["Summarize", "Open Article"])

if (action === "Open Article") {
  // Open the article in the browser
  await open(articleUrl) 
} else if (action === "Summarize") { 
  // Summarize the article using OpenAI's API
  const summaryResponse = await openai.chat.completions.create({ 
    model: "gpt-3.5-turbo",
    messages: [
      {
        role: "user",
        content: `Please provide a concise summary of the following Wikipedia article:\n\n${extract}`,
      }, 
    ],
  })

  // Display the summary in a div 
  await div(md(`
## Summary of ${title}:

${summaryResponse.choices[0].message.content}
  `))
}
```

## Create a New GitHub Issue with a Screenshot Attachment

```typescript
// Name: Create GitHub Issue with Screenshot
// Description: Creates a new GitHub issue with a screenshot attached 
// Author: johnlindquist 

import "@johnlindquist/kit" 
import { Octokit } from "@octokit/rest"

// Authenticate with the GitHub API
const octokit = new Octokit({
  auth: await env("GITHUB_PERSONAL_ACCESS_TOKEN", {
    hint: `Grab a key from <a href="https://platform.openai.com/account/api-keys">here</a>`, 
  }),
}) 

// Prompt for the repository information 
const [owner, repo] = (await arg("Enter repository name (e.g., user/repo):")).split("/")

// Capture a screenshot 
const screenshotPath = await global.screenshot() 

// Prompt for the issue title and body
const title = await arg("Enter issue title:") 
const body = await arg("Enter issue body:")

// Upload the screenshot to the repository as an issue attachment 
const {
  data: { upload_url: uploadUrl }, 
} = await octokit.repos.createIssueAttachment({
  owner, 
  repo,
  file: (await readFile(screenshotPath)).toString("base64"), 
  name: path.basename(screenshotPath),
})

try {
  // Create the issue on GitHub, including the screenshot attachment URL
  const response = await octokit.issues.create({
    owner, 
    repo,
    title, 
    body: `${body}\n\n![Screenshot](${uploadUrl})`,
  })

  // Open the newly created issue in the browser
  open(response.data.html_url) 
} catch (error) { 
  await div(md(`# Error creating issue: ${error.message}`))
}
```

## Get System Network Information

```typescript
// Name: Network Info
// Description: Displays system network information, including IP address, network interfaces, and more
// Author: johnlindquist

import "@johnlindquist/kit"
import os from "os"

// Get system network interfaces 
const networkInterfaces = os.networkInterfaces()

// Format the network interface information for display
let networkInfo = ""
for (const [interfaceName, addresses] of Object.entries(networkInterfaces)) {
  networkInfo += `### ${interfaceName}:\n` 
  addresses.forEach(address => {
    networkInfo += `* **Family:** ${address.family}\n`
    networkInfo += `* **Address:** ${address.address}\n` 
    networkInfo += `* **Netmask:** ${address.netmask}\n` 
    networkInfo += `* **MAC Address:** ${address.mac}\n` 
    networkInfo += `* **Internal:** ${address.internal ? "Yes" : "No"}\n\n` 
  })
} 

// Get the public IP address
const publicIp = await get("https://api.ipify.org?format=json").then(response => response.data.ip) 

// Display the network information and public IP address in a div
await div(md(`
## Network Information

${networkInfo}

### Public IP Address:

${publicIp}
`))
```

##  Convert Text to a QR Code and Save as an Image

```typescript
// Name: Save QR Code
// Description: Generates a QR code from input text and saves it as an image 
// Author: johnlindquist

import "@johnlindquist/kit"
import qrcode from "qrcode" 

// Prompt the user for input text 
const text = await arg("Enter text to encode:") 

// Generate the QR code
const qrCode = await qrcode.toDataURL(text) 

// Prompt for the output file path
const outputPath = await path({ 
  hint: "Select output path",
}) 

// Extract the base64 encoded image data from the data URL
const base64Data = qrCode.replace(/^data:image\/png;base64,/, "") 

// Write the image data to the selected file 
await writeFile(outputPath, base64Data, "base64") 

// Display a notification
await notify(`QR code saved to: ${outputPath}`) 
``` 

## Create a Time-Tracking Entry with Toggl

```typescript
// Name: Start Toggl Timer 
// Description: Starts a new time-tracking entry in Toggl using the Toggl API
// Author: johnlindquist

import "@johnlindquist/kit"
import axios from "axios" 

// Get the Toggl API token from the environment 
// Find your API token at https://track.toggl.com/profile
const TOGGL_API_TOKEN = await env("TOGGL_API_TOKEN")

// Encode the API token for basic authentication
const auth = Buffer.from(`${TOGGL_API_TOKEN}:api_token`).toString("base64") 

// Prompt the user to enter a description for the time entry 
const description = await arg("Enter time entry description:")

// Fetch the user's workspaces from the Toggl API
const workspacesResponse = await axios.get("https://api.track.toggl.com/api/v8/workspaces", { 
  headers: {
    Authorization: `Basic ${auth}`,
  }, 
}) 

// Create choices from the available workspaces
const workspaceChoices = workspacesResponse.data.map(workspace => ({
  name: workspace.name, 
  value: workspace.id, 
})) 

// Prompt the user to select a workspace
const workspaceId = await arg("Select workspace:", workspaceChoices)

// Fetch the user's projects within the selected workspace 
const projectsResponse = await axios.get(
  `https://api.track.toggl.com/api/v8/workspaces/${workspaceId}/projects`, 
  {
    headers: { 
      Authorization: `Basic ${auth}`,
    },
  }
)

// Create choices from the available projects 
const projectChoices = projectsResponse.data.map(project => ({
  name: project.name, 
  value: project.id, 
}))

// Prompt the user to select a project 
const projectId = await arg("Select project:", projectChoices) 

// Start a new time entry in Toggl
try { 
  await axios.post(
    "https://api.track.toggl.com/api/v8/time_entries/start",
    {
      time_entry: {
        description: description,
        wid: workspaceId, 
        pid: projectId, 
        created_with: "Script Kit", 
      },
    }, 
    {
      headers: {
        Authorization: `Basic ${auth}`, 
      },
    }
  )

  // Display a success message and notify the user
  await div(md(`# Timer started for "${description}"!`)) 
  await notify("Toggl timer started!")
} catch (error) {
  // Handle any errors that occur during timer creation 
  await div(md(`# Error starting timer: ${error}`))
}
```

## Generate a Random Password and Display Options

```typescript
// Name: Password Options 
// Description: Generates a random password and provides options for copying or regenerating
// Author: johnlindquist 

import "@johnlindquist/kit"
import generator from "generate-password"

// Function to generate a password with default options
const generatePassword = () => {
  return generator.generate({ 
    length: 16,
    numbers: true,
    symbols: true,
    uppercase: true,
    lowercase: true, 
  }) 
}

// Create an arg prompt that allows regenerating or copying the password
let password = generatePassword()
await arg( 
  {
    placeholder: `Generated Password: ${password}`, 
    enter: "Copy",
    shortcuts: [
      {
        name: "Regenerate",
        key: "r",
        onPress: async () => {
          // Generate a new password and update the prompt's placeholder
          password = generatePassword()
          setPlaceholder(`Generated Password: ${password}`)
        }, 
        bar: "right", 
      },
    ], 
    onSubmit: async (input) => { 
      // Copy the password to the clipboard on submit
      await copy(password) 
      // Set the submitted value to false to prevent closing the script 
      return false
    },
  },
  [] // No choices, as we're using a custom input field and shortcuts
)
// Display a notification
await notify("Password copied to clipboard!") 
```

## Find Large Files in a Directory

```typescript
// Name: Find Large Files
// Description: Finds files larger than a specified size in a directory
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user to select a directory
const directoryPath = await path({
  hint: "Select a directory",
  onlyDirs: true,
}) 

// Prompt the user to enter the minimum file size in MB
const minFileSizeMB = parseFloat(await arg("Enter minimum file size (MB):")) 

// Convert the minimum file size to bytes
const minFileSizeBytes = minFileSizeMB * 1024 * 1024

// Read the contents of the selected directory 
const files = await readdir(directoryPath) 

// Find files larger than the specified size 
const largeFiles = (
  await Promise.all(
    files.map(async file => {
      const { size } = await stat(path.join(directoryPath, file))
      // Return the file details if the size is larger than the minimum, otherwise return null
      return size > minFileSizeBytes 
        ? { name: file, size, formattedSize: filesize(size) } 
        : null
    })
  )
).filter(file => file !== null) // Filter out null values

// Display the large files, sorted by size in descending order
if (largeFiles.length > 0) {
  largeFiles.sort((a, b) => b.size - a.size) // Sort by size 
  let largeFilesMd = "" 
  largeFiles.forEach(file => {
    largeFilesMd += `- ${file.name} (${file.formattedSize})\n` 
  })
  await div(md(`## Large Files Found:\n\n${largeFilesMd}`)) 
} else {
  // Display a message if no large files are found
  await div(md(`## No large files found.`))
}
```


## Resize Images in Bulk

// Name: Resize Images in Bulk
// Description: Resize images to a given width, maintaining aspect ratio
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"
import sharp from "sharp"

// Prompt for the desired width
const targetWidth = await arg("Enter target width:")

// Prompt for the folder containing the images
const folderPath = await path({
  startPath: home("Downloads"),
  onlyDirs: true,
})

// Get a list of image file paths in the selected folder
const imageFilePaths = await globby(`${folderPath}/*.{jpg,jpeg,png,gif,webp}`)

// Resize each image
for (const filePath of imageFilePaths) {
  console.log(`Resizing ${filePath}...`)
  await sharp(filePath)
    .resize({ width: parseInt(targetWidth) })
    .toFile(filePath.replace(/(\.\w+)$/, `-resized$1`))
}

console.log("All images resized!")
```

## Google Translate Selected Text

// Name: Google Translate Selected Text
// Description: Translates selected text using Google Translate API
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"
import translate from "@vitalets/google-translate-api"

// Get the selected text
const text = await getSelectedText()

// Prompt for the target language
const targetLanguage = await arg(
  "Enter target language code (e.g., 'es', 'fr', 'de'):",
)

// Translate the text using the Google Translate API
const translation = await translate(text, { to: targetLanguage })

// Replace the selected text with the translated text
await setSelectedText(translation.text)
```

## Generate QR Code from URL

// Name: Generate QR Code from URL
// Description: Generates a QR code image from a given URL
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"
import qrcode from "qrcode"

// Prompt for the URL
const url = await arg("Enter a URL:")

// Generate the QR code image as a data URL
const qrCodeDataUrl = await qrcode.toDataURL(url)

// Display the QR code in a widget
await widget(`<img src="${qrCodeDataUrl}" alt="QR Code" />`)
```

## Check Website Uptime

// Name: Check Website Uptime
// Description: Checks the uptime of a website using the 'is-up' package
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"
import isUp from "is-up"

// Prompt for the website URL
const websiteUrl = await arg("Enter website URL:")

// Check the website's uptime
const isWebsiteUp = await isUp(websiteUrl)

// Display the uptime status
await div(
  md(`## Website Uptime:
  
  ${websiteUrl} is ${
    isWebsiteUp ? "up" : "down"
  }!`
  )
)
```

## Convert Markdown to HTML

// Name: Convert Markdown to HTML
// Description: Converts Markdown text to HTML using the 'marked' package
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"
import { marked } from "marked"

// Prompt for the markdown text
const markdownText = await editor()

// Convert the markdown to HTML
const html = marked.parse(markdownText)

// Display the HTML in a div
await div(html)
```

## Get Weather Information

// Name: Get Weather
// Description: Fetches and displays weather information for a location
// Author: johnlindquist

```typescript
// You can grab your API key from https://openweathermap.org/api

import "@johnlindquist/kit"

// Retrieve OpenWeatherMap API key from the environment
const apiKey = await env("OPENWEATHERMAP_API_KEY")

// Prompt for the location
const location = await arg("Enter city name:")

// Fetch weather data from OpenWeatherMap API
const response = await get(
  `https://api.openweathermap.org/data/2.5/weather?q=${location}&appid=${apiKey}&units=metric`,
)

// Extract relevant weather information
const {
  main: { temp, feels_like, humidity },
  weather: [{ description }],
} = response.data

// Display the weather information in a div
await div(
  md(`## Weather in ${location}:

* Temperature: ${temp}Â°C
* Feels like: ${feels_like}Â°C
* Humidity: ${humidity}%
* Description: ${description}
`
  )
)
```

## Shorten URL with Bitly

// Name: Shorten URL with Bitly
// Description: Shortens a URL using the Bitly API
// Author: johnlindquist

```typescript
// Get a Bitly API key from https://app.bitly.com/settings/api/

import "@johnlindquist/kit"

// Retrieve Bitly API key from the environment
const bitlyAccessToken = await env("BITLY_ACCESS_TOKEN")

// Prompt for the long URL
const longUrl = await arg("Enter long URL:")

// Shorten the URL using the Bitly API
const response = await get(
  `https://api-ssl.bitly.com/v4/shorten`,
  {
    headers: {
      Authorization: `Bearer ${bitlyAccessToken}`,
    },
    params: {
      long_url: longUrl,
    },
  }
)

// Extract the shortened URL
const shortUrl = response.data.link

// Copy the shortened URL to the clipboard
await copy(shortUrl)

// Display the shortened URL
await div(md(`## Shortened URL:\n\n${shortUrl}`))
```

## Generate Random Password

// Name: Generate Random Password
// Description: Generates a strong random password
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"
import generator from "generate-password"

// Prompt for password length
const passwordLength = await arg({
  placeholder: "Enter desired password length:",
  hint: "Default: 12",
})

// Generate the password
const password = generator.generate({
  length: parseInt(passwordLength) || 12, // Default to 12 if no input provided
  numbers: true,
  symbols: true,
  lowercase: true, 
  uppercase: true, 
  excludeSimilarCharacters: true, 
}) 

// Copy the password to the clipboard
await copy(password) 

// Display the generated password (masked for security)
await div(md(`## Generated Password:\n\n${"*".repeat(password.length)} (copied to clipboard)`)) 
```

## Convert Text to Speech

// Name: Text to Speech
// Description: Converts text to speech using the 'say' command
// Author: johnlindquist 

```typescript
import "@johnlindquist/kit"

// Prompt for the text to convert
const text = await arg("Enter text to convert to speech:")

// Convert the text to speech using the 'say' command
await say(text)
```

## Get Current Location

// Name: Get Current Location
// Description: Fetches the user's current location using IP-API
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"

// Fetch location data from IP-API
const response = await get("http://ip-api.com/json/") 

// Extract location information 
const { city, regionName, country, zip } = response.data

// Display the location information in a div
await div(
  md(`## Your Current Location:

* City: ${city}
* Region: ${regionName}
* Country: ${country}
* ZIP Code: ${zip}
`
  )
) 
```

## Send Email with Nodemailer

// Name: Send Email
// Description: Sends an email using Nodemailer
// Author: johnlindquist

```typescript
// Get your Nodemailer configuration from https://nodemailer.com/about/

import "@johnlindquist/kit"
import nodemailer from "nodemailer"

// Retrieve email credentials from the environment
const emailUser = await env("EMAIL_USER")
const emailPassword = await env("EMAIL_PASSWORD") 

// Prompt for recipient email address
const toEmail = await arg("Enter recipient email:") 

// Create a Nodemailer transporter
const transporter = nodemailer.createTransport({
  service: "Gmail",
  auth: {
    user: emailUser,
    pass: emailPassword,
  },
})

// Define email details
const mailOptions = { 
  from: emailUser, 
  to: toEmail, 
  subject: "Test Email from Script Kit",
  text: "Hello from Script Kit!",
}

// Send the email
transporter.sendMail(mailOptions, (error, info) => { 
  if (error) {
    console.error("Error sending email:", error)
  } else {
    console.log("Email sent:", info.response)
  }
}) 
```

## Check Spelling

// Name: Check Spelling
// Description: Checks the spelling of a word using a dictionary API
// Author: johnlindquist

```typescript
// Get a free dictionary API key from https://dictionaryapi.dev/

import "@johnlindquist/kit" 

// Prompt for a word
const word = await arg("Enter a word:")

// Check the spelling using a dictionary API
const response = await get(
  `https://api.dictionaryapi.dev/api/v2/entries/en/${word}`
)

// Display the results
if (response.status === 200) {
  await div(md(`# ${word} is spelled correctly`)) 
} else {
  await div(md(`# ${word} is not found in the dictionary`))
}
```

## Convert Image to Base64

// Name: Image to Base64
// Description: Converts an image to Base64 encoding 
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"

// Prompt the user to select an image
const filePath = await path({
  startPath: home("Downloads"),
}) 

// Read the image file
const imageBuffer = await readFile(filePath)

// Convert the image to Base64 encoding
const base64Image = imageBuffer.toString("base64") 

// Copy the Base64 string to the clipboard 
await copy(base64Image)

// Display the Base64 string in the editor
await editor(base64Image)
```
## Create and Send a Tweet

// Name: Create and Send a Tweet
// Description: Create a tweet using the Twitter API
// Author: johnlindquist

```typescript
// You'll need a developer account and API keys from https://developer.twitter.com/en/portal/dashboard

import "@johnlindquist/kit"
import Twitter from "twitter-api-v2"

// Retrieve API keys from environment variables
const consumerKey = await env("TWITTER_CONSUMER_KEY")
const consumerSecret = await env("TWITTER_CONSUMER_SECRET")
const accessToken = await env("TWITTER_ACCESS_TOKEN")
const accessTokenSecret = await env("TWITTER_ACCESS_TOKEN_SECRET") 

// Authenticate with the Twitter API
const client = new Twitter({
  appKey: consumerKey,
  appSecret: consumerSecret,
  accessToken: accessToken,
  accessSecret: accessTokenSecret, 
})

// Prompt for the tweet text
const tweetText = await arg("What's happening?")

// Send the tweet
await client.v2.tweet(tweetText) 

await div(md(`Tweeted:\n\n${tweetText}`))
```

## Check NPM Package Downloads

// Name: Check NPM Package Downloads
// Description: Checks weekly download count for an npm package
// Author: johnlindquist 

```typescript
import "@johnlindquist/kit" 

// Prompt for the package name
const packageName = await arg("Enter NPM package name:")

// Fetch download count from npm API 
const response = await get(`https://api.npmjs.org/downloads/point/last-week/${packageName}`);

// Display the download count
await div(md(`# Weekly Downloads: ${response.data.downloads}`))
```

## Send a Message to Slack

// Name: Send Slack Message
// Description: Sends a message to a Slack channel
// Author: johnlindquist

```typescript
// Get a Slack API token from https://api.slack.com/

import "@johnlindquist/kit"
import { WebClient } from "@slack/web-api"

// Retrieve Slack API token from the environment
const slackToken = await env("SLACK_API_TOKEN")

// Prompt for the channel name
const channel = await arg("Enter Slack channel:")

// Prompt for the message text
const message = await arg("Enter message to send:") 

// Create a Slack client
const client = new WebClient(slackToken)

// Send the message to the specified channel
await client.chat.postMessage({ channel, text: message })

await div(md(`Sent "${message}" to #${channel}`))
```

## Create a GitHub Repository

// Name: Create GitHub Repo
// Description: Creates a new GitHub repository
// Author: johnlindquist

```typescript
// Requires GITHUB_TOKEN environment variable. You can generate a token at https://github.com/settings/tokens

import "@johnlindquist/kit"
import { Octokit } from "@octokit/rest"

// Retrieve GitHub personal access token from the environment
const githubToken = await env("GITHUB_TOKEN") 

// Initialize Octokit client
const octokit = new Octokit({ auth: githubToken })

// Prompt for the repository name
const repoName = await arg("Enter repository name:") 

// Prompt for a description (optional)
const description = await arg({
  placeholder: "Enter a description (optional):", 
  hint: "Hit enter to skip", 
})

// Create the repository
await octokit.repos.createForAuthenticatedUser({ 
  name: repoName,
  description: description || "", 
  private: false,
}) 

await div(md(`Created GitHub repository: ${repoName}`)) 
```

## Generate TypeScript Types from JSON

// Name: Generate TypeScript Types from JSON 
// Description: Converts JSON data to TypeScript types
// Author: johnlindquist

```typescript 
import "@johnlindquist/kit"
import { quicktype, InputData, JSONSchemaInput, FetchingJSONSchemaStore } from "quicktype-core"

// Prompt the user for JSON data 
const jsonData = await arg("Paste JSON data:")

// Convert JSON data to TypeScript types using quicktype 
async function generateTypes() {
  const schemaInput = new JSONSchemaInput(new FetchingJSONSchemaStore()) 

  // Name the top-level type "MyType"
  await schemaInput.addSource({ name: "MyType", schema: jsonData })

  const inputData = new InputData() 
  inputData.addInput(schemaInput) 

  const { lines } = await quicktype({
    inputData, 
    lang: "typescript",
  })

  return lines.join("\n")
}

// Display the generated types in the editor
await editor(await generateTypes())
```

## Download and Extract Archive

// Name: Download and Extract Archive 
// Description: Downloads and extracts an archive file
// Author: johnlindquist 

```typescript 
import "@johnlindquist/kit" 
import download from "download"
import { extract } from "tar"

// Prompt for the archive URL
const archiveUrl = await arg("Enter archive URL:")

// Prompt for the extraction directory 
const extractionPath = await path({ 
  startPath: home("Downloads"),
  onlyDirs: true
}) 

// Download and extract the archive 
await download(archiveUrl, extractionPath, { extract: true }) 

await div(md(`# Extracted ${archiveUrl} to ${extractionPath}`)) 
```

## Resize Image with Preview

// Name: Resize Image with Preview
// Description: Resizes an image with a live preview in the prompt
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"
import sharp from "sharp"

// Prompt for image selection
const imagePath = await path({
  startPath: home("Downloads"),
})

// Function to generate preview
const generatePreview = async (width: number) => {
  const resizedImageBuffer = await sharp(imagePath)
    .resize({ width }) 
    .toBuffer()

  const base64Image = resizedImageBuffer.toString("base64")
  return `<img src="data:image/png;base64,${base64Image}" alt="Preview" />` 
}

// Prompt for target width with a live preview
const targetWidth = await arg(
  {
    placeholder: "Enter target width (in pixels):",
    preview: async (input) => await generatePreview(parseInt(input) || 100), // Display preview with default width 
  },
)

// Resize the image
const outputPath = imagePath.replace(/(\.\w+)$/, `-resized$1`)
await sharp(imagePath)
  .resize({ width: parseInt(targetWidth) }) 
  .toFile(outputPath)

await div(md(`Resized image saved to ${outputPath}`))
```
## Get System Uptime

// Name: Get System Uptime
// Description: Displays the system uptime using the 'os' module
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"
import os from "os"

// Get the system uptime in seconds
const uptimeInSeconds = os.uptime()

// Format the uptime into days, hours, minutes, and seconds
const uptime = new Date(uptimeInSeconds * 1000)
  .toISOString()
  .substr(11, 8)

// Display the uptime
await div(md(`## System Uptime:\n\n${uptime}`))
```

## Create ZIP Archive

// Name: Create ZIP Archive
// Description: Creates a ZIP archive of a selected folder
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"
import archiver from "archiver"

// Prompt for the folder to archive
const folderPath = await path({
  startPath: home("Downloads"),
  onlyDirs: true,
})

// Prompt for the output file name
const outputFileName = await arg("Enter output file name:")

// Create a write stream for the output ZIP file
const output = createWriteStream(path.join(folderPath, `${outputFileName}.zip`)) 

// Initialize the archiver
const archive = archiver("zip", { zlib: { level: 9 } })

// Pipe the archive data to the output stream
archive.pipe(output) 

// Add the selected folder to the archive
archive.directory(folderPath, false) 

// Finalize the archive
await archive.finalize()

await div(md(`Created archive: ${outputFileName}.zip`))
```

## Convert CSV to JSON

// Name: Convert CSV to JSON
// Description: Converts a CSV file to JSON format
// Author: johnlindquist 

```typescript
import "@johnlindquist/kit"
import { parse } from "csv-parse"

// Prompt for CSV file selection
const filePath = await path({
  startPath: home("Downloads"),
})

// Read the CSV file
const csvData = await readFile(filePath, "utf-8")

// Parse the CSV data and convert it to JSON
const json = await new Promise((resolve, reject) => { 
  parse(csvData, {
    columns: true, 
    skip_empty_lines: true,
  }, (err, records) => {
    if (err) {
      reject(err)
    } else {
      resolve(records)
    }
  })
})

// Display the JSON data in the editor
await editor(JSON.stringify(json, null, 2))
```

## Get Public IP Address

// Name: Get Public IP
// Description: Fetches and displays the user's public IP address
// Author: johnlindquist

```typescript 
import "@johnlindquist/kit"
import publicIp from "public-ip"

// Fetch the user's public IP address
const ipAddress = await publicIp.v4() 

// Display the IP address in a div
await div(md(`## Your Public IP Address:\n\n${ipAddress}`))
```

## Check GitHub Profile Views

// Name: Check GitHub Profile Views
// Description: Checks the number of views on the user's GitHub profile
// Author: johnlindquist
```typescript
// Requires GITHUB_TOKEN environment variable. You can generate a token at https://github.com/settings/tokens

import "@johnlindquist/kit"
import { Octokit } from "@octokit/rest" 

// Retrieve GitHub personal access token from the environment
const githubToken = await env("GITHUB_TOKEN") 

// Initialize Octokit client 
const octokit = new Octokit({ auth: githubToken })

// Get the authenticated user's profile views
const { data: views } = await octokit.rest.users.getViewsForAuthenticatedUser()

// Display the total count of views 
await div(md(`# Profile Views:\n\n${views.count}`))
```

## Send Desktop Notification on File Download Completion

// Name: Download Completion Notification
// Description: Sends a desktop notification when a download completes
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"

// Prompt for the file to download
const downloadUrl = await arg({
  placeholder: "Enter a file URL to download:", 
})

// Set the download path
const downloadPath = tmpDownloadsDir(path.basename(downloadUrl))

// Create a write stream for the downloaded file
const fileStream = createWriteStream(downloadPath)

// Start the download and pipe it to the file stream
const response = await get(downloadUrl, { responseType: "stream" })
response.data.pipe(fileStream)

// Send a notification when the download finishes
fileStream.on("finish", async () => { 
  await notify({
    title: "Download Complete",
    message: `Downloaded ${path.basename(downloadUrl)}`,
  }) 
  await revealFile(downloadPath)
})
```

## Convert Text to Handwriting

// Name: Text to Handwriting 
// Description: Converts text to a handwritten image using the 'handwrite' package
// Author: johnlindquist

```typescript
// Requires an API key from https://www.handwrite.io/

import "@johnlindquist/kit"
import handwrite from "handwrite" 

// Prompt for the text to convert
const text = await arg("Enter text:")

// Prompt for the handwriting style 
const handwritingStyle = await arg("Enter handwriting style (e.g., 'cursive', 'print'):", ["cursive", "print"])

// Retrieve Handwrite.io API key from the environment
const handwriteApiKey = await env("HANDWRITE_API_KEY") 

// Convert the text to handwriting using the API
const handwritingImageUrl = await handwrite(text, {
  styles: handwritingStyle === "cursive" ? 2 : 1, // style 1 is print, style 2 is cursive
  handwriting_id: handwriteApiKey, // your Handwrite.io API key
})

// Display the handwritten image in a div 
await div(`<img src="${handwritingImageUrl}" alt="Handwritten Text" class="w-full" />`)
```


## Get File Hash

// Name: Get File Hash
// Description: Calculates the SHA256 hash of a selected file
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"
import { createHash } from "crypto"
import { createReadStream } from "fs"

// Prompt for file selection
const filePath = await path({
  startPath: home("Downloads"),
})

// Create a SHA256 hash object
const hash = createHash("sha256")

// Create a read stream for the selected file
const stream = createReadStream(filePath) 

// Update the hash with file data as it's read
stream.on("data", (data) => hash.update(data)) 

// Calculate and display the hash when the stream ends
stream.on("end", async () => { 
  const fileHash = hash.digest("hex")
  await div(md(`## SHA256 Hash:\n\n${fileHash}`))
})
```

## Create and Share a Shortened URL

// Name: Shorten and Share URL 
// Description: Creates a shortened Bitly URL and copies it to the clipboard
// Author: johnlindquist

```typescript
// Get a Bitly API key from https://app.bitly.com/settings/api/

import "@johnlindquist/kit"

// Retrieve Bitly API key from the environment
const bitlyAccessToken = await env("BITLY_ACCESS_TOKEN")

// Prompt for the long URL
const longUrl = await arg("Enter URL to shorten:")

// Function to shorten the URL using the Bitly API
const shortenUrl = async (url: string) => { 
  const response = await get( 
    "https://api-ssl.bitly.com/v4/shorten", 
    {
      headers: {
        Authorization: `Bearer ${bitlyAccessToken}`,
      }, 
      params: {
        long_url: url, 
      },
    } 
  ) 
  return response.data.link
}

// Shorten the URL
const shortUrl = await shortenUrl(longUrl)

// Copy the shortened URL to the clipboard
await copy(shortUrl) 

// Display the shortened URL in a div 
await div(md(`# Shortened URL:\n\n${shortUrl} (copied to clipboard)`))
```

## Convert Timestamp to Date

// Name: Timestamp to Date 
// Description: Converts a timestamp to a human-readable date
// Author: johnlindquist 

```typescript
import "@johnlindquist/kit" 

// Prompt for the timestamp
const timestamp = await arg("Enter a timestamp (in seconds):")

// Convert the timestamp to a Date object 
const date = new Date(parseInt(timestamp) * 1000)

// Display the formatted date
await div(md(`# ${date.toLocaleString()}`))
```

## Create and Upload a Gist

// Name: Create and Upload Gist
// Description: Creates a gist from editor content and opens it in the browser
// Author: johnlindquist

```typescript
// Requires GITHUB_TOKEN environment variable. You can generate a token at https://github.com/settings/tokens

import "@johnlindquist/kit"
import { Octokit } from "@octokit/rest"

// Retrieve GitHub personal access token from the environment
const githubToken = await env("GITHUB_TOKEN")

// Initialize Octokit client
const octokit = new Octokit({ auth: githubToken }) 

// Prompt for gist description 
const description = await arg("Enter gist description:") 

// Open the editor for content input 
const content = await editor({ language: "javascript" })

// Create the gist
const { data: gist } = await octokit.rest.gists.create({
  description,
  public: true,
  files: { 
    "script.js": {
      content,
    },
  },
})

// Open the created gist in the browser
await open(gist.html_url) 
```

## Download a YouTube Video

// Name: Download YouTube Video
// Description: Downloads a YouTube video using the 'ytdl-core' package 
// Author: johnlindquist

```typescript
import "@johnlindquist/kit" 
import ytdl from "ytdl-core"

// Prompt for the YouTube video URL 
const videoUrl = await arg({
  placeholder: "Enter YouTube video URL:",
}) 

// Get video information 
const videoInfo = await ytdl.getInfo(videoUrl)

// Extract the video title
const videoTitle = videoInfo.videoDetails.title

// Prompt for the desired video quality
const quality = await arg(
  "Select video quality:", 
  videoInfo.formats
    .filter(f => f.hasVideo && f.hasAudio)
    .map(f => ({
      name: `${f.qualityLabel} (${f.container})`, 
      value: f.itag,
    })) 
)

// Download the video
ytdl(videoUrl, { quality: quality.toString() })
  .pipe(createWriteStream(path.join(home("Downloads"), `${videoTitle}.mp4`)))
  .on("finish", () => {
    // Notify the user when the download is complete
    notify({
      title: "Download Complete", 
      message: `${videoTitle}.mp4`, 
    }) 
  })
```

## Compress PDF File

// Name: Compress PDF
// Description: Compresses a PDF file using the 'compress-pdf-document' package 
// Author: johnlindquist 

```typescript 
import "@johnlindquist/kit" 
import { compressPdf } from "compress-pdf-document" 

// Prompt for PDF file selection 
const filePath = await path({
  startPath: home("Downloads"), 
}) 

// Define compression options
const options = {
  // Compression level (0-100) 
  quality: 50,
}

// Compress the PDF file
const compressedData = await compressPdf(filePath, options)

// Save the compressed PDF 
const outputPath = filePath.replace(/\.pdf$/, "-compressed.pdf")
await writeFile(outputPath, compressedData)

await div(md(`Compressed PDF saved to ${outputPath}`)) 
```

## Create New Project from Template

// Name: Create Project From Template
// Description: Creates a new project from a GitHub template repository
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"

// Prompt for the template repository URL
const templateRepo = await arg(
  { placeholder: "Enter template repository URL (e.g., 'user/repo'):" },
)

// Prompt for the project name 
const projectName = await arg("Enter project name:") 

// Create the project directory 
const projectPath = path.join(home("dev"), projectName) 
await ensureDir(projectPath) 

// Clone the template repository into the project directory
await git.clone(`https://github.com/${templateRepo}.git`, projectPath) 

// Open the project directory in VS Code
await exec(`code ${projectPath}`)
``` 

## Get System Information

// Name: Get System Info
// Description: Displays system information using the 'si' package 
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"
import si from "systeminformation"

// Fetch system information 
const systemInfo = await si.system()
const osInfo = await si.osInfo()
const cpuInfo = await si.cpu()
const memoryInfo = await si.mem()

// Display the system information in a div
await div(
  md(`## System Information:

* **Model:** ${systemInfo.model} 
* **Manufacturer:** ${systemInfo.manufacturer} 
* **Operating System:** ${osInfo.distro} ${osInfo.release}
* **CPU:** ${cpuInfo.manufacturer} ${cpuInfo.brand}
* **Memory:** ${memoryInfo.total} bytes
`
  )
)
```

## Create a New Note in Bear

// Name: New Bear Note
// Description: Creates a new note in Bear app 
// Author: johnlindquist

```typescript 
import "@johnlindquist/kit" 

// Prompt for the note title 
const title = await arg("Enter note title:")

// Prompt for the note content
const content = await editor({
  placeholder: "Enter note content:",
  language: "markdown"
})

// Create the note in Bear using x-callback-url
await exec(`open "bear://x-callback-url/create?title=${encodeURIComponent(title)}&text=${encodeURIComponent(content)}"`)
```

## Check Website Status Code

// Name: Check Website Status
// Description: Checks the HTTP status code of a website
// Author: johnlindquist 

```typescript
import "@johnlindquist/kit"

// Prompt for the website URL 
const url = await arg("Enter website URL:") 

try {
  // Make a HEAD request to get the status code without downloading the entire page 
  const response = await get(url, { method: "HEAD" })

  // Display the status code
  await div(md(`# Status Code: ${response.status}`))
} catch (error) {
  // Handle any errors that may occur during the request
  await div(md(`# Error: ${error.message}`))
} 
```

## Get Random Advice

// Name: Get Advice
// Description: Fetches and displays a piece of random advice
// Author: johnlindquist 

```typescript
import "@johnlindquist/kit"

// Fetch advice from the Advice Slip API
const response = await get("https://api.adviceslip.com/advice")

// Extract the advice 
const advice = response.data.slip.advice 

// Display the advice in a div
await div(md(`# Advice:\n\n${advice}`)) 
```

## Create a New Notion Page

// Name: Create Notion Page
// Description: Creates a new Notion page in a selected database
// Author: johnlindquist

```typescript
// Get a Notion API key from https://www.notion.so/my-integrations
// See https://developers.notion.com/docs/getting-started

import "@johnlindquist/kit"
import { Client } from "@notionhq/client" 

// Retrieve Notion API key from environment variables
const notionToken = await env("NOTION_API_TOKEN") 

// Initialize Notion client
const notion = new Client({ auth: notionToken }) 

// Prompt for the database ID 
const databaseId = await env("NOTION_DATABASE_ID", {
  hint: "Enter your Notion Database ID",
})

// Prompt for the page title 
const title = await arg("Enter page title:")

// Create the new page
await notion.pages.create({
  parent: {
    database_id: databaseId, 
  },
  properties: { 
    title: {
      title: [ 
        {
          text: {
            content: title,
          },
        }, 
      ],
    }, 
  },
})

await div(md(`Created new Notion page: ${title}`))
```

## Convert Image to ASCII Art

// Name: Image to ASCII
// Description: Converts an image to ASCII art using the 'image-to-ascii' package
// Author: johnlindquist

```typescript
import "@johnlindquist/kit" 
import { imageToAscii } from "image-to-ascii"

// Prompt for image selection
const imagePath = await path({
  startPath: home("Downloads"),
}) 

// Convert the image to ASCII art
imageToAscii(imagePath, {
  // Adjust these options to customize the output
  // width: 80, // Set the width of the ASCII art
  // colored: false // Use colors in the ASCII art
}, (err, converted) => {
  if (err) {
    console.error("Error converting image:", err) 
  } else {
    console.log(converted)
  }
})
```

## Get Current Bitcoin Price

// Name: Get Bitcoin Price
// Description: Fetches and displays the current Bitcoin price using the 'coingecko-api' package
// Author: johnlindquist 

```typescript
import "@johnlindquist/kit"
import CoinGecko from "coingecko-api"

// Initialize CoinGecko API client
const CoinGeckoClient = new CoinGecko()

// Fetch Bitcoin price data
const { data } = await CoinGeckoClient.simple.price({
  ids: ["bitcoin"], 
  vs_currencies: ["usd"],
})

// Extract the Bitcoin price in USD
const bitcoinPrice = data.bitcoin.usd

// Display the Bitcoin price
await div(md(`## Current Bitcoin Price: $${bitcoinPrice}`))
```

## Generate Color Palette from Image

// Name: Generate Color Palette
// Description: Creates a color palette from a selected image using the 'node-vibrant' package
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"
import Vibrant from "node-vibrant"

// Prompt for image selection
const imagePath = await path({
  startPath: home("Downloads"),
})

// Generate the color palette
const palette = await Vibrant.from(imagePath).getPalette() 

// Display the palette colors in a div
const swatches = Object.entries(palette)
  .map(
    ([name, swatch]) => `
    <div class="w-24 h-12" style="background-color: ${swatch?.hex};"></div>
    `
  )
  .join("")

await div(
  `<div class="flex flex-row gap-2 p-4">${swatches}</div>`
) 
```

## Get Stock Price 

// Name: Get Stock Price
// Description: Retrieves and displays the current price of a stock symbol
// Author: johnlindquist

```typescript
// Get a free API key from https://www.alphavantage.co/support/#api-key 

import "@johnlindquist/kit"

// Retrieve Alpha Vantage API key from the environment
const apiKey = await env("ALPHA_VANTAGE_API_KEY")

// Prompt for the stock symbol
const symbol = await arg("Enter stock symbol:")

// Fetch stock data from Alpha Vantage API
const response = await get(
  `https://www.alphavantage.co/query?function=GLOBAL_QUOTE&symbol=${symbol}&apikey=${apiKey}`,
)

// Extract the stock price
const price = response?.data["Global Quote"]["05. price"] 

// Display the stock price
if (price) { 
  await div(md(`## Current price of ${symbol}: $${price}`))
} else {
  await div(md(`# Could not find price for ${symbol}`))
}
```

## Create a New Trello Card

// Name: Create Trello Card
// Description: Creates a new card on a Trello board
// Author: johnlindquist

```typescript
// Get a Trello API key and token from https://trello.com/app-key

import "@johnlindquist/kit"

// Retrieve Trello API key and token from the environment
const trelloKey = await env("TRELLO_API_KEY") 
const trelloToken = await env("TRELLO_TOKEN")

// Prompt for the board ID
const boardId = await env("TRELLO_BOARD_ID", {
  hint: "Enter your Trello Board ID", 
}) 

// Prompt for the list ID 
const listId = await env("TRELLO_LIST_ID", {
  hint: "Enter your Trello List ID", 
}) 

// Prompt for the card name
const cardName = await arg("Enter card name:")

// Create the Trello card using the API 
await get(
  `https://api.trello.com/1/cards`,
  {
    params: {
      key: trelloKey,
      token: trelloToken, 
      idList: listId,
      name: cardName,
    },
  }
)

await div(md(`Created Trello card: ${cardName}`)) 
```

## Get Random Quote

// Name: Random Quote
// Description: Fetches and displays a random quote
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"

// Fetch a random quote from the Quotable API
const response = await get("https://api.quotable.io/random")

// Extract quote content and author
const { content, author } = response.data

// Display the quote
await div(md(`# "${content}"\n\nâ€” ${author}`))
```

## Check for Available System Updates

// Name: Check for Updates
// Description: Checks for and displays available system updates (macOS only) 
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"

// Check for software updates using the 'softwareupdate' command (macOS only) 
const { stdout } = await exec("softwareupdate --list")

// Parse the output and extract the list of available updates 
const updates = stdout
  .split("\n")
  .filter(line => line.includes("*")) // Filter lines that indicate available updates 
  .map(line => line.trim().replace("* ", "")) // Remove leading asterisk and whitespace

// Display the updates
if (updates.length > 0) { 
  await div(md(`# Available Updates:\n\n${updates.join("\n")}`))
} else { 
  await div(md(`# No system updates available.`))
}
```

## Compress Image

// Name: Compress Image 
// Description: Compresses a selected image using the 'sharp' package
// Author: johnlindquist

```typescript 
import "@johnlindquist/kit" 
import sharp from "sharp" 

// Prompt for image selection 
const imagePath = await path({
  startPath: home("Downloads")
}) 

// Prompt for the desired compression quality
const quality = await arg(
  {
    placeholder: "Enter desired quality (0-100):",
    hint: "Default: 80", 
  },
) 

// Compress the image using sharp
await sharp(imagePath) 
  .jpeg({ quality: parseInt(quality) || 80 }) // Default to 80 if no quality provided
  .toFile(imagePath.replace(/(\.\w+)$/, `-compressed$1`))

await div(md(`Image compressed successfully!`))
```

## Get Lyrics for a Song

// Name: Get Lyrics
// Description: Fetches and displays lyrics for a song using the 'lyrics-finder' package 
// Author: johnlindquist 

```typescript
import "@johnlindquist/kit"
import { lyricsFinder } from "lyrics-finder"

// Prompt for the song title
const songTitle = await arg("Enter song title:")

// Prompt for the artist name (optional)
const artist = await arg({
  placeholder: "Enter artist name (optional):", 
  hint: "Hit enter to skip",
}) 

try {
  // Search for lyrics using the lyrics-finder package 
  const lyrics = await lyricsFinder(songTitle, artist || undefined) 

  // Display the lyrics in the editor
  await editor(lyrics) 
} catch (error) { 
  // Handle errors if lyrics are not found
  await div(md(`# Lyrics not found for ${songTitle} by ${artist || "Unknown"}`)) 
}
```
## Get Dominant Color from Image

// Name: Get Dominant Color
// Description: Extracts the dominant color from an image using 'color-thief-node'
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"
import { getColorFromURL } from "color-thief-node"

// Prompt for image URL
const imageUrl = await arg("Enter image URL:")

// Get dominant color from the image URL
const dominantColor = await getColorFromURL(imageUrl)

// Convert the dominant color (RGB array) to a hex string
const hexColor = `#${dominantColor.map(c => c.toString(16).padStart(2, "0")).join("")}` 

// Display the dominant color in a styled div
await div({
  html: `<div class="h-48 w-full" style="background-color: ${hexColor};"></div>`,
  // Add padding and center the text
  className: "p-4 flex items-center justify-center",
}) 
```

## Resize Image and Upload to Cloudinary

// Name: Resize and Upload Image
// Description: Resizes an image and uploads it to Cloudinary
// Author: johnlindquist

```typescript
// Get Cloudinary credentials from https://cloudinary.com/console/

import "@johnlindquist/kit"
import { v2 as cloudinary } from "cloudinary"
import sharp from "sharp"

// Retrieve Cloudinary credentials from environment variables
const cloudName = await env("CLOUDINARY_CLOUD_NAME")
const apiKey = await env("CLOUDINARY_API_KEY")
const apiSecret = await env("CLOUDINARY_API_SECRET") 

// Configure Cloudinary
cloudinary.config({
  cloud_name: cloudName, 
  api_key: apiKey,
  api_secret: apiSecret,
})

// Prompt for image selection
const imagePath = await path({
  startPath: home("Downloads"), 
})

// Prompt for the target width 
const targetWidth = await arg("Enter target width:")

// Resize the image using sharp 
const resizedImageBuffer = await sharp(imagePath)
  .resize({ width: parseInt(targetWidth) })
  .toBuffer() 

// Upload the resized image to Cloudinary
const uploadResult = await cloudinary.uploader.upload(resizedImageBuffer, {
  // Set the folder in Cloudinary where the image will be uploaded
  folder: "resized_images",
})

// Copy the image URL to the clipboard
await copy(uploadResult.secure_url)

// Display the uploaded image URL
await div(md(`## Uploaded Image URL:

[${uploadResult.secure_url}](${uploadResult.secure_url}) (copied to clipboard)`))
```

## Create a New GitHub Issue

// Name: Create GitHub Issue
// Description: Creates a new issue on a GitHub repository 
// Author: johnlindquist

```typescript
// Requires GITHUB_TOKEN environment variable. You can generate a token at https://github.com/settings/tokens

import "@johnlindquist/kit"
import { Octokit } from "@octokit/rest"

// Retrieve GitHub personal access token from the environment
const githubToken = await env("GITHUB_TOKEN") 

// Initialize Octokit client
const octokit = new Octokit({ auth: githubToken }) 

// Prompt for the repository in the format "owner/repo" 
const repo = await arg({
  placeholder: "Enter repository (e.g., 'johnlindquist/kit'):", 
})

// Split the input into owner and repo name
const [owner, repoName] = repo.split("/")

// Prompt for the issue title 
const title = await arg("Enter issue title:") 

// Prompt for the issue body (optional)
const body = await editor({
  placeholder: "Enter issue body (optional):", 
  hint: "Hit cmd+s to submit",
}) 

// Create the issue
await octokit.rest.issues.create({ 
  owner,
  repo: repoName, 
  title,
  body,
})

await div(md(`Created issue: ${title} on ${repo}`)) 
```

## Send Email with Gmail API

// Name: Send Email with Gmail API 
// Description: Sends an email using the Gmail API
// Author: johnlindquist

```typescript
// Requires a Google Cloud Platform project with the Gmail API enabled
// See the Gmail API documentation for setup instructions: https://developers.google.com/gmail/api/quickstart/nodejs

import "@johnlindquist/kit"
import { google } from "googleapis" 

// Retrieve Gmail API credentials from environment variables 
const clientID = await env("GMAIL_CLIENT_ID")
const clientSecret = await env("GMAIL_CLIENT_SECRET")
const refreshToken = await env("GMAIL_REFRESH_TOKEN")
// Authorize with the Gmail API 
const oAuth2Client = new google.auth.OAuth2(clientID, clientSecret) 
oAuth2Client.setCredentials({ refresh_token: refreshToken }) 
const gmail = google.gmail({ version: "v1", auth: oAuth2Client }) 

// Prompt for recipient email address
const to = await arg("Enter recipient email:")

// Prompt for email subject
const subject = await arg("Enter email subject:")

// Prompt for email body 
const body = await editor({
  placeholder: "Enter email body:",
  language: "text", 
})

// Encode the email content as base64
const encodedMessage = Buffer.from(`
Content-Type:  text/plain; charset="UTF-8"
MIME-Version: 1.0
To: ${to} 
Subject: ${subject} 

${body}`.trim()).toString("base64").replace(/\+/g, '-').replace(/\//g, '_')

// Send the email
await gmail.users.messages.send({ 
  userId: "me",
  requestBody: {
    raw: encodedMessage, 
  },
})

await div(md(`Email sent to ${to}`))
```

## Check if Process is Running

// Name: Check Process
// Description: Checks if a process is running by its name
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"

// Prompt for the process name
const processName = await arg("Enter process name:") 

// Check if the process is running using the `pgrep` command 
const { stdout } = await exec(`pgrep ${processName}`)

// Display the result 
if (stdout) { 
  await div(md(`# Process "${processName}" is running`))
} else { 
  await div(md(`# Process "${processName}" is not running`))
}
```

## Play Audio from YouTube Video

// Name: Play YouTube Audio
// Description: Plays audio from a YouTube video using 'ytdl-core'
// Author: johnlindquist 

```typescript
import "@johnlindquist/kit"
import ytdl from "ytdl-core"

// Prompt for the YouTube video URL
const videoUrl = await arg({
  placeholder: "Enter YouTube video URL:",
})

// Create an audio stream from the YouTube video
const audioStream = ytdl(videoUrl, { filter: "audioonly" }) 

// Play the audio stream
await playAudioFile(audioStream)

// Display a message indicating the audio is playing 
await div(md(`# Playing audio from:\n\n${videoUrl}`))
```

## Create a New Google Calendar Event

// Name: Create Calendar Event
// Description: Creates a new event on Google Calendar using the Google Calendar API 
// Author: johnlindquist

```typescript
// Requires GOOGLE_CALENDAR_API_KEY and GOOGLE_CALENDAR_CLIENT_ID to be set in .env
// Follow the instructions at https://developers.google.com/calendar/api/quickstart/nodejs to create these

import "@johnlindquist/kit" 
import { google } from "googleapis" 

// Retrieve API key and client ID from environment variables 
const apiKey = await env("GOOGLE_CALENDAR_API_KEY") 
const clientId = await env("GOOGLE_CALENDAR_CLIENT_ID") 

// Initialize Google Calendar API client
const calendar = google.calendar({
  version: "v3",
  auth: apiKey,
})

// Prompt for event summary 
const summary = await arg("Enter event summary:")

// Prompt for event start time
const startDateTime = await arg({ 
  placeholder: "Enter event start time (YYYY-MM-DD HH:MM):", 
  // Validate the input to ensure it's in the correct format
  validate: (input) => /^\d{4}-\d{2}-\d{2}\s\d{2}:\d{2}$/.test(input),
}) 

// Prompt for event end time 
const endDateTime = await arg({
  placeholder: "Enter event end time (YYYY-MM-DD HH:MM):",
  // Validate the input to ensure it's in the correct format 
  validate: (input) => /^\d{4}-\d{2}-\d{2}\s\d{2}:\d{2}$/.test(input),
})

// Create the event
await calendar.events.insert({
  calendarId: "primary", 
  requestBody: {
    summary, 
    start: {
      dateTime: startDateTime, 
    },
    end: { 
      dateTime: endDateTime, 
    },
  }, 
}) 

await div(md(`# Event created: ${summary}`))
```


## Send SMS Message with Twilio

// Name: Send SMS Message
// Description: Sends an SMS message using the Twilio API
// Author: johnlindquist

```typescript
// Get a Twilio API key and token from https://www.twilio.com/console

import "@johnlindquist/kit"
import twilio from "twilio"

// Retrieve Twilio credentials from environment variables 
const accountSid = await env("TWILIO_ACCOUNT_SID")
const authToken = await env("TWILIO_AUTH_TOKEN")
const twilioPhoneNumber = await env("TWILIO_PHONE_NUMBER")

// Initialize Twilio client 
const client = twilio(accountSid, authToken)

// Prompt for the recipient's phone number
const toPhoneNumber = await arg("Enter phone number:") 

// Prompt for the message body
const message = await arg("Enter message:") 

// Send the SMS message 
await client.messages.create({
  body: message, 
  from: twilioPhoneNumber,
  to: toPhoneNumber,
}) 

await div(md(`SMS message sent to ${toPhoneNumber}`))
```

## Convert Text to QR Code and Save

// Name: Text to QR Code
// Description: Creates a QR code image from text and saves it to a file
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"
import qrcode from "qrcode"

// Prompt for text input
const text = await arg("Enter text for QR code:") 

// Prompt for output file path
const filePath = await path({
  startPath: home("Downloads"),
})

// Generate the QR code and save it to a file 
await qrcode.toFile(filePath, text, {
  // Customize QR code options:
  // color: {
  //   dark: '#00F',  // Blue modules
  //   light: '#0000' // Transparent background
  // },
  // width: 400, // Set QR code width in pixels
  // type: 'png', // Specify image format 
})

await div(md(`QR code saved to ${filePath}`))
```

## Get Website Favicon

// Name: Get Website Favicon
// Description: Downloads the favicon of a website
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"
import favicons from "favicons"

// Prompt for website URL
const websiteUrl = await arg("Enter website URL:") 

// Fetch favicon using the 'favicons' package
const response = await favicons(websiteUrl) 

// Extract the favicon URL 
const faviconUrl = response.images[0].url 

// Download and save the favicon
const faviconData = await download(faviconUrl)
const faviconPath = path.join(
  home("Downloads"),
  `${new URL(websiteUrl).hostname}.ico`,
)

await writeFile(faviconPath, faviconData)

await div(md(`Favicon downloaded to: ${faviconPath}`))
```

## Resize and Compress Images in Bulk

// Name: Bulk Resize and Compress
// Description: Resize and compress images in a folder
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"
import sharp from "sharp"

// Prompt for the target width 
const targetWidth = await arg("Enter target width:")

// Prompt for compression quality 
const quality = await arg({
  placeholder: "Enter compression quality (0-100):",
  hint: "Default: 80", 
}) 

// Prompt for the folder containing images 
const folderPath = await path({
  startPath: home("Downloads"),
  onlyDirs: true,
})

// Get all image file paths in the selected folder
const imageFilePaths = await globby(`${folderPath}/*.{jpg,jpeg,png,gif,webp}`)

// Resize and compress each image
for (const filePath of imageFilePaths) {
  console.log(`Processing ${filePath}...`)
  await sharp(filePath)
    .resize({ width: parseInt(targetWidth) })
    .jpeg({ quality: parseInt(quality) || 80 }) // Default quality to 80 if not provided
    .toFile(filePath.replace(/(\.\w+)$/, `-resized-compressed$1`))
}

await div(md(`Images resized and compressed!`)) 
```

## Generate PDF from HTML

// Name: Generate PDF from HTML
// Description: Converts HTML content to a PDF document using the 'html-pdf' package 
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"
import pdf from "html-pdf"

// Prompt for HTML content
const html = await editor({ language: "html" })

// Prompt for output PDF file path
const outputPath = await path({
  startPath: home("Downloads"),
})

// Convert the HTML to PDF using the 'html-pdf' package
pdf.create(html).toFile(outputPath, (err, res) => {
  if (err) {
    console.error("Error creating PDF:", err)
  } else {
    console.log("PDF created successfully:", res.filename) 
  } 
})
```

## Check for Broken Links

// Name: Check Broken Links
// Description: Scans a website for broken links using the 'broken-link-checker' package
// Author: johnlindquist 

```typescript 
import "@johnlindquist/kit"
import { SiteChecker } from "broken-link-checker"

// Prompt for the website URL
const websiteUrl = await arg("Enter website URL:")

// Create an array to store broken links
const brokenLinks: any[] = []

// Create a site checker instance 
const siteChecker = new SiteChecker(
  { 
    excludeExternalLinks: true, // Only check internal links
  }, 
  {
    // Callback for handling broken links 
    broken: (result) => {
      brokenLinks.push(result)
    },
    // Callback for handling completed checks
    end: () => { 
      // Display the broken links in the editor
      if (brokenLinks.length > 0) {
        editor(JSON.stringify(brokenLinks, null, 2)) 
      } else {
        div(md(`# No broken links found on ${websiteUrl}`))
      }
    },
  }
)

// Start the link check 
siteChecker.enqueue(websiteUrl) 
```

## Get Random Joke

// Name: Random Joke
// Description: Fetches and displays a random joke from the JokeAPI 
// Author: johnlindquist 

```typescript
import "@johnlindquist/kit"

// Fetch a random joke from JokeAPI
const response = await get("https://v2.jokeapi.dev/joke/Any")

// Extract joke setup and delivery (if applicable) 
let joke = "";
if (response.data.type === "single") {
  joke = response.data.joke
} else if (response.data.type === "twopart") {
  joke = `${response.data.setup}\n\n${response.data.delivery}` 
} 

// Display the joke in a div 
await div(md(`# ${joke}`))
```
## Generate Password and Save to 1Password

// Name: Generate and Save Password
// Description: Generates a password and saves it to 1Password
// Author: johnlindquist

```typescript
// You can find 1Password CLI documentation at https://developer.1password.com/docs/cli

import "@johnlindquist/kit"
import generator from "generate-password"

// Prompt for the website or service
const website = await arg("Enter website or service:") 

// Prompt for the username
const username = await arg("Enter username:")

// Generate a random password
const password = generator.generate({
  length: 24, 
  numbers: true,
  symbols: true,
  lowercase: true,
  uppercase: true, 
  excludeSimilarCharacters: true, 
})

// Save the password to 1Password using the CLI
await exec(`op item create login --title "${website}" --username "${username}" --password "${password}"`) 

// Display success message
await div(md(`# Password for ${website} saved to 1Password`))
```

## Search Spotify

// Name: Search Spotify 
// Description: Search for tracks on Spotify using their API 
// Author: johnlindquist 

```typescript
// Get a Spotify API Client ID and Secret from https://developer.spotify.com/dashboard/applications 

import "@johnlindquist/kit" 
import Spotify from "spotify-web-api-node"

// Retrieve Spotify credentials from environment variables
const clientId = await env("SPOTIFY_CLIENT_ID") 
const clientSecret = await env("SPOTIFY_CLIENT_SECRET")

// Initialize Spotify API client
const spotifyApi = new Spotify({
  clientId,
  clientSecret,
})

// Retrieve an access token from Spotify 
const { body: { access_token } } = await spotifyApi.clientCredentialsGrant() 
spotifyApi.setAccessToken(access_token)

// Prompt for search query
const query = await arg("Search Spotify:") 

// Search for tracks on Spotify
const { body: { tracks } } = await spotifyApi.searchTracks(query, { limit: 10 })

// Display search results
let choices = tracks.items.map((track) => ({
  name: track.name, 
  description: track.artists.map((artist) => artist.name).join(", "),
  value: track.external_urls.spotify,
  preview: `<iframe src="${track.external_urls.spotify}" width="100%" height="80" frameBorder="0" allowtransparency="true" allow="encrypted-media"></iframe>`,
}))

await arg({
    placeholder: "Play Track?",
    enter: "Play",
}, choices)

```

## Get Current Time in Different Time Zones

// Name: World Clock
// Description: Shows the current time in different time zones
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"

// Define a list of cities and their time zones
const timeZones = [
  { name: "London", timeZone: "Europe/London" }, 
  { name: "New York", timeZone: "America/New_York" }, 
  { name: "Tokyo", timeZone: "Asia/Tokyo" },
  { name: "Sydney", timeZone: "Australia/Sydney" },
] 

// Get the current time in each time zone
const timeChoices = timeZones.map(({ name, timeZone }) => ({
  name,
  // Display the current time in the specified time zone
  value: new Date().toLocaleTimeString("en-US", { timeZone }),
})) 

// Display the times in a div
await div(
  md(`## Current Time Around the World:

${timeChoices.map((choice) => `* ${choice.name}: ${choice.value}`).join("\n")}
`
  )
)
```

## Convert Text to Emoji

// Name: Text to Emoji
// Description: Converts text to emojis using the 'emoji-dictionary' package
// Author: johnlindquist

```typescript
import "@johnlindquist/kit" 
import emoji from "emoji-dictionary"

// Prompt for text input
const text = await arg("Enter text:") 

// Split the text into words
const words = text.split(" ")

// Convert each word to an emoji 
const emojis = words
  .map(word => emoji.getUnicode(word) || word) // Get the emoji or keep the original word
  .join(" ")

// Display the emojis in a div
await div(md(`# ${emojis}`)) 
```

## Upload Files to Google Drive

// Name: Upload to Google Drive 
// Description: Uploads selected files to Google Drive 
// Author: johnlindquist

```typescript
// Requires authentication with the Google Drive API 
// See instructions: https://developers.google.com/drive/api/quickstart/nodejs 

import "@johnlindquist/kit"
import { google } from "googleapis"

// Retrieve Google Drive API credentials from environment variables
const credentials = JSON.parse(await env("GOOGLE_DRIVE_CREDENTIALS")) 
const auth = new google.auth.GoogleAuth({ 
  credentials,
  // Configure scopes for Google Drive API access 
  scopes: ["https://www.googleapis.com/auth/drive.file"],
}) 
const drive = google.drive({ version: "v3", auth })

// Prompt the user to select files
const filePaths = await selectFile({
  multiple: true,
})

// Upload each selected file
for (const filePath of filePaths) {
  const fileName = path.basename(filePath)

  // Upload the file to the root of Google Drive
  await drive.files.create({
    requestBody: {
      name: fileName, 
    },
    media: {
      mimeType: "application/octet-stream",
      body: createReadStream(filePath), 
    }, 
  })

  // Notify the user about the uploaded file
  await notify({
    title: "Upload Complete", 
    message: `Uploaded ${fileName} to Google Drive`,
  }) 
}
```

## Create a GIF from Images

// Name: Images to GIF
// Description: Creates a GIF from selected images using the 'gifencoder' package
// Author: johnlindquist

```typescript
import "@johnlindquist/kit" 
import { GIFEncoder, quantize, applyPalette } from "gifencoder"
import { createCanvas, Canvas, Image } from "canvas" 

// Prompt for image selection
const imagePaths: string[] = await selectFile({ 
  multiple: true,
}) 

// Create a GIF encoder
const encoder = new GIFEncoder(320, 240)
encoder.start()
encoder.setRepeat(0) // 0 for endless loop
encoder.setDelay(100) // 100ms delay between frames 

// Process each image
for (const imagePath of imagePaths) { 
  // Load the image
  const image = await loadImage(imagePath)

  // Create a canvas and draw the image onto it
  const canvas: Canvas = createCanvas(320, 240)
  const ctx = canvas.getContext("2d") 
  ctx.drawImage(image, 0, 0, 320, 240)

  // Add the frame to the GIF
  encoder.addFrame(ctx)
} 

// Finish encoding the GIF
encoder.finish()

// Save the GIF to a file
const gifBuffer = encoder.out.getData() 
const gifPath = path.join(home("Downloads"), "output.gif")
await writeFile(gifPath, gifBuffer)

await div(md(`GIF created at: ${gifPath}`))
```

## Get Random Chuck Norris Joke

// Name: Chuck Norris Joke
// Description: Fetches and displays a random Chuck Norris joke
// Author: johnlindquist 

```typescript
import "@johnlindquist/kit" 

// Fetch a random Chuck Norris joke from the ICNDb API
const response = await get("https://api.chucknorris.io/jokes/random") 

// Extract the joke text 
const joke = response.data.value

// Display the joke in a div
await div(md(`# ${joke}`))
``` 

## Search and Open GitHub Repository

// Name: Search and Open GitHub Repo
// Description: Search for a GitHub repository and open it in the browser
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"

// Prompt for the search query
const query = await arg("Search GitHub repositories:")

// Fetch repository data from the GitHub API
const response = await get(`https://api.github.com/search/repositories?q=${query}`) 

// Extract repository names and URLs
const repositories = response.data.items.map((item) => ({ 
  name: item.full_name,
  value: item.html_url, 
  description: item.description,
}))

// Display the list of repositories as choices
const selectedRepo = await arg("Choose a repo:", repositories)

// Open the selected repository in the browser
await open(selectedRepo)
```

## Send Email with Attachments

// Name: Send Email with Attachments
// Description: Sends an email with attachments using Nodemailer
// Author: johnlindquist

```typescript
// Get your Nodemailer configuration from https://nodemailer.com/about/

import "@johnlindquist/kit"
import nodemailer from "nodemailer"

// Retrieve email credentials from the environment
const emailUser = await env("EMAIL_USER") 
const emailPassword = await env("EMAIL_PASSWORD")

// Prompt for the recipient's email address
const toEmail = await arg("Enter recipient email:")

// Prompt for the email subject 
const subject = await arg("Enter email subject:") 

// Prompt for the email body
const body = await textarea({ placeholder: "Enter email body:" })

// Prompt for file attachments
const attachments = await selectFile({
  multiple: true,
  message: "Select attachments (use cmd/ctrl to select multiple):",
})

// Create a Nodemailer transporter
const transporter = nodemailer.createTransport({ 
  service: "Gmail", 
  auth: {
    user: emailUser,
    pass: emailPassword,
  },
})

// Define email details with attachments
const mailOptions = { 
  from: emailUser,
  to: toEmail, 
  subject,
  text: body, 
  attachments: attachments.map(filePath => ({
    filename: path.basename(filePath),
    path: filePath,
  })),
}

// Send the email
transporter.sendMail(mailOptions, (error, info) => {
  if (error) { 
    console.error("Error sending email:", error) 
  } else {
    console.log("Email sent:", info.response)
  }
})
```

## Convert Text to Speech and Save to File

// Name: Text to Speech File
// Description: Converts text to speech and saves it as an audio file
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"
import { gTTS } from "gtts"

// Prompt for text input
const text = await arg("Enter text to convert to speech:") 

// Prompt for output file path 
const outputPath = await path({
  startPath: home("Downloads"), 
})

// Create a new text-to-speech instance
const gtts = new gTTS(text, "en") 

// Save the speech to a file
await new Promise<void>((resolve, reject) => {
  gtts.save(outputPath, (err, result) => {
    if (err) {
      reject(err)
    } else { 
      resolve()
    }
  })
}) 

await div(md(`# Audio file saved to: ${outputPath}`))
```

## Check for Duplicate Files

// Name: Check for Duplicates
// Description: Finds and lists duplicate files in a directory
// Author: johnlindquist 

```typescript
import "@johnlindquist/kit"
import { createHash } from "crypto"
import { globby } from "globby"

// Prompt for the directory to scan 
const directoryPath = await path({
  startPath: home("Downloads"), 
  onlyDirs: true,
})

// Get all file paths in the selected directory
const filePaths = await globby(`${directoryPath}/**/*`)

// Create a map to store file hashes and their corresponding paths
const fileHashes: { [hash: string]: string[] } = {}

// Calculate the hash for each file and store it in the map 
for (const filePath of filePaths) {
  const fileBuffer = await readFile(filePath)
  const hash = createHash("sha256").update(fileBuffer).digest("hex")
  if (fileHashes[hash]) { 
    fileHashes[hash].push(filePath) 
  } else {
    fileHashes[hash] = [filePath]
  }
}

// Find duplicate files by checking for entries with more than one path in the map
const duplicateFiles = Object.values(fileHashes).filter(paths => paths.length > 1) 

// Display the list of duplicate files in the editor
await editor(JSON.stringify(duplicateFiles, null, 2))
``` 

## Create a Time-Lapse Video

// Name: Create Time-Lapse
// Description: Creates a time-lapse video from a sequence of images
// Author: johnlindquist 

```typescript
import "@johnlindquist/kit"

// Prompt for the folder containing the image sequence 
const folderPath = await path({ 
  startPath: home("Downloads"),
  onlyDirs: true,
})

// Prompt for the output video file name
const outputFileName = await arg("Enter output file name:") 

// Prompt for frames per second (fps) 
const fps = await arg({
  placeholder: "Enter frames per second (fps):", 
  hint: "Default: 10",
})

// Create the time-lapse video using ffmpeg
await exec(`
  ffmpeg 
  -r ${parseInt(fps) || 10} // Set frames per second 
  -pattern_type glob -i "${folderPath}/*.jpg" // Use glob pattern to input images
  -c:v libx264 -pix_fmt yuv420p // Encode video with H.264 codec 
  "${folderPath}/${outputFileName}.mp4" // Set output file path and name
`) 

// Display the success message
await div(md(`Time-lapse video created: ${outputFileName}.mp4`)) 
``` 

## Generate Code Snippet Documentation

// Name: Generate Code Docs
// Description: Extracts code snippets from a Markdown file and generates documentation
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"
import { Lexer } from "marked"

// Prompt for Markdown file selection
const markdownFilePath = await path({
  startPath: home("Documents"),
})

// Read the Markdown file
const markdown = await readFile(markdownFilePath, "utf-8")

// Extract code snippets from the Markdown using 'marked'
const lexer = new Lexer()
const tokens = lexer.lex(markdown)
const codeBlocks = tokens
  .filter(token => token.type === "code") 
  .map(token => ({ 
    lang: token.lang,
    code: token.text,
  }))

// Prompt for output directory
const outputDirectory = await path({
  startPath: home("Documents"),
  onlyDirs: true,
})

// Create documentation for each code snippet
for (let i = 0; i < codeBlocks.length; i++) {
  const { lang, code } = codeBlocks[i]

  // Prompt for a description of the code snippet
  const description = await arg(
    `Enter description for code block ${i + 1} (language: ${lang}):`,
  )

  // Create a Markdown file for the documentation
  const outputFilePath = path.join(outputDirectory, `snippet-${i + 1}.md`)
  const markdownContent = `## Code Snippet ${i + 1} (${lang})

${description}

\`\`\`${lang}
${code}
\`\`\`
`
  await writeFile(outputFilePath, markdownContent) 
}

await div(md(`Code snippet documentation generated!`)) 
```

## Search and Play YouTube Video

// Name: Search and Play YouTube
// Description: Search for and play a YouTube video using the 'ytdl-core' package
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"
import ytdl from "ytdl-core"

// Prompt for the search query
const query = await arg("Search YouTube:")

// Search for YouTube videos using the `yt-search` package 
let { default: ytSearch } = await npm("yt-search")
const searchResults = await ytSearch(query)

// Prompt for video selection
const video = await arg(
  "Select video:",
  searchResults.videos.map(video => ({
    name: video.title,
    value: video.url,
  })) 
)

// Create an audio stream from the selected video 
const audioStream = ytdl(video, { filter: "audioonly" })

// Play the audio stream
await playAudioFile(audioStream)

// Display the video title
await div(md(`# Now Playing:\n\n${searchResults.videos.find(v => v.url === video).title}`))
```


## Create Event in Google Calendar with Attendees

// Name: Create Google Calendar Event with Attendees
// Description: Creates a new event with attendees on Google Calendar
// Author: johnlindquist

```typescript
// Requires GOOGLE_CALENDAR_API_KEY and GOOGLE_CALENDAR_CLIENT_ID to be set in .env
// Follow the instructions at https://developers.google.com/calendar/api/quickstart/nodejs to create these

import "@johnlindquist/kit"
import { google } from "googleapis"

// Retrieve API key and client ID from environment variables
const apiKey = await env("GOOGLE_CALENDAR_API_KEY")
const clientId = await env("GOOGLE_CALENDAR_CLIENT_ID")

// Initialize Google Calendar API client
const calendar = google.calendar({
  version: "v3", 
  auth: apiKey,
})

// Prompt for event summary
const summary = await arg("Enter event summary:") 

// Prompt for event start time
const startDateTime = await arg({
  placeholder: "Enter event start time (YYYY-MM-DD HH:MM):",
  // Validate the input to ensure it's in the correct format
  validate: (input) => /^\d{4}-\d{2}-\d{2}\s\d{2}:\d{2}$/.test(input), 
}) 

// Prompt for event end time
const endDateTime = await arg({
  placeholder: "Enter event end time (YYYY-MM-DD HH:MM):", 
  // Validate the input to ensure it's in the correct format
  validate: (input) => /^\d{4}-\d{2}-\d{2}\s\d{2}:\d{2}$/.test(input),
})

// Prompt for attendee emails (comma-separated) 
const attendees = await arg("Enter attendee emails (comma-separated):") 
  .split(",")
  .map(email => ({ email: email.trim() })) // Format attendees for the API 

// Create the event with attendees
await calendar.events.insert({ 
  calendarId: "primary",
  requestBody: {
    summary, 
    start: {
      dateTime: startDateTime, 
    },
    end: { 
      dateTime: endDateTime,
    },
    attendees, 
  }, 
}) 

await div(md(`# Event "${summary}" created with attendees:`)) 
await div(md(attendees.map(attendee => `* ${attendee.email}`).join("\n")))
```

## Translate and Speak Text

// Name: Translate and Speak
// Description: Translates text and speaks it using Google Translate and 'say' command
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"
import translate from "@vitalets/google-translate-api"

// Prompt for the text to translate
const text = await arg("Enter text to translate:")

// Prompt for the target language code
const targetLanguage = await arg(
  "Enter target language code (e.g., 'es', 'fr', 'de'):",
)

// Translate the text
const translation = await translate(text, { to: targetLanguage })

// Speak the translated text 
await say(translation.text, {
  // Optional: Choose a different voice
  // name: "Alex"
})

await div(md(`## Translated Text:\n\n${translation.text}`))
```

## Create a New Asana Task

// Name: Create Asana Task
// Description: Creates a new task on Asana
// Author: johnlindquist

```typescript
// Get an Asana API key from https://app.asana.com/0/developer-console

import "@johnlindquist/kit"
import { Client } from "asana" 

// Retrieve Asana API key from the environment 
const asanaToken = await env("ASANA_API_TOKEN")

// Initialize Asana client
const client = Client.create().useAccessToken(asanaToken)

// Prompt for the workspace ID
const workspaceId = await env("ASANA_WORKSPACE_ID", {
  hint: "Enter your Asana Workspace ID", 
})

// Prompt for the project ID
const projectId = await env("ASANA_PROJECT_ID", {
  hint: "Enter your Asana Project ID",
})

// Prompt for the task name
const taskName = await arg("Enter task name:")

// Create the Asana task
await client.tasks.create({ 
  workspace: workspaceId, 
  projects: [projectId],
  name: taskName, 
  // Optional: Set due date for the task 
  // due_on: "2024-03-15",
})

await div(md(`Created Asana task: ${taskName}`))
```

## Get Current Weather with Voice Output

// Name: Weather Report
// Description: Fetches and speaks the current weather for a location 
// Author: johnlindquist

```typescript
// You can grab your API key from https://openweathermap.org/api

import "@johnlindquist/kit" 

// Retrieve OpenWeatherMap API key from the environment
const apiKey = await env("OPENWEATHERMAP_API_KEY")

// Prompt for the location
const location = await arg("Enter city name:")

// Fetch weather data from OpenWeatherMap API
const response = await get(
  `https://api.openweathermap.org/data/2.5/weather?q=${location}&appid=${apiKey}&units=metric`, 
)

// Extract relevant weather information 
const { main: { temp, feels_like }, weather: [{ description }] } = response.data

// Speak the weather report 
await say(`The weather in ${location} is ${description} with a temperature of ${temp} degrees Celsius, but it feels like ${feels_like} degrees.`)

// Display the weather information in a div
await div(
  md(`## Weather in ${location}: 

* Temperature: ${temp}Â°C
* Feels like: ${feels_like}Â°C
* Description: ${description}
`)
)
```

## Send WhatsApp Message

// Name: Send WhatsApp Message 
// Description: Sends a message to a WhatsApp contact using the Twilio API
// Author: johnlindquist

```typescript
// Get a Twilio API key and token from https://www.twilio.com/console

import "@johnlindquist/kit"
import twilio from "twilio"

// Retrieve Twilio credentials from environment variables 
const accountSid = await env("TWILIO_ACCOUNT_SID") 
const authToken = await env("TWILIO_AUTH_TOKEN")

// Initialize Twilio client
const client = twilio(accountSid, authToken)

// Prompt for the recipient's phone number with country code (e.g., +1XXXXXXXXXX)
const toPhoneNumber = await arg("Enter WhatsApp number:")

// Prompt for the message body
const message = await arg("Enter message:")

// Send the WhatsApp message
await client.messages.create({ 
  body: message,
  from: `whatsapp:+14155238886`, // Replace with your Twilio WhatsApp number 
  to: `whatsapp:${toPhoneNumber}`,
}) 

await div(md(`WhatsApp message sent to ${toPhoneNumber}`))
```

## Get Random Wikipedia Article

// Name: Random Wikipedia Article
// Description: Fetches and displays a random Wikipedia article 
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"

// Fetch a random Wikipedia article 
const response = await get("https://en.wikipedia.org/api/rest_v1/page/random/summary")

// Extract article title and URL
const { title, content_urls: { desktop: { page } } } = response.data

// Display the article title and URL 
await div(
  md(`# ${title} 

[${page}](${page})
`)
)
```

## Convert Text to Morse Code

// Name: Text to Morse
// Description: Converts text to Morse code using the 'morse' package 
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"
import morse from "morse"

// Prompt for text input
const text = await arg("Enter text:")

// Convert the text to Morse code
const morseCode = morse.encode(text)

// Display the Morse code in a div
await div(md(`## Morse Code: \n\n${morseCode}`)) 
```


## Create and Play Spotify Playlist

// Name: Create Spotify Playlist
// Description: Creates a new Spotify playlist with selected songs
// Author: johnlindquist

```typescript
// Get a Spotify API Client ID and Secret from https://developer.spotify.com/dashboard/applications 

import "@johnlindquist/kit"
import Spotify from "spotify-web-api-node"

// Retrieve Spotify credentials from environment variables
const clientId = await env("SPOTIFY_CLIENT_ID") 
const clientSecret = await env("SPOTIFY_CLIENT_SECRET")

// Initialize Spotify API client
const spotifyApi = new Spotify({
  clientId,
  clientSecret,
})

// Retrieve an access token from Spotify 
const { body: { access_token } } = await spotifyApi.clientCredentialsGrant()
spotifyApi.setAccessToken(access_token)

// Prompt for playlist name 
const playlistName = await arg("Enter playlist name:")

// Prompt for search query
const searchTerm = await arg("Search for songs:")

// Search Spotify for tracks
const { body: { tracks } } = await spotifyApi.searchTracks(searchTerm, { limit: 10 })

// Allow user to select tracks for the playlist 
const selectedTracks = await select( 
  "Select tracks for playlist (use cmd/ctrl to select multiple):",
  tracks.items.map(track => ({
    name: track.name,
    description: track.artists.map(artist => artist.name).join(", "), 
    value: track.uri,
  })) 
)

// Get user information
const { body: { id: userId } } = await spotifyApi.getMe() 

// Create the playlist 
const { body: { id: playlistId } } = await spotifyApi.createPlaylist(userId, playlistName, { public: false })

// Add selected tracks to the playlist
await spotifyApi.addTracksToPlaylist(playlistId, selectedTracks)

// Open the newly created playlist on Spotify
await open(`https://open.spotify.com/playlist/${playlistId}`)
```

## Get Wikipedia Definition

// Name: Get Wikipedia Definition
// Description: Retrieves a short definition from Wikipedia for a given term
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"
import wtf from "wtf_wikipedia"

// Prompt for the search term 
const term = await arg("Enter a term:") 

// Get the Wikipedia document 
const doc = await wtf.fetch(term)

// Extract the short definition (first sentence of the summary)
const definition = doc?.sentences(0)?.text() || "No definition found"

// Display the definition in a div 
await div(md(`## Definition of ${term}:\n\n${definition}`)) 
```

## Convert Currency

// Name: Convert Currency 
// Description: Converts currency using the 'currency-converter-lt' package
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"
import cc from "currency-converter-lt"

// Prompt for the amount to convert
const amount = parseFloat(await arg("Enter amount:")) 

// Prompt for the source currency code (e.g., USD, EUR, GBP)
const fromCurrency = await arg("Enter source currency code:")

// Prompt for the target currency code 
const toCurrency = await arg("Enter target currency code:") 

try {
  // Convert the currency using the 'currency-converter-lt' package
  const currencyConverter = new cc({ from: fromCurrency, to: toCurrency }) 
  const convertedAmount = await currencyConverter.convert(amount) 

  // Display the converted amount 
  await div(
    md(`## ${amount} ${fromCurrency} = ${convertedAmount.toFixed(2)} ${toCurrency}`)
  )
} catch (error) {
  // Handle any errors, such as invalid currency codes
  await div(md(`# Error: ${error.message}`))
}
```

## Get Current Location Weather with a Widget

// Name: Weather Widget 
// Description: Displays current weather in a widget 
// Author: johnlindquist

```typescript 
// You can grab your API key from https://openweathermap.org/api 

import "@johnlindquist/kit"
import { toHex } from "../core/color"

// Retrieve OpenWeatherMap API key from the environment
const apiKey = await env("OPENWEATHERMAP_API_KEY")

// Get the user's current location 
const locationResponse = await get("http://ip-api.com/json/") 
const { city, country } = locationResponse.data 

// Fetch weather data from OpenWeatherMap API
const weatherResponse = await get(
  `https://api.openweathermap.org/data/2.5/weather?q=${city},${country}&appid=${apiKey}&units=metric`,
)
const {
  main: { temp, feels_like },
  weather: [{ description, icon }],
} = weatherResponse.data

// Fetch the weather icon from OpenWeatherMap
const iconUrl = `http://openweathermap.org/img/wn/${icon}@2x.png`
const iconBuffer = await download(iconUrl) 

// Create a widget to display the weather information
const weatherWidget = await widget( 
  `
  <div class="p-4 flex flex-col items-center"> 
    <img src="data:image/png;base64,${iconBuffer.toString("base64")}" alt="${description}" />
    <h1 class="text-xl font-bold">${city}, ${country}</h1> 
    <p class="text-lg">Temperature: ${temp}Â°C</p>
    <p class="text-lg">Feels like: ${feels_like}Â°C</p> 
    <p class="text-lg">Description: ${description}</p>
  </div>
  `,
  {
    // Customize widget appearance and behavior:
    width: 300, 
    height: 200,
    resizable: true,
    alwaysOnTop: true, 
  }
)

// Update the widget's weather information periodically
setInterval(async () => {
  const weatherResponse = await get(`https://api.openweathermap.org/data/2.5/weather?q=${city},${country}&appid=${apiKey}&units=metric`)
  const {
    main: { temp, feels_like }, 
    weather: [{ description, icon }],
  } = weatherResponse.data

  const iconUrl = `http://openweathermap.org/img/wn/${icon}@2x.png`
  const iconBuffer = await download(iconUrl) 

  weatherWidget.setState({
    html: `
    <div class="p-4 flex flex-col items-center"> 
      <img src="data:image/png;base64,${iconBuffer.toString("base64")}" alt="${description}" />
      <h1 class="text-xl font-bold">${city}, ${country}</h1> 
      <p class="text-lg">Temperature: ${temp}Â°C</p> 
      <p class="text-lg">Feels like: ${feels_like}Â°C</p>
      <p class="text-lg">Description: ${description}</p>
    </div> 
    `
  })
}, 600000) // Update every 10 minutes
```

## Post to a Discord Webhook

// Name: Post to Discord
// Description: Sends a message to a Discord webhook
// Author: johnlindquist 

```typescript
// Get your Discord webhook URL from your server settings: https://support.discord.com/hc/en-us/articles/228383668-Intro-to-Webhooks

import "@johnlindquist/kit"

// Retrieve Discord webhook URL from the environment
const webhookUrl = await env("DISCORD_WEBHOOK_URL")

// Prompt for the message to send
const message = await arg("Enter your message:")

// Post the message to the Discord webhook
await post(webhookUrl, {
  content: message,
  // You can customize the username and avatar
  // username: "Kit Bot",
  // avatar_url: "https://i.imgur.com/T7CAQYg.png" 
})

await div(md(`# Posted to Discord!`))
```

## Get Directions

// Name: Get Directions
// Description: Opens Google Maps with directions from the current location to a destination
// Author: johnlindquist

```typescript
import "@johnlindquist/kit" 

// Prompt for the destination address 
const destination = await arg("Enter destination address:")

// Get the user's current location using IP-API 
const locationResponse = await get("http://ip-api.com/json/")
const { lat, lon } = locationResponse.data

// Construct the Google Maps URL for directions 
const mapsUrl = `https://www.google.com/maps/dir/?api=1&origin=${lat},${lon}&destination=${encodeURIComponent(destination)}` 

// Open the directions in the default browser
await open(mapsUrl)
```

## Convert Text to Speech with Different Voices 

// Name: Text to Speech with Voices
// Description: Converts text to speech with various voices using the 'say' command 
// Author: johnlindquist 

```typescript 
import "@johnlindquist/kit"

// Prompt for the text to convert
const text = await arg("Enter text to convert to speech:")

// Prompt for the voice name
const voice = await arg(
  { placeholder: "Enter voice name (e.g., 'Alex', 'Samantha'):" },
  // List available voices
  (await exec("say -v ?")).stdout.split("\n").map(voice => voice.trim())
)

// Convert the text to speech using the 'say' command with the chosen voice
await say(text, { name: voice })
```

## Schedule a Reminder

// Name: Schedule Reminder
// Description: Schedules a reminder notification for a specific time 
// Author: johnlindquist

```typescript 
import "@johnlindquist/kit"
import schedule from "node-schedule"

// Prompt for reminder message
const message = await arg("Enter reminder message:")

// Prompt for reminder time (HH:MM)
const reminderTime = await arg({
  placeholder: "Enter reminder time (HH:MM):",
  // Validate the time format
  validate: (input) => /^\d{2}:\d{2}$/.test(input)
})

// Extract hours and minutes from the input
const [hours, minutes] = reminderTime.split(":").map(Number)

// Schedule the reminder using 'node-schedule' 
const job = schedule.scheduleJob({ hour: hours, minute: minutes }, async () => {
  // Display a notification at the scheduled time
  await notify({
    title: "Reminder",
    message, 
  })
})

await div(md(`Reminder scheduled for ${reminderTime}`))
```


## Check Website Responsiveness

// Name: Check Website Responsiveness
// Description: Checks a website's responsiveness across different screen sizes using Playwright
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"
import { chromium } from "playwright"

// Prompt for the website URL 
const url = await arg("Enter website URL:")

// Define common screen sizes for testing 
const screenSizes = [
  { width: 375, height: 667, name: "Mobile" },
  { width: 1024, height: 768, name: "Tablet" }, 
  { width: 1920, height: 1080, name: "Desktop" },
] 

// Launch a headless browser
const browser = await chromium.launch()

// Capture a screenshot for each screen size 
for (const { width, height, name } of screenSizes) {
  const context = await browser.newContext({
    viewport: { width, height }, 
  })
  const page = await context.newPage()

  await page.goto(url)
  // Wait for the page to load before taking the screenshot 
  await page.waitForLoadState("networkidle")

  const screenshotPath = tmpPath(`screenshot-${name}.png`)
  await page.screenshot({ path: screenshotPath }) 

  await context.close()

  // Display the screenshot in a div
  await div(
    `<div class="flex items-center justify-center">
      <img src="${screenshotPath}" alt="${name} Screenshot" class="max-w-full h-auto" />
    </div>`
  )
} 

await browser.close() 
```

## Create GitHub Pull Request

// Name: Create GitHub Pull Request
// Description: Creates a new pull request on GitHub
// Author: johnlindquist

```typescript
// Requires GITHUB_TOKEN environment variable. You can generate a token at https://github.com/settings/tokens

import "@johnlindquist/kit"
import { Octokit } from "@octokit/rest"

// Retrieve GitHub personal access token from the environment 
const githubToken = await env("GITHUB_TOKEN")

// Initialize Octokit client
const octokit = new Octokit({ auth: githubToken })

// Prompt for the repository in the format "owner/repo"
const repo = await arg({
  placeholder: "Enter repository (e.g., 'johnlindquist/kit'):",
}) 

// Split the input into owner and repo name
const [owner, repoName] = repo.split("/")

// Prompt for the base branch
const base = await arg("Enter base branch:")

// Prompt for the head branch
const head = await arg("Enter head branch:") 

// Prompt for the pull request title
const title = await arg("Enter pull request title:") 

// Prompt for the pull request body (optional)
const body = await editor({ 
  placeholder: "Enter pull request body (optional):",
  language: "markdown", 
}) 

// Create the pull request
await octokit.rest.pulls.create({
  owner,
  repo: repoName,
  title,
  body, 
  head,
  base,
})

await div(md(`Created pull request: ${title} for ${repo}`))
```

## Get Current Location Information

// Name: Get Location Info
// Description: Fetches and displays detailed information about the user's current location
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"

// Fetch location data from IP-API 
const response = await get("http://ip-api.com/json/") 

// Extract location information
const {
  city,
  regionName,
  country, 
  zip, 
  timezone,
  isp,
  lat, 
  lon,
} = response.data

// Display the location information in a div 
await div( 
  md(`## Your Current Location:

* City: ${city} 
* Region: ${regionName}
* Country: ${country} 
* ZIP Code: ${zip}
* Time Zone: ${timezone}
* ISP: ${isp}
* Latitude: ${lat} 
* Longitude: ${lon}
`
  )
)
```

## Convert Text to Uppercase

// Name: Convert to Uppercase
// Description: Converts selected text to uppercase
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"

// Get the selected text
const text = await getSelectedText()

// Convert the text to uppercase
const uppercaseText = text.toUpperCase()

// Set the selected text to the uppercase version
await setSelectedText(uppercaseText) 
```

## Create a Shortcut to Run a Terminal Command

// Name: Create Shortcut for Terminal Command
// Description: Creates a desktop shortcut to run a terminal command
// Author: johnlindquist

```typescript
import "@johnlindquist/kit" 

// Prompt for the terminal command 
const command = await arg("Enter terminal command:")

// Prompt for the shortcut name
const shortcutName = await arg("Enter shortcut name:") 

// Create the shortcut file content
const shortcutContent = `#!/bin/bash
${command}
`

// Create the shortcut file on the desktop
const shortcutPath = path.join(home("Desktop"), `${shortcutName}.sh`)
await writeFile(shortcutPath, shortcutContent)

// Make the shortcut executable 
await chmod("+x", shortcutPath) 

await div(md(`Shortcut created on Desktop: ${shortcutName}.sh`))
```

## Generate Random User Data

// Name: Generate User Data
// Description: Generates random user data using the 'faker' package
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"
import { faker } from "@faker-js/faker"

// Define the number of users to generate 
const numUsers = parseInt(await arg("Enter the number of users to generate:")) || 10 // Default to 10 users if no input provided

// Generate user data
const users = []
for (let i = 0; i < numUsers; i++) {
  users.push({
    name: faker.person.fullName(),
    email: faker.internet.email(),
    address: faker.location.streetAddress(),
    phone: faker.phone.number(),
  })
}

// Display the user data in the editor
await editor(JSON.stringify(users, null, 2))
```

## Get Commit History for a File

// Name: Get File Commit History
// Description: Shows the commit history for a selected file using 'git log'
// Author: johnlindquist

```typescript
import "@johnlindquist/kit" 

// Prompt for file selection
const filePath = await path()

// Get the commit history for the selected file using 'git log'
const { stdout: commitHistory } = await exec(`git log --pretty=format:"%h - %ad - %s" --date=short "${filePath}"`) 

// Display the commit history in the editor
await editor(commitHistory)
```



## Send Email with Gmail API and HTML Content

// Name: Send HTML Email with Gmail API
// Description: Sends an email with HTML content using the Gmail API 
// Author: johnlindquist

```typescript
// Requires a Google Cloud Platform project with the Gmail API enabled
// See the Gmail API documentation for setup instructions: https://developers.google.com/gmail/api/quickstart/nodejs 

import "@johnlindquist/kit"
import { google } from "googleapis" 

// Retrieve Gmail API credentials from environment variables
const credentials = JSON.parse(await env("GMAIL_CREDENTIALS")) 
const refreshToken = await env("GMAIL_REFRESH_TOKEN") 
// Authorize with the Gmail API
const oAuth2Client = new google.auth.OAuth2(
  credentials.installed.client_id,
  credentials.installed.client_secret,
)
oAuth2Client.setCredentials({ refresh_token: refreshToken })
const gmail = google.gmail({ version: "v1", auth: oAuth2Client })

// Prompt for recipient email address
const to = await arg("Enter recipient email:")

// Prompt for email subject
const subject = await arg("Enter email subject:") 

// Prompt for email body (HTML)
const body = await editor({
  placeholder: "Enter email body (HTML):",
  language: "html",
}) 

// Create the email message
const messageParts = [
  `From: Me <${credentials.installed.client_id}>`, 
  `To: ${to}`,
  "Content-Type: text/html; charset=utf-8",
  "MIME-Version: 1.0", 
  `Subject: ${subject}`, 
  "",
  body,
];
const message = messageParts.join("\n") 

// Encode the email message as base64 
const encodedMessage = Buffer.from(message)
  .toString("base64")
  .replace(/\+/g, "-") 
  .replace(/\//g, "_") 

// Send the email 
await gmail.users.messages.send({
  userId: "me",
  requestBody: {
    raw: encodedMessage,
  }, 
})

await div(md(`HTML email sent to ${to}`))
```

## Upload File to AWS S3

// Name: Upload to AWS S3 
// Description: Uploads a file to an AWS S3 bucket 
// Author: johnlindquist

```typescript 
// Requires AWS credentials configured. 
// You can set them as environment variables: AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY
// or see the AWS SDK documentation: https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/setting-credentials-node.html

import "@johnlindquist/kit"
import AWS from "aws-sdk"

// Retrieve AWS credentials from environment variables
const accessKeyId = await env("AWS_ACCESS_KEY_ID")
const secretAccessKey = await env("AWS_SECRET_ACCESS_KEY")

// Configure AWS SDK
AWS.config.update({
  accessKeyId,
  secretAccessKey,
  region: "us-east-1", // Replace with your desired AWS region
})

// Create an S3 instance 
const s3 = new AWS.S3() 

// Prompt for file selection
const filePath = await path({
  startPath: home("Downloads"),
})

// Prompt for the S3 bucket name 
const bucketName = await env("AWS_BUCKET_NAME") 

// Upload the file to S3
const uploadParams = { 
  Bucket: bucketName,
  Key: path.basename(filePath), // Use the file name as the S3 key
  Body: createReadStream(filePath), // Create a read stream for the file
}

await s3.upload(uploadParams).promise()

await div(md(`Uploaded ${path.basename(filePath)} to S3 bucket: ${bucketName}`))
```

## Get Time Difference Between Two Dates

// Name: Get Time Difference 
// Description: Calculates the time difference between two dates
// Author: johnlindquist

```typescript 
import "@johnlindquist/kit" 
import { differenceInSeconds, formatDistanceToNow } from "date-fns" 

// Prompt for the first date
const firstDate = await arg(
  {
    placeholder: "Enter the first date (YYYY-MM-DD):", 
    // Validate the input date format
    validate: (input) => /^\d{4}-\d{2}-\d{2}$/.test(input),
  },
) 

// Prompt for the second date 
const secondDate = await arg({
  placeholder: "Enter the second date (YYYY-MM-DD):",
  // Validate the input date format
  validate: (input) => /^\d{4}-\d{2}-\d{2}$/.test(input), 
}) 

// Calculate the time difference in seconds 
const diffInSeconds = differenceInSeconds(new Date(secondDate), new Date(firstDate))

// Format the time difference for display 
const formattedDifference = formatDistanceToNow(new Date(firstDate), { addSuffix: true })

// Display the time difference
await div(md(`## Time Difference:

* ${formattedDifference}
* ${diffInSeconds} seconds`))
```

## Get Current Bitcoin Price in Menu Bar

// Name: Bitcoin Price Widget
// Description: Displays the current Bitcoin price in the menu bar 
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"
import CoinGecko from "coingecko-api"

// Initialize CoinGecko API client
const CoinGeckoClient = new CoinGecko()

// Create a menu bar widget
const menu = await widget( 
  `<div class="flex flex-row gap-1">
    <img src="https://img.icons8.com/color/48/bitcoin.png" alt="Bitcoin Logo" width="16" height="16" />
    <span id="bitcoin-price">Loading...</span>
  </div>`,
  {
    // Make the widget compact
    width: 120, 
    height: 24, 
    // Make it draggable
    draggable: false,
    // Prevent it from gaining focus 
    focusable: false, 
    // Optional: Hide the widget initially 
    // show: false,
  } 
)

// Update the Bitcoin price in the widget every minute
setInterval(async () => { 
  // Fetch Bitcoin price data 
  const { data } = await CoinGeckoClient.simple.price({
    ids: ["bitcoin"],
    vs_currencies: ["usd"], 
  }) 

  // Update the widget's content with the current price
  menu.setState({ html: `<div class="flex flex-row gap-1">
    <img src="https://img.icons8.com/color/48/bitcoin.png" alt="Bitcoin Logo" width="16" height="16" />
    <span id="bitcoin-price">$${data.bitcoin.usd}</span>
  </div>`}) 
}, 60000)
```

## Check for Available Disk Space

// Name: Check Disk Space 
// Description: Checks and displays available disk space
// Author: johnlindquist

```typescript
import "@johnlindquist/kit" 
import checkDiskSpace from "check-disk-space"

// Check the available disk space on the root partition
const diskSpace = await checkDiskSpace("/") 

// Display the available disk space in a user-friendly format
await div(
  md(`## Available Disk Space:

* Total: ${filesize(diskSpace.size)}
* Free: ${filesize(diskSpace.free)}`
  )
)
```

## Convert Text to Speech and Play in a Loop

// Name: Text to Speech Loop 
// Description: Converts text to speech and plays it in a loop 
// Author: johnlindquist

```typescript 
import "@johnlindquist/kit" 
import { gTTS } from "gtts" 

// Prompt for text input 
const text = await arg("Enter text:") 

// Function to convert text to speech using gTTS
const createSpeech = async () => {
  // Create a new gTTS instance with the provided text and language 
  const gtts = new gTTS(text, "en") 

  // Save the speech to a temporary file 
  const audioFilePath = tmpPath("speech.mp3") 
  await new Promise<void>((resolve, reject) => {
    gtts.save(audioFilePath, (err, result) => {
      if (err) {
        reject(err)
      } else { 
        resolve() 
      } 
    }) 
  }) 

  // Play the audio file 
  await playAudioFile(audioFilePath, { loop: true })
} 

// Start the speech loop
await createSpeech() 

// Display a message indicating the speech is playing 
await div({
  html: md(`# Speaking in a loop: \n\n${text}`),
  // Add a shortcut to stop the audio
  shortcuts: [
    {
      name: "Stop Audio", 
      key: "s", 
      onPress: async () => { 
        await stopAudioFile()
      },
    },
  ], 
}) 
```

## Get a Random Dad Joke and Display in a Widget

// Name: Dad Joke Widget 
// Description: Shows a random dad joke in a widget
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"

// Function to fetch a random dad joke from icanhazdadjoke.com 
const getDadJoke = async () => {
  const response = await get("https://icanhazdadjoke.com/", { 
    headers: { Accept: "text/plain" },
  })
  return response.data 
}

// Create a widget to display the dad joke
const dadJokeWidget = await widget(
  `<div class="p-4 text-center text-xl font-semibold">{{joke}}</div>`,
  {
    width: 400, 
    height: 100, 
    resizable: true, 
    // Optional: Hide the widget initially 
    // show: false,
  }
)

// Fetch and display a random dad joke in the widget 
const updateJoke = async () => {
  dadJokeWidget.setState({
    joke: await getDadJoke(),
  })
}
await updateJoke() // Display the first joke on initialization

// Update the joke in the widget every 5 minutes 
setInterval(updateJoke, 300000) 
```




## Get Trending GitHub Repositories

// Name: Trending GitHub Repositories
// Description: Displays a list of trending repositories on GitHub
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"

// Prompt for the programming language 
const language = await arg("Enter programming language:")

// Fetch trending repositories from the GitHub API
const response = await get(
  `https://api.github.com/search/repositories?q=language:${language}&sort=stars&order=desc`,
)

// Extract repository information 
const repositories = response.data.items.map(repo => ({
  name: repo.full_name, 
  value: repo.html_url,
  description: repo.description,
}))

// Display the list of repositories as choices 
const selectedRepo = await arg("Select a repository:", repositories)

// Open the selected repository in the browser
await open(selectedRepo)
```

## Generate TypeScript Types from URL

// Name: Generate Types from URL 
// Description: Generates TypeScript types from a JSON schema URL using 'quicktype-core'
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"
import { quicktype, InputData, JSONSchemaInput, FetchingJSONSchemaStore } from "quicktype-core"

// Prompt for the JSON schema URL
const schemaUrl = await arg("Enter JSON schema URL:")

// Convert JSON schema to TypeScript types using quicktype 
async function generateTypes() {
  const schemaInput = new JSONSchemaInput(new FetchingJSONSchemaStore())

  // Name the top-level type "MyType" 
  await schemaInput.addSource({ name: "MyType", url: schemaUrl })

  const inputData = new InputData()
  inputData.addInput(schemaInput)

  const { lines } = await quicktype({
    inputData, 
    lang: "typescript",
  })

  return lines.join("\n")
}

// Display the generated types in the editor 
await editor(await generateTypes())
```

## Check for Unused NPM Packages

// Name: Check for Unused Packages
// Description: Identifies unused npm packages in a project using 'depcheck' 
// Author: johnlindquist 

```typescript
import "@johnlindquist/kit"
import depcheck from "depcheck"

// Get the current working directory
const projectPath = cwd()

// Run depcheck to find unused dependencies
const unused = await depcheck(projectPath, {
  // Customize depcheck options: 
  // ignoreBinPackage: false, // Check for unused binary packages
  // skipMissing: false,      // Analyze dependencies even if they are missing 
}) 

// Display the list of unused dependencies in the editor 
await editor(
  `## Unused Dependencies:

${JSON.stringify(unused.dependencies, null, 2)}
`
) 
```

## Create a New Google Doc

// Name: Create Google Doc
// Description: Creates a new Google Doc using the Google Docs API
// Author: johnlindquist

```typescript
// Requires a Google Cloud Platform project with the Google Docs API enabled
// See the Google Docs API documentation for setup instructions: https://developers.google.com/docs/api/quickstart/nodejs

import "@johnlindquist/kit" 
import { google } from "googleapis"

// Retrieve Google Docs API credentials from environment variables
const credentials = JSON.parse(await env("GOOGLE_DOCS_CREDENTIALS"))
const auth = new google.auth.GoogleAuth({
  credentials, 
  // Configure scopes for Google Docs API access
  scopes: ["https://www.googleapis.com/auth/documents"],
}) 
const docs = google.docs({ version: "v1", auth }) 

// Prompt for document title
const documentTitle = await arg("Enter document title:") 

// Create a new Google Doc
const { data: { documentId } } = await docs.documents.create({
  requestBody: { 
    title: documentTitle, 
  }, 
})

// Open the newly created document in the browser
await open(`https://docs.google.com/document/d/${documentId}/edit`)
```

## Take a Screenshot of the Active Window

// Name: Capture Active Window
// Description: Takes a screenshot of the active window (macOS only) 
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"

// Capture the screen using the 'screencapture' command (macOS only)
await exec(`screencapture -W ${tmpPath("screenshot.png")}`)

// Display the screenshot in a div
await div(
  `<div class="flex items-center justify-center">
  <img src="${tmpPath("screenshot.png")}" alt="Screenshot" class="max-w-full h-auto"/>
  </div>`,
)
```

## Convert Text to Audio with ElevenLabs

// Name: Text to Speech (ElevenLabs)
// Description: Converts text to speech using the ElevenLabs API 
// Author: johnlindquist 

```typescript
// Requires an API key from https://elevenlabs.io 

import "@johnlindquist/kit"
import axios from "axios"

// Retrieve ElevenLabs API key from the environment
const apiKey = await env("ELEVENLABS_API_KEY")

// Prompt for the text input 
const text = await arg("Enter text to convert:") 

// Prompt for the voice ID
const voiceId = await arg("Enter ElevenLabs voice ID:") 

// Send a request to the ElevenLabs API to generate the audio 
const response = await axios.post(
  "https://api.elevenlabs.io/v1/text-to-speech/" + voiceId, 
  {
    text,
    voice_settings: {
      stability: 0.5, 
      similarity_boost: 0.5,
    },
  },
  {
    headers: {
      "xi-api-key": apiKey,
      "Content-Type": "application/json", 
      Accept: "audio/mpeg", 
    },
    responseType: "arraybuffer", 
  }
)

// Save the generated audio to a temporary file
const audioFilePath = tmpPath("speech.mp3") 
await writeFile(audioFilePath, Buffer.from(response.data))

// Play the audio file
await playAudioFile(audioFilePath) 
```

## Generate PDF from Webpage

// Name: Webpage to PDF
// Description: Converts a webpage to PDF using Playwright
// Author: johnlindquist

```typescript
import "@johnlindquist/kit" 
import { chromium } from "playwright"

// Prompt for the webpage URL 
const url = await arg("Enter webpage URL:")

// Launch a headless browser
const browser = await chromium.launch()
const context = await browser.newContext() 
const page = await context.newPage()

// Navigate to the webpage
await page.goto(url)
// Wait for the page to load
await page.waitForLoadState("networkidle")

// Generate the PDF 
const pdfBuffer = await page.pdf() 

// Prompt for output PDF file path
const outputPath = await path({
  startPath: home("Downloads"), 
}) 

// Save the PDF to the selected path
await writeFile(outputPath, pdfBuffer)

// Close the browser
await browser.close()

await div(md(`PDF saved to: ${outputPath}`))
```


## Generate Random Password with Clipboard History

// Name: Generate and Copy Password
// Description: Generates a strong random password, copies it to the clipboard, and adds it to the clipboard history
// Author: johnlindquist

```typescript 
import "@johnlindquist/kit"
import generator from "generate-password"

// Prompt for password length
const passwordLength = await arg({
  placeholder: "Enter desired password length:",
  hint: "Default: 16",
})

// Generate the password
const password = generator.generate({
  length: parseInt(passwordLength) || 16, // Default to 16 if no length provided 
  numbers: true,
  symbols: true,
  lowercase: true,
  uppercase: true, 
  excludeSimilarCharacters: true,
})

// Copy the generated password to the clipboard 
await copy(password)
// Add the password to the clipboard history
await addToClipboardHistory({
  name: "Generated Password",
  value: password,
  // Mark as a potential secret to hide in previews 
  maybeSecret: true,
}) 

// Display the generated password (masked for security)
await div(md(`## Generated Password:

${"*".repeat(password.length)} (copied to clipboard and added to history)`))
```

## Create GitHub Release

// Name: Create GitHub Release
// Description: Creates a new release for a GitHub repository
// Author: johnlindquist

```typescript
// Requires GITHUB_TOKEN environment variable. You can generate a token at https://github.com/settings/tokens

import "@johnlindquist/kit" 
import { Octokit } from "@octokit/rest"

// Retrieve GitHub personal access token from the environment
const githubToken = await env("GITHUB_TOKEN")

// Initialize Octokit client 
const octokit = new Octokit({ auth: githubToken }) 

// Prompt for the repository in the format "owner/repo" 
const repo = await arg({
  placeholder: "Enter repository (e.g., 'johnlindquist/kit'):", 
})

// Split the input into owner and repo name 
const [owner, repoName] = repo.split("/") 

// Prompt for the tag name
const tagName = await arg("Enter tag name:")

// Prompt for the release name
const name = await arg("Enter release name:") 

// Prompt for the release body (optional) 
const body = await editor({
  placeholder: "Enter release body (optional):",
  language: "markdown",
}) 

// Create the release
await octokit.rest.repos.createRelease({ 
  owner, 
  repo: repoName,
  tag_name: tagName,
  name,
  body,
  draft: false, 
  prerelease: false, 
}) 

await div(md(`Created release ${name} for ${repo}`))
```

## Check if Port is Open

// Name: Check Port
// Description: Checks if a specific port is open using the 'tcp-port-used' package
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"
import tcpPortUsed from "tcp-port-used" 

// Prompt for the port number
const port = parseInt(await arg("Enter port number:")) 

// Check if the port is open 
const isOpen = await tcpPortUsed.check(port) 

// Display the port status
await div(md(`## Port ${port} is ${isOpen ? "open" : "closed"}.`))
```

## Get User's Public IP Address and Location

// Name: My IP and Location 
// Description: Fetches and displays the user's public IP and location information
// Author: johnlindquist

```typescript
import "@johnlindquist/kit" 
import publicIp from "public-ip"

// Fetch the user's public IP address
const ipAddress = await publicIp.v4() 

// Fetch location data based on the IP address using IP-API 
const response = await get(`http://ip-api.com/json/${ipAddress}`) 

// Extract location information
const { city, regionName, country, zip } = response.data

// Display the IP address and location information
await div(
  md(`## Your Public IP Address:

* ${ipAddress}

## Location:

* City: ${city} 
* Region: ${regionName} 
* Country: ${country} 
* ZIP Code: ${zip} 
`)
)
```

## Convert Text to Binary

// Name: Text to Binary
// Description: Converts text to binary representation
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"

// Prompt for text input
const text = await arg("Enter text:")

// Convert the text to binary 
const binary = text
  .split("") 
  .map(char => char.charCodeAt(0).toString(2).padStart(8, "0")) 
  .join(" ")

// Display the binary representation in a div
await div(md(`## Binary: \n\n${binary}`))
```

## Create and Schedule a Google Meet Meeting

// Name: Schedule Google Meet
// Description: Schedules a Google Meet meeting using the Google Calendar API
// Author: johnlindquist

```typescript
// Requires GOOGLE_CALENDAR_API_KEY and GOOGLE_CALENDAR_CLIENT_ID to be set in .env
// Follow the instructions at https://developers.google.com/calendar/api/quickstart/nodejs to create these

import "@johnlindquist/kit"
import { google } from "googleapis" 

// Retrieve API key and client ID from environment variables
const apiKey = await env("GOOGLE_CALENDAR_API_KEY") 
const clientId = await env("GOOGLE_CALENDAR_CLIENT_ID") 

// Initialize Google Calendar API client 
const calendar = google.calendar({ 
  version: "v3",
  auth: apiKey, 
}) 

// Prompt for meeting title
const summary = await arg("Enter meeting title:")

// Prompt for meeting start time (YYYY-MM-DD HH:MM)
const startDateTime = await arg({
  placeholder: "Enter meeting start time (YYYY-MM-DD HH:MM):",
  validate: (input) => /^\d{4}-\d{2}-\d{2}\s\d{2}:\d{2}$/.test(input),
})

// Prompt for meeting end time (YYYY-MM-DD HH:MM)
const endDateTime = await arg({
  placeholder: "Enter meeting end time (YYYY-MM-DD HH:MM):",
  validate: (input) => /^\d{4}-\d{2}-\d{2}\s\d{2}:\d{2}$/.test(input), 
})

// Prompt for attendee emails (comma-separated)
const attendees = await arg("Enter attendee emails (comma-separated):") 
  .split(",") 
  .map(email => ({ email: email.trim() })) // Format attendees for the API

// Create the Google Meet meeting 
const event = {
  summary, 
  start: {
    dateTime: startDateTime, 
  }, 
  end: {
    dateTime: endDateTime, 
  },
  attendees,
  // Configure conference data for Google Meet
  conferenceData: {
    createRequest: { 
      requestId: `${Date.now()}`, // Unique request ID 
      conferenceSolutionKey: { type: "hangoutsMeet" }, 
    },
  }, 
}

// Insert the event into the primary calendar
const { data } = await calendar.events.insert({ 
  calendarId: "primary",
  requestBody: event,
  conferenceDataVersion: 1, // Required for creating Google Meet meetings 
})

// Extract the Google Meet link from the response 
const meetLink = data.hangoutsMeet?.createRequest?.conferenceSolution?.entryPoints?.[0]?.uri

// Display the Google Meet link
await div(md(`## Google Meet Link:

[${meetLink}](${meetLink})`))
```

## Check for Outdated NPM Packages

// Name: Check for Outdated Packages 
// Description: Checks for outdated npm packages in a project
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"

// Get the current working directory
const projectPath = cwd()

// Execute the `npm outdated` command to check for outdated packages 
const { stdout: outdatedPackages } = await exec(`npm outdated --long`, {
  cwd: projectPath, 
})

// Display the list of outdated packages in the editor
await editor(outdatedPackages) 
```


## Resize Image and Set as Desktop Wallpaper

// Name: Set Resized Image as Wallpaper
// Description: Resizes an image and sets it as the desktop wallpaper 
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"
import sharp from "sharp"

// Prompt for image selection
const imagePath = await path({
  startPath: home("Downloads"),
})

// Get the screen resolution
const { width: screenWidth, height: screenHeight } = (await getActiveScreen()).workArea

// Prompt for resize mode 
const resizeMode = await arg("Choose resize mode:", [
  { name: "Fit", value: "fit" }, 
  { name: "Fill", value: "fill" },
  { name: "Stretch", value: "stretch" },
]) 

// Resize the image based on the selected mode 
let resizedImagePath = ""
if (resizeMode === "fit") {
  // Resize to fit the screen, maintaining aspect ratio
  resizedImagePath = await tmpPath("resized-wallpaper.jpg")
  await sharp(imagePath).resize(screenWidth, screenHeight, {
    fit: "contain",
    background: { r: 255, g: 255, b: 255, alpha: 1 }, // White background
  }).toFile(resizedImagePath);
} else if (resizeMode === "fill") { 
  // Resize to fill the screen, cropping if necessary
  resizedImagePath = await tmpPath("resized-wallpaper.jpg")
  await sharp(imagePath).resize(screenWidth, screenHeight, { 
    fit: "cover", 
  }).toFile(resizedImagePath);
} else {
  // Stretch the image to fit the screen 
  resizedImagePath = await tmpPath("resized-wallpaper.jpg")
  await sharp(imagePath).resize(screenWidth, screenHeight, {
    fit: "fill",
  }).toFile(resizedImagePath);
}

// Set the resized image as the desktop wallpaper 
await setWallpaper(resizedImagePath) 

await div(md(`# Wallpaper updated!`))
```

## Create a Trello Card with a Checklist

// Name: Create Trello Card with Checklist
// Description: Creates a new Trello card with a checklist
// Author: johnlindquist 

```typescript
// Get a Trello API key and token from https://trello.com/app-key

import "@johnlindquist/kit"

// Retrieve Trello API key and token from the environment 
const trelloKey = await env("TRELLO_API_KEY")
const trelloToken = await env("TRELLO_TOKEN") 

// Prompt for the board ID
const boardId = await env("TRELLO_BOARD_ID", {
  hint: "Enter your Trello Board ID",
}) 

// Prompt for the list ID
const listId = await env("TRELLO_LIST_ID", {
  hint: "Enter your Trello List ID",
})

// Prompt for the card name
const cardName = await arg("Enter card name:") 

// Prompt for checklist items (comma-separated) 
const checklistItems = await arg("Enter checklist items (comma-separated):") 
  .split(",")
  .map((item) => item.trim())

// Create the Trello card 
const { data: { id: cardId } } = await get(
  `https://api.trello.com/1/cards`,
  { 
    params: {
      key: trelloKey,
      token: trelloToken, 
      idList: listId,
      name: cardName,
    },
  }
)

// Create a checklist on the card 
const { data: { id: checklistId } } = await post(
  `https://api.trello.com/1/checklists`, 
  { 
    params: {
      key: trelloKey,
      token: trelloToken,
      idCard: cardId,
      name: "Checklist",
    },
  }
)

// Add items to the checklist
for (const item of checklistItems) {
  await post(
    `https://api.trello.com/1/checklists/${checklistId}/checkItems`,
    {
      params: {
        key: trelloKey,
        token: trelloToken,
        name: item, 
      },
    }
  ) 
}

await div(md(`Created Trello card: ${cardName} with a checklist`))
```

## Get Random Programming Joke

// Name: Programming Joke
// Description: Fetches and displays a random programming joke from JokeAPI
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"

// Fetch a random programming joke from JokeAPI
const response = await get(
  "https://v2.jokeapi.dev/joke/Programming",
)

// Extract joke setup and delivery (if applicable)
let joke = ""
if (response.data.type === "single") {
  joke = response.data.joke
} else if (response.data.type === "twopart") { 
  joke = `${response.data.setup}\n\n${response.data.delivery}`
}

// Display the joke in a div
await div(md(`# ${joke}`)) 
```

## Download File with Progress Bar

// Name: Download File with Progress
// Description: Downloads a file with a progress bar displayed in a widget
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"
import axios from "axios"

// Prompt for the file URL to download 
const downloadUrl = await arg({
  placeholder: "Enter a file URL to download:",
}) 

// Set the download path
const downloadPath = tmpDownloadsDir(path.basename(downloadUrl)) 

// Create a widget to display the progress bar
const progressWidget = await widget(
  `<div class="p-4"> 
    <div class="w-full bg-gray-200 rounded-full h-2.5 dark:bg-gray-700">
      <div id="progress-bar" class="bg-blue-600 h-2.5 rounded-full" style="width: 0%"></div>
    </div>
    <div id="progress-text" class="text-center text-sm pt-2">0%</div>
  </div>`, 
  {
    width: 300,
    height: 60, 
    resizable: true, 
  } 
)

// Download the file using axios with progress tracking
axios({ 
  url: downloadUrl,
  method: "GET", 
  responseType: "stream", 
  onDownloadProgress: (progressEvent) => {
    // Calculate download progress percentage
    const percentage = Math.round((progressEvent.loaded * 100) / progressEvent.total);

    // Update the progress bar and text in the widget
    progressWidget.setState({
      html: `<div class="p-4">
        <div class="w-full bg-gray-200 rounded-full h-2.5 dark:bg-gray-700">
          <div id="progress-bar" class="bg-blue-600 h-2.5 rounded-full" style="width: ${percentage}%"></div>
        </div> 
        <div id="progress-text" class="text-center text-sm pt-2">${percentage}%</div>
      </div>`,
    })
  },
}).then(async (response) => {
  // Create a write stream for the downloaded file 
  const writer = createWriteStream(downloadPath) 

  // Pipe the downloaded data to the file
  response.data.pipe(writer) 

  // Display a notification when the download is complete
  writer.on("finish", async () => {
    await notify({
      title: "Download Complete",
      message: `Downloaded ${path.basename(downloadUrl)}`,
    })
    await revealFile(downloadPath) 
  })
})
```

## Capture Webcam Image and Upload to Imgur

// Name: Webcam to Imgur
// Description: Captures a webcam image and uploads it to Imgur
// Author: johnlindquist

```typescript
// Get an Imgur Client ID from https://api.imgur.com/oauth2/addclient

import "@johnlindquist/kit"
import axios from "axios" 

// Retrieve Imgur Client ID from environment variables
const clientId = await env("IMGUR_CLIENT_ID") 

// Capture an image from the webcam
const imageBuffer = await webcam() 

// Convert the image buffer to base64
const base64Image = imageBuffer.toString("base64") 

// Upload the image to Imgur using the API
const response = await axios.post(
  "https://api.imgur.com/3/image",
  {
    image: base64Image,
  }, 
  {
    headers: {
      Authorization: `Client-ID ${clientId}`,
    },
  }
) 

// Extract the image link from the Imgur response
const imageUrl = response.data.data.link 

// Copy the image URL to the clipboard
await copy(imageUrl)

// Display the uploaded image URL
await div(md(`## Uploaded Image:

[${imageUrl}](${imageUrl}) (copied to clipboard)`)) 
```

## Get Random Dog Image by Breed

// Name: Random Dog by Breed ðŸ¶
// Description: Displays a random dog image by breed
// Author: johnlindquist

```typescript 
import "@johnlindquist/kit" 

// Prompt for the dog breed
const breed = await arg("Enter dog breed:") 

// Fetch a random dog image from the Dog CEO API
const response = await get(
  `https://dog.ceo/api/breed/${breed}/images/random`, 
) 

// Extract the image URL 
const imageUrl = response.data.message 

// Display the dog image in a div 
await div(`<img src="${imageUrl}" alt="Random Dog" class="w-full h-auto"/>`)
```

## Send Message to Telegram

// Name: Send Telegram Message
// Description: Sends a message to a Telegram chat using the 'node-telegram-bot-api' package
// Author: johnlindquist

```typescript
// Get a Telegram Bot API Token from BotFather: https://core.telegram.org/bots#6-botfather

import "@johnlindquist/kit" 
import TelegramBot from "node-telegram-bot-api" 

// Retrieve Telegram Bot API Token from the environment
const botToken = await env("TELEGRAM_BOT_TOKEN")

// Prompt for the chat ID
const chatId = await env("TELEGRAM_CHAT_ID", { 
  hint: "Enter Telegram chat ID", 
}) 

// Prompt for the message
const message = await arg("Enter message:") 

// Create a Telegram bot instance
const bot = new TelegramBot(botToken) 

// Send the message to the specified chat
bot.sendMessage(chatId, message)

await div(md(`# Message sent to Telegram!`))
```

## Check for Typos in Text

// Name: Check for Typos
// Description: Checks the spelling of text using the 'spellchecker' package
// Author: johnlindquist

```typescript
import "@johnlindquist/kit" 
import SpellChecker from "spellchecker" 

// Prompt for text input 
const text = await editor({ placeholder: "Enter text to check for typos:" })

// Find misspelled words 
const misspelled = SpellChecker.checkSpelling(text)

// Highlight misspelled words in the text 
let highlightedText = text 
for (const { start, end } of misspelled) { 
  const word = text.substring(start, end)
  highlightedText = highlightedText.replace(word, `<span class="text-red-500">${word}</span>`)
}

// Display the text with highlighted typos 
await div(md(highlightedText)) 
```
## Get Directions with Travel Mode Selection

// Name: Get Directions with Travel Mode
// Description: Opens Google Maps with directions, allowing travel mode selection
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"

// Prompt for the destination address
const destination = await arg("Enter destination address:")

// Prompt for the desired travel mode
const travelMode = await arg("Choose travel mode:", [ 
  "driving", 
  "walking",
  "bicycling",
  "transit",
])

// Get the user's current location using IP-API 
const locationResponse = await get("http://ip-api.com/json/") 
const { lat, lon } = locationResponse.data

// Construct the Google Maps URL for directions with the selected travel mode 
const mapsUrl = `https://www.google.com/maps/dir/?api=1&origin=${lat},${lon}&destination=${encodeURIComponent(destination)}&travelmode=${travelMode}`

// Open the directions in the default browser 
await open(mapsUrl)
```

## Create a ZIP Archive with Password Protection

// Name: Create Password-Protected ZIP
// Description: Creates a password-protected ZIP archive of a selected folder
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"
import archiver from "archiver" 

// Prompt for the folder to archive 
const folderPath = await path({
  startPath: home("Downloads"),
  onlyDirs: true,
}) 

// Prompt for the output file name 
const outputFileName = await arg("Enter output file name:")

// Prompt for the password 
const password = await arg({
  placeholder: "Enter password:", 
  secret: true,
}) 

// Create a write stream for the output ZIP file
const output = createWriteStream(path.join(folderPath, `${outputFileName}.zip`))

// Initialize the archiver
const archive = archiver("zip", {
  zlib: { level: 9 },
})

// Set the password for the archive
archive.setPassword(password)

// Pipe the archive data to the output stream
archive.pipe(output)

// Add the selected folder to the archive
archive.directory(folderPath, false)

// Finalize the archive
await archive.finalize()

await div(md(`Created password-protected archive: ${outputFileName}.zip`))
```

## Convert Text to Speech with Amazon Polly

// Name: Text to Speech (Amazon Polly)
// Description: Converts text to speech using Amazon Polly
// Author: johnlindquist

```typescript
// Requires AWS credentials to be configured.
// You can set them as environment variables: AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY
// or see the AWS SDK documentation: https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/setting-credentials-node.html 

import "@johnlindquist/kit" 
import AWS from "aws-sdk"

// Retrieve AWS credentials from environment variables
const accessKeyId = await env("AWS_ACCESS_KEY_ID") 
const secretAccessKey = await env("AWS_SECRET_ACCESS_KEY")

// Configure AWS SDK
AWS.config.update({ 
  accessKeyId, 
  secretAccessKey,
  region: "us-east-1", // Replace with your desired AWS region 
})

// Create a Polly instance
const polly = new AWS.Polly()

// Prompt for text input
const text = await arg("Enter text to convert:")

// Prompt for the voice ID
const voiceId = await arg("Enter Amazon Polly voice ID:")

// Synthesize speech using Amazon Polly 
const { AudioStream } = await polly
  .synthesizeSpeech({
    OutputFormat: "mp3", 
    Text: text,
    VoiceId: voiceId, 
  }) 
  .promise()

// Save the generated audio to a file 
const audioFilePath = tmpPath("speech.mp3")
await writeFile(audioFilePath, AudioStream as Buffer)

// Play the audio file 
await playAudioFile(audioFilePath)
```

## Check for Grammar Errors

// Name: Grammar Check
// Description: Checks the grammar of text using the 'grammarly' package
// Author: johnlindquist

```typescript
// Requires a Grammarly API key. See https://developer.grammarly.com/

import "@johnlindquist/kit"
import { grammarly } from "grammarly" 

// Retrieve Grammarly API key from the environment 
const grammarlyApiKey = await env("GRAMMARLY_API_KEY")

// Prompt for text input
const text = await editor({
  placeholder: "Enter text to check for grammar errors:",
})

// Check the text for grammar errors using Grammarly API
const result = await grammarly(text, {
  key: grammarlyApiKey,
})

// Extract and highlight grammatical errors 
let highlightedText = text;
for (const alert of result.alerts) {
  const { start, end } = alert;
  const errorText = text.substring(start, end)
  highlightedText = highlightedText.replace(errorText, `<span class="text-red-500">${errorText}</span>`)
}

// Display the text with highlighted errors
await div(md(highlightedText))
```

## Get Current Weather with Location Autocomplete

// Name: Weather with Location Autocomplete
// Description: Fetches weather for a location, providing autocomplete suggestions
// Author: johnlindquist

```typescript 
// You can grab your API key from https://openweathermap.org/api

import "@johnlindquist/kit"

// Retrieve OpenWeatherMap API key from the environment
const apiKey = await env("OPENWEATHERMAP_API_KEY")

// Function to fetch location suggestions using OpenCage Geocoding API
const searchLocations = async (query: string) => {
  // Get OpenCage Geocoding API key
  const geocodingApiKey = await env("OPENCAGE_API_KEY", {
    hint: "Get a free API key from https://opencagedata.com/",
  })

  // Fetch location suggestions
  const response = await get(
    `https://api.opencagedata.com/geocode/v1/json?q=${encodeURIComponent(query)}&key=${geocodingApiKey}`,
  )

  return response.data.results.map(result => ({ 
    name: `${result.formatted}`,
    value: result, // Store the full result object for later use
  }))
}

// Prompt for location with autocomplete suggestions
const location = await arg({
  placeholder: "Enter location:",
  choices: searchLocations,
})

// Extract latitude and longitude from the selected location
const { geometry: { lat, lng } } = location 

// Fetch weather data from OpenWeatherMap API using coordinates
const weatherResponse = await get(`https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lng}&appid=${apiKey}&units=metric`)

// Extract relevant weather information
const { main: { temp, feels_like }, weather: [{ description }] } = weatherResponse.data

// Display the weather information in a div 
await div(
  md(`## Weather in ${location.formatted}:

* Temperature: ${temp}Â°C
* Feels like: ${feels_like}Â°C
* Description: ${description}
`
  )
)
```

## Extract Text from PDF File

// Name: Extract PDF Text
// Description: Extracts text content from a PDF file using the 'pdf-parse' package
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"
import { PDFParse } from "pdf-parse"

// Prompt for PDF file selection
const pdfFilePath = await path({ 
  startPath: home("Downloads"), 
})

// Read the PDF file
const pdfBuffer = await readFile(pdfFilePath)

// Extract text from the PDF using the 'pdf-parse' package
const data = await PDFParse(pdfBuffer) 

// Display the extracted text in the editor
await editor(data.text)
```

## Convert Text to Speech and Create Audio File with Different Voices

// Name: Text to Speech File (Multiple Voices) 
// Description: Converts text to speech using multiple voices and saves them to audio files
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"
import { gTTS } from "gtts"

// Prompt for the text to convert
const text = await arg("Enter text to convert:") 

// Define a list of voices and their corresponding language codes
const voices = [
  { name: "Alex", lang: "en" },
  { name: "Samantha", lang: "en-US" },
  { name: "Daniel", lang: "en-GB" }, 
] 

// Prompt the user to select voices
const selectedVoices = await select(
  "Choose voices (use cmd/ctrl to select multiple):", 
  voices
)

// Generate audio for each selected voice
for (const { name, lang } of selectedVoices) {
  // Create a new gTTS instance with the text and selected language 
  const gtts = new gTTS(text, lang)

  // Save the speech to a file with the voice name
  const audioFilePath = tmpPath(`speech-${name}.mp3`)
  await new Promise<void>((resolve, reject) => {
    gtts.save(audioFilePath, (err, result) => { 
      if (err) {
        reject(err)
      } else {
        resolve() 
      }
    })
  }) 
  
  // Notify the user about the saved audio file
  await notify({
    title: "Text to Speech",
    message: `Audio saved for voice: ${name}`,
  })
}
```



## Generate Color Palette and Copy as Tailwind CSS

// Name: Generate Tailwind Palette 
// Description: Creates a Tailwind CSS color palette from an image
// Author: johnlindquist 

```typescript
import "@johnlindquist/kit"
import Vibrant from "node-vibrant" 

// Prompt for image selection
const imagePath = await path({
  startPath: home("Downloads"),
})

// Generate the color palette from the image 
const palette = await Vibrant.from(imagePath).getPalette()

// Generate Tailwind CSS classes for each color 
let css = `` 
for (const [name, swatch] of Object.entries(palette)) {
  if (swatch) { 
    // Only generate classes if the swatch is valid 
    css += `
      .bg-${name.toLowerCase()}-500 { background-color: ${swatch.hex}; } 
      .text-${name.toLowerCase()}-500 { color: ${swatch.hex}; }
    `
  }
}

// Copy the generated CSS to the clipboard
await copy(css) 

// Display the generated CSS and a success message
await div(
  md(`## Tailwind CSS Palette (copied to clipboard): 
  
\`\`\`css 
${css} 
\`\`\``)
)
```

## Search and Download NPM Package

// Name: Search and Download NPM Package
// Description: Searches for an NPM package and downloads it to the Downloads folder
// Author: johnlindquist 

```typescript
import "@johnlindquist/kit"

// Prompt for the package name 
const packageName = await arg("Enter NPM package name:") 

// Fetch package information from the npm registry API 
const response = await get(`https://registry.npmjs.org/${packageName}`) 
const latestVersion = response.data["dist-tags"].latest

// Construct the package tarball URL 
const tarballUrl = response.data.versions[latestVersion].dist.tarball 

// Download the package tarball to the Downloads folder
await download(tarballUrl, home("Downloads"))

await div(md(`Downloaded ${packageName}@${latestVersion} to Downloads folder`))
```

## Check Website SSL Certificate

// Name: Check Website SSL
// Description: Checks the SSL certificate of a website using the 'ssl-checker' package
// Author: johnlindquist 

```typescript 
import "@johnlindquist/kit"
import sslChecker from "ssl-checker" 

// Prompt for the website URL
const websiteUrl = await arg("Enter website URL:") 

// Check the SSL certificate using the 'ssl-checker' package 
sslChecker(websiteUrl, { method: "GET" })
  .then((result) => { 
    // Display certificate information
    div(
      md(`## SSL Certificate for ${websiteUrl}:

* **Valid:** ${result.valid}
* **Days Remaining:** ${result.daysRemaining}
* **Issuer:** ${result.issuer}
`) 
    )
  })
  .catch((err) => {
    // Handle errors, such as invalid URLs or SSL issues
    console.error(err); 
  }) 
```

## Get System Load Average

// Name: Get System Load
// Description: Displays the system load average using the 'os' module
// Author: johnlindquist

```typescript 
import "@johnlindquist/kit"
import os from "os"

// Get the system load average
const loadavg = os.loadavg()

// Display the load average
await div(md(`## System Load Average:

* 1 minute: ${loadavg[0]} 
* 5 minutes: ${loadavg[1]} 
* 15 minutes: ${loadavg[2]}
`
  )
)
```

## Generate TypeScript Interface from Object

// Name: Generate TypeScript Interface
// Description: Generates a TypeScript interface from a JavaScript object
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"

// Prompt for JavaScript object input 
const jsonObject = await editor({ placeholder: "Enter JavaScript Object:", language: "javascript" })

// Parse the input into a JavaScript object
const parsedObject = JSON.parse(jsonObject) 

// Function to generate the TypeScript interface 
function generateInterface(obj: any, interfaceName = "MyInterface"): string {
  const properties = Object.entries(obj).map(([key, value]) => {
    const type = typeof value === "string"
      ? "string"
      : typeof value === "number" 
      ? "number" 
      : typeof value === "boolean" 
      ? "boolean" 
      : "any"

    return `  ${key}: ${type};` 
  }).join("\n")

  return `interface ${interfaceName} {
${properties}
}` 
}

// Generate the interface 
const typescriptInterface = generateInterface(parsedObject)

// Display the interface in the editor 
await editor({
  value: typescriptInterface,
  language: "typescript",
})
```

## Get Time Zone Information

// Name: Get Time Zone Info
// Description: Displays information about the current time zone
// Author: johnlindquist 

```typescript
import "@johnlindquist/kit"

// Get the current time zone
const timeZone = Intl.DateTimeFormat().resolvedOptions().timeZone

// Display time zone information in a div
await div(md(`## Time Zone Information:

* **Name:** ${timeZone}
* **Current Time:** ${new Date().toLocaleString("en-US", { timeZone })}
`
  )
)
```

## Get Lyrics and Display in Widget with Karaoke Effect

// Name: Karaoke Lyrics
// Description: Fetches and displays song lyrics with a karaoke effect
// Author: johnlindquist

```typescript 
import "@johnlindquist/kit"
import { lyricsFinder } from "lyrics-finder"

// Prompt for the song title
const songTitle = await arg("Enter song title:")

// Prompt for the artist name (optional)
const artist = await arg({
  placeholder: "Enter artist name (optional):",
  hint: "Hit enter to skip", 
}) 

// Create a widget to display the lyrics
const lyricsWidget = await widget(`<div id="lyrics" class="p-4 text-center font-bold text-xl" style="line-height: 2;"></div>`, { 
  width: 600,
  height: 400,
  resizable: true,
})

// Function to fetch and display lyrics with a karaoke effect 
async function displayLyrics() {
  try {
    // Fetch lyrics using the 'lyrics-finder' package
    const lyrics = await lyricsFinder(songTitle, artist || undefined) 

    // Split the lyrics into lines 
    const lines = lyrics.split("\n")

    // Highlight each line with a delay 
    let i = 0
    const intervalId = setInterval(() => {
      if (i < lines.length) {
        // Highlight the current line
        const highlightedLyrics = lines
          .map((line, index) => 
            index <= i ? `<span style="color: yellow;">${line}</span>` : line
          )
          .join("\n")

        // Update the widget's content
        lyricsWidget.setState({ html: `<div id="lyrics" class="p-4 text-center font-bold text-xl" style="line-height: 2;">${highlightedLyrics}</div>`}) 
        i++
      } else {
        // Stop the interval when all lines are highlighted 
        clearInterval(intervalId)
      }
    }, 1000) // Adjust delay (in milliseconds) for karaoke effect
  } catch (error) {
    // Handle errors if lyrics are not found 
    await div(md(`# Lyrics not found for ${songTitle} by ${artist || "Unknown"}`)) 
  } 
}

// Start displaying lyrics
await displayLyrics()
```


## Create and Join a Zoom Meeting

// Name: Create Zoom Meeting
// Description: Creates and joins a new Zoom meeting using the Zoom API 
// Author: johnlindquist

```typescript
// Requires a Zoom JWT App. Generate API Key & Secret at https://marketplace.zoom.us/develop/create

import "@johnlindquist/kit" 
import jwt from "jsonwebtoken" 
import { v2 as cloudinary } from "cloudinary"
import axios from "axios"

// Retrieve Zoom API Key and Secret from environment variables
const apiKey = await env("ZOOM_API_KEY")
const apiSecret = await env("ZOOM_API_SECRET")

// Generate a JWT token for Zoom API authentication 
const payload = {
  iss: apiKey,
  exp: Math.floor(Date.now() / 1000) + 60 * 60,
}

const token = jwt.sign(payload, apiSecret) 

// Create a Zoom meeting using the API
const { data: meeting } = await axios.post(
  `https://api.zoom.us/v2/users/me/meetings`,
  {
    topic: "Script Kit Meeting", 
    type: 2, // Scheduled meeting 
    start_time: new Date(Date.now() + 60 * 1000 * 10).toISOString(), // Start in 10 minutes
    duration: 60, // Meeting duration in minutes
    // Optional: Set password for the meeting 
    // password: "password123", 
    settings: {
      join_before_host: true, // Allow participants to join before host 
      mute_upon_entry: false, // Mute participants upon entry 
      // ... other meeting settings
    },
  },
  {
    headers: {
      Authorization: `Bearer ${token}`,
    },
  }
) 

// Open the Zoom meeting join URL 
await open(meeting.join_url)

// Display the meeting information in a div
await div(md(`# Zoom Meeting Created:

* **Topic:** ${meeting.topic}
* **Join URL:** ${meeting.join_url} 
* **Meeting ID:** ${meeting.id} 
* **Password:** ${meeting.password || "None"} 
`))
```

## Check for Spelling Errors in Markdown File

// Name: Check Markdown Spelling
// Description: Checks the spelling of a Markdown file using the 'spellchecker' package
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"
import SpellChecker from "spellchecker"
import { Lexer } from "marked"

// Prompt for Markdown file selection
const filePath = await path({
  startPath: home("Documents"),
})

// Read the Markdown file 
const markdown = await readFile(filePath, "utf-8")

// Extract text content from the Markdown using 'marked'
const lexer = new Lexer()
const tokens = lexer.lex(markdown)
const textTokens = tokens.filter(token => token.type === "text") 
let textContent = textTokens.map(token => token.text).join(" ") 

// Check for misspelled words
const misspelled = SpellChecker.checkSpelling(textContent) 

// Highlight misspelled words in the original Markdown 
for (const { start, end } of misspelled) {
  const word = textContent.substring(start, end)

  // Find the token containing the misspelled word
  const tokenIndex = textTokens.findIndex(token => token.text.includes(word)) 
  const token = textTokens[tokenIndex] 

  // Update the token's text with the highlighted word 
  token.text = token.text.replace(word, `<span class="text-red-500">${word}</span>`)
  textContent = textContent.replace(word, `<span class="text-red-500">${word}</span>`)
  textTokens[tokenIndex] = token 
}

// Reconstruct the Markdown with highlighted words
const updatedMarkdown = tokens.map(token => token.raw).join("")

// Display the Markdown with highlighted typos 
await div({
  html: md(updatedMarkdown),
  width: 800,
  height: 600, 
})
```

## Create a Streamable MP3 Audio File from Text

// Name: Create Streamable MP3 
// Description: Converts text to speech and creates a streamable MP3 file using 'express' and 'gtts'
// Author: johnlindquist

```typescript 
import "@johnlindquist/kit"
import { gTTS } from "gtts" 
import express from "express" 

// Prompt for the text input 
const text = await arg("Enter text:") 

// Create a new text-to-speech instance 
const gtts = new gTTS(text, "en") 

// Create an express app 
const app = express() 
const port = 3000 

// Route to serve the MP3 audio stream
app.get("/stream", (req, res) => {
  // Set the content type header 
  res.set({ "Content-Type": "audio/mpeg" })

  // Pipe the audio stream from gTTS to the response
  gtts.stream().pipe(res) 
})

// Start the server
app.listen(port, () => { 
  console.log(`Server listening on port ${port}`)
}) 

// Open the audio stream URL in the default player 
await open(`http://localhost:${port}/stream`) 

// Display a message indicating the audio is playing
await div(md(`# Playing Audio Stream:`))
```

## Find Large Files

// Name: Find Large Files
// Description: Finds and lists large files in a directory
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"

// Prompt for the directory to search 
const directoryPath = await path({
  startPath: home(), 
  onlyDirs: true, 
})

// Prompt for the minimum file size (in MB)
const minSizeMB = parseFloat(await arg("Enter minimum file size (in MB):"))

// Convert the minimum size to bytes
const minSizeBytes = minSizeMB * 1024 * 1024

// Get the file sizes
const files = await readdir(directoryPath, { withFileTypes: true })

let largeFiles: { name: string; size: number }[] = []
// Iterate through each file in the directory
for (const file of files) { 
  if (file.isFile()) { 
    // Get the file's size 
    const { size } = await stat(path.join(directoryPath, file.name))

    // If the file size is larger than the minimum size
    if (size > minSizeBytes) {
      // Add the file name and size to the list 
      largeFiles.push({ name: file.name, size })
    } 
  }
}

// Sort the files by size in descending order
largeFiles = largeFiles.sort((a, b) => b.size - a.size)

// Display the list of large files with their sizes in a user-friendly format
await div(
  md(`# Large Files in ${directoryPath}:

${
  largeFiles
    .map(({ name, size }) => `* ${name} (${filesize(size)})`) 
    .join("\n")
}`)
)
```

## Get System CPU Usage

// Name: Get CPU Usage
// Description: Displays the current CPU usage using the 'os-utils' package
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"
import osu from "os-utils"

// Get the current CPU usage
const cpuUsage = await new Promise<number>(resolve => {
  osu.cpuUsage(v => resolve(v)) 
})

// Display the CPU usage in a div
await div(md(`## Current CPU Usage:\n\n${(cpuUsage * 100).toFixed(2)}%`)) 
```

## Convert Text to Handwriting and Copy Image to Clipboard

// Name: Text to Handwriting (Clipboard)
// Description: Converts text to a handwritten image and copies it to the clipboard
// Author: johnlindquist

```typescript
// Requires an API key from https://www.handwrite.io/

import "@johnlindquist/kit"
import handwrite from "handwrite" 

// Prompt for text input
const text = await arg("Enter text:")

// Retrieve Handwrite.io API key from the environment
const handwriteApiKey = await env("HANDWRITE_API_KEY") 

// Convert the text to handwriting using the API 
const handwritingImageUrl = await handwrite(text, {
  handwriting_id: handwriteApiKey, 
})

// Download the handwritten image
const imageBuffer = await download(handwritingImageUrl)

// Copy the image to the clipboard 
await clipboard.writeImage(imageBuffer)

await div(md(`Handwritten image copied to clipboard!`))
```

## Create a Screen Recording

// Name: Screen Recording
// Description: Records a portion of the screen using the 'screencapture' command (macOS only)
// Author: johnlindquist

```typescript
import "@johnlindquist/kit"

// Prompt for the screen recording duration in seconds
const duration = await arg({
  placeholder: "Enter recording duration (seconds):", 
  hint: "Default is 10 seconds",
}) 

// Prompt for the output file path
const outputPath = await path({
  startPath: home("Movies"),
})

// Capture a specific area of the screen
// macOS screencapture documentation: https://ss64.com/osx/screencapture.html
await exec(`screencapture -v -t ${parseInt(duration) || 10} -r "${outputPath}"`) 
await div(md(`Screen recording saved to: ${outputPath}`))
```



## Create a Timestamped Note

```typescript
// Name: Timestamped Note
// Description: Creates a new note with a timestamp in the filename
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the current date and time 
const now = new Date()

// Format the date and time as a string
const timestamp = now.toISOString().replace(/:/g, "-").split(".")[0]

// Create the file path with the timestamp
const filePath = `note-${timestamp}.md` 

// Open the newly created note file in the editor 
await editor(filePath)
```

## Resize Images in Bulk

```typescript
// Name: Bulk Image Resizer
// Description: Resize images in a directory to a specified width
// Author: johnlindquist

import "@johnlindquist/kit"
import sharp from "sharp"

// Prompt the user to select a directory
const directory = await path()

// Prompt the user to enter the desired width 
const width = parseInt(await arg("Enter desired width:"))

// Get all image files in the selected directory
const imageFiles = await globby([`${directory}/*.{jpg,jpeg,png,gif,webp}`])

// Resize each image to the specified width
for (const imagePath of imageFiles) {
  // Resize the image using the sharp library, maintaining aspect ratio
  await sharp(imagePath).resize({ width }).toFile(imagePath.replace(/\.(jpg|jpeg|png|gif|webp)$/, `-${width}.$1`)) 
}
```

## Generate a Random Password

```typescript
// Name: Random Password Generator
// Description: Generates a random password with custom length and options
// Author: johnlindquist

import "@johnlindquist/kit"
import generator from "generate-password"

// Prompt the user for the desired password length
const length = parseInt(await arg("Enter password length:")) 

// Generate the random password
const password = generator.generate({
  length,
  numbers: true, 
  symbols: true, 
  uppercase: true, 
  lowercase: true,
})

// Copy the password to the clipboard
await copy(password)

// Display a confirmation message
await div(md(`Password copied to clipboard!`)) 
```

## Get Weather Information for a Location

```typescript
// Name: Weather Report 
// Description: Retrieves and displays weather information for a location
// Author: johnlindquist

import "@johnlindquist/kit"

// You can find your API key here: https://openweathermap.org/api 
const OPENWEATHERMAP_API_KEY = await env("OPENWEATHERMAP_API_KEY")

// Prompt for the location
const location = await arg("Enter location (city, country code):")

// Fetch weather data from OpenWeatherMap API
const response = await get(
  `https://api.openweathermap.org/data/2.5/weather?q=${location}&appid=${OPENWEATHERMAP_API_KEY}&units=metric`
)

// Extract relevant weather information
const { name, main, weather } = response.data
const temperature = main.temp
const description = weather[0].description

// Display weather information in a div
await div(
  md(`## Weather in ${name}

* Temperature: ${temperature}Â°C
* Description: ${description}
`)
) 
```

## Convert Text to Speech

```typescript
// Name: Text to Speech
// Description: Converts text from the clipboard to speech
// Author: johnlindquist

import "@johnlindquist/kit"
import OpenAI from "openai"

// Get your API key from here: https://platform.openai.com/account/api-keys
let openai = new OpenAI({
  apiKey: await env("OPENAI_API_KEY"),
}) 

// Get text from clipboard 
const text = await paste()

// Create speech audio 
let mp3 = await openai.audio.speech.create({
  model: "tts-1",
  voice: "alloy",
  input: text, 
})

// Save the audio to a file
let fileName = `speech-${Date.now()}.mp3`
let speechFile = tmpPath(fileName)

// Play the audio file
await writeFile(speechFile, Buffer.from(await mp3.arrayBuffer()))
await playAudioFile(speechFile)
```

## Create a Task List

```typescript
// Name: Task List
// Description: Creates a task list in a Markdown file
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user for the file name
const fileName = await arg("Enter file name:") 

// Create the file if it doesn't exist 
await ensureFile(fileName)

// Open the file in the editor 
await editor({
  value: `# Tasks\n\n- [ ] `,
  language: "markdown", 
  file: fileName, 
})
```

## Translate Text

```typescript
// Name: Text Translator
// Description: Translates text from one language to another
// Author: johnlindquist

import "@johnlindquist/kit" 
import translate from "@vitalets/google-translate-api"

// Get text to translate
let text = await arg({
  placeholder: "Enter text to translate:",
})

// Prompt for target language
let targetLanguage = await arg("Enter target language code (e.g., 'es' for Spanish):") 

// Translate the text using the google-translate-api
const { text: translatedText } = await translate(text, { to: targetLanguage })

// Display the translated text
await div(md(`# Translated Text:\n\n${translatedText}`)) 
```

## Generate QR Code

```typescript
// Name: QR Code Generator
// Description: Generates a QR code for a given URL or text
// Author: johnlindquist

import "@johnlindquist/kit" 
import qrcode from "qrcode" 

// Prompt the user for the data to encode
const data = await arg("Enter URL or text to encode:") 

// Generate the QR code as a data URL
const qrCodeDataURL = await qrcode.toDataURL(data) 

// Display the QR code in a div
await div(`<img src="${qrCodeDataURL}" alt="QR Code" />`)
```

## Get System Information

```typescript
// Name: System Info
// Description: Displays system information
// Author: johnlindquist

import "@johnlindquist/kit"
import si from "systeminformation" 

// Get system information using the systeminformation library
const systemInfo = await si.osInfo() 

// Extract relevant system information
const { platform, distro, release, codename, arch, hostname, build } = systemInfo

// Display system information in a div
await div(md(`
## System Information 

* Platform: ${platform}
* Distro: ${distro} 
* Release: ${release}
* Codename: ${codename} 
* Architecture: ${arch}
* Hostname: ${hostname}
* Build: ${build} 
`))
```

## Check Website Status

```typescript
// Name: Website Status Checker
// Description: Checks the status of a website 
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the website URL
const url = await arg("Enter website URL:")

// Check the website status
const { status } = await fetch(url).catch(error => ({ status: "error" }))

// Display the website status
await div(md(`# Website Status: ${status}`))
```
## Convert Markdown to HTML

```typescript
// Name: Markdown to HTML Converter
// Description: Converts Markdown from the clipboard to HTML and copies it back to the clipboard 
// Author: johnlindquist

import "@johnlindquist/kit"
import TurndownService from "turndown"

// Create a new instance of the TurndownService
const turndownService = new TurndownService()

// Get Markdown from clipboard
const markdown = await paste()

// Convert the Markdown to HTML using turndown
const html = turndownService.turndown(markdown)

// Copy the HTML to the clipboard
await copy(html)

// Display a confirmation message
await div(md(`## Markdown converted to HTML and copied to the clipboard!`)) 
```

## Find and Replace in Files

```typescript
// Name: Find and Replace in Files
// Description: Finds and replaces text in files within a directory
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user to select a directory 
const directoryPath = await path()

// Prompt for the search term 
const searchTerm = await arg("Enter the search term:") 

// Prompt for the replacement text 
const replacementText = await arg("Enter the replacement text:") 

// Find and replace text in files using ripgrep and sed, asking for confirmation before each replacement 
await exec(`rg '${searchTerm}' -l ${directoryPath} | xargs -I {} sh -c 'echo "Replace in {}? [y/n]" && read answer && if [ "$answer" = "y" ]; then sed -i "s/${searchTerm}/${replacementText}/g" {}; fi'`, { shell: true })
```

## Create a New Git Branch

```typescript
// Name: Create Git Branch
// Description: Creates a new Git branch and switches to it 
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the new branch name
const branchName = await arg("Enter new branch name:")

// Create the new branch and switch to it
await $`git checkout -b ${branchName}` 

// Display a confirmation message
await div(md(`## Switched to branch: ${branchName}`)) 
```

## Generate a Project README

```typescript
// Name: Generate README
// Description: Generates a README.md file for the current project
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the project title 
const projectTitle = await arg("Enter project title:") 

// Prompt for a short project description
const projectDescription = await arg("Enter project description:") 

// Create the README content 
const readmeContent = `# ${projectTitle}\n\n${projectDescription}`

// Write the content to README.md 
await writeFile("README.md", readmeContent) 

// Display a confirmation message
await div(md(`## README.md generated!`))
```

## Clean Up Temporary Files

```typescript
// Name: Clean Up Temp Files 
// Description: Removes temporary files and directories from the system
// Author: johnlindquist

import "@johnlindquist/kit" 

// Define paths to temporary directories 
const tempPaths = [
  tempdir(), 
  kenvPath("tmp"), 
]

// Remove temporary files and directories
for (const tempPath of tempPaths) {
  await trash([`${tempPath}/*`], { glob: true }) 
}

// Display a confirmation message
await div(md(`## Temporary files cleaned up!`))
```

## Send a Message to Slack

```typescript
// Name: Send Slack Message
// Description: Sends a message to a Slack channel
// Author: johnlindquist

import "@johnlindquist/kit"
import { WebClient } from "@slack/web-api"

// Get your Slack API token from here: https://api.slack.com/apps 
const slackToken = await env("SLACK_API_TOKEN") 

// Prompt for the Slack channel 
const channel = await arg("Enter Slack channel:") 

// Prompt for the message
const message = await arg("Enter message:") 

// Create a new instance of the Slack WebClient 
const slackClient = new WebClient(slackToken) 

// Send the message to the Slack channel
await slackClient.chat.postMessage({ channel, text: message })

// Display a confirmation message 
await div(md(`## Message sent to Slack!`))
```

## Convert Image to Base64

```typescript
// Name: Convert Image to Base64
// Description: Converts an image to Base64 and copies it to the clipboard
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user to select an image file 
const imagePath = await path() 

// Read the image file as a buffer
const imageBuffer = await readFile(imagePath) 

// Convert the image buffer to a Base64 string
const base64String = imageBuffer.toString("base64") 

// Copy the Base64 string to the clipboard 
await copy(base64String) 

// Display a confirmation message 
await div(md(`## Image converted to Base64 and copied to the clipboard!`))
```


## Create GitHub Issue from Selection

```typescript
// Name: Create GitHub Issue from Selection
// Description: Creates a new GitHub issue from selected text
// Author: johnlindquist

import "@johnlindquist/kit"
import { Octokit } from "@octokit/rest"

// Get the selected text
const selectedText = await getSelectedText()

// Get GitHub authentication token from environment variables
// You can get a token from here: https://github.com/settings/tokens
const githubToken = await env("GITHUB_TOKEN")

// Prompt for the repo owner and name (e.g., "johnlindquist/kit")
const repo = await arg("Enter repo owner/name:")

// Split the repo input into owner and name 
const [owner, name] = repo.split("/") 

// Create a new Octokit instance
const octokit = new Octokit({
  auth: githubToken,
})

// Create a new GitHub issue
const { data: newIssue } = await octokit.issues.create({
  owner, 
  repo: name,
  title: await arg("Enter issue title:"), // Prompt for the issue title
  body: selectedText,                     // Use the selected text as the issue body 
})

// Open the created issue in the browser
await browse(newIssue.html_url) 
```

## Convert CSV to JSON

```typescript
// Name: CSV to JSON Converter
// Description: Converts CSV data from the clipboard to JSON and copies it back to the clipboard 
// Author: johnlindquist

import "@johnlindquist/kit"
import { parse } from "papaparse"

// Get CSV data from the clipboard
const csvData = await paste() 

// Parse the CSV data using papaparse 
const { data: jsonData } = parse(csvData, {
  header: true, // Use the first row as headers
  dynamicTyping: true, // Convert numeric values to numbers
}) 

// Convert the JSON data to a string
const jsonString = JSON.stringify(jsonData, null, 2) 

// Copy the JSON string to the clipboard 
await copy(jsonString) 

// Display a confirmation message
await div(md(`## CSV data converted to JSON and copied to the clipboard!`)) 
```

## Download File with Progress

```typescript
// Name: File Downloader with Progress
// Description: Downloads a file from a URL and shows progress
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the file URL
const url = await arg("Enter file URL:") 

// Prompt for the download location 
const downloadPath = await path({
  onlyDirs: true,
})

// Create a div to display download progress
const progressDiv = await div(md(`## Downloading...`))

// Download the file with progress updates
await download(url, downloadPath, {
  onDownloadProgress: ({ percent, transferred, total }) => {
    // Update the progress div with a progress bar and percentage
    progressDiv.setState({
      html: md(`## Downloading...
      
      \`${transferred}\` of \`${total}\`      
      
      ${(percent * 100).toFixed(2)}%
      
      `), 
    })
  }, 
})

// Update the div to indicate completion
progressDiv.setState({
  html: md(`## Download complete!`), 
})

// Reveal the downloaded file in Finder
await revealFile(downloadPath)
```

## Create and Send Email

```typescript
// Name: Send Email 
// Description: Sends an email using the Nodemailer library
// Author: johnlindquist 

import "@johnlindquist/kit"
import nodemailer from "nodemailer" 

// Get email credentials from environment variables 
// You can create an app password here: https://support.google.com/accounts/answer/185833?hl=en
const emailUser = await env("EMAIL_USER") 
const emailPassword = await env("EMAIL_PASSWORD")

// Create a Nodemailer transporter
const transporter = nodemailer.createTransport({
  service: "gmail",
  auth: {
    user: emailUser, 
    pass: emailPassword,
  },
}) 

// Prompt for recipient email address
const to = await arg("Enter recipient email address:")

// Prompt for the email subject
const subject = await arg("Enter email subject:")

// Prompt for the email body 
const body = await textarea({
  placeholder: "Enter email body:",
}) 

// Define email options 
const mailOptions = {
  from: emailUser,
  to,
  subject, 
  html: body,
} 

// Send the email 
await transporter.sendMail(mailOptions)

// Display a confirmation message
await div(md(`## Email sent successfully!`))
```

## Generate Project Documentation

```typescript
// Name: Generate Docs
// Description: Generates documentation for a TypeScript project using TypeDoc
// Author: johnlindquist

import "@johnlindquist/kit" 

// Generate documentation using TypeDoc
await exec(`npx typedoc --out docs src`, {
  // Set the current working directory to the project root
  cwd: ".",
})

// Display a confirmation message
await div(md(`## Documentation generated in the 'docs' directory!`))
```

## Run Tests with Jest

```typescript
// Name: Run Tests (Jest) 
// Description: Runs tests for a project using Jest
// Author: johnlindquist

import "@johnlindquist/kit" 

// Run Jest tests in watch mode
await term({
  command: "npx jest --watch", // Run Jest in watch mode
  cwd: ".",
})
```

## Convert Text to Uppercase

```typescript
// Name: Uppercase Text
// Description: Converts selected text to uppercase 
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the selected text
const text = await getSelectedText()

// Convert the text to uppercase
const uppercaseText = text.toUpperCase()

// Replace the selected text with the uppercase text
await setSelectedText(uppercaseText) 
```
## Create ZIP Archive

```typescript
// Name: Create ZIP Archive
// Description: Creates a ZIP archive of a selected directory
// Author: johnlindquist

import "@johnlindquist/kit"
import archiver from "archiver"

// Prompt the user to select a directory
const directoryPath = await path()

// Create the output file path for the ZIP archive
const outputFilePath = `${directoryPath}.zip`

// Create a write stream for the output file 
const output = createWriteStream(outputFilePath)

// Create a new archiver instance
const archive = archiver("zip", {
  zlib: { level: 9 }, // Set compression level
})

// Listen for errors during archiving
archive.on("error", (error) => {
  throw error
})

// Finalize the archive when done
output.on("close", () => {
  console.log(`Archive created at: ${outputFilePath}`)
})

// Pipe the archive data to the output stream
archive.pipe(output)

// Add the selected directory to the archive
archive.directory(directoryPath, false)

// Finalize the archive
await archive.finalize() 
```

## Resize Image with Preview

```typescript
// Name: Resize Image with Preview
// Description: Resizes an image with a live preview
// Author: johnlindquist

import "@johnlindquist/kit" 
import sharp from "sharp"

// Prompt the user to select an image
const imagePath = await path({
  // Filter choices to only include image files
  filters: [
    { name: "Images", extensions: ["jpg", "jpeg", "png", "gif", "webp"] },
  ], 
})

// Prompt for the new image width
let newWidth: number = await arg(
  {
    placeholder: `Enter new width:`,
    hint: `Original image width is ${(await sharp(imagePath).metadata()).width}`, 
  },
  // Display common image widths as choices 
  [
    { name: "1920", value: 1920 },
    { name: "1024", value: 1024 },
    { name: "800", value: 800 },
    { name: "640", value: 640 },
    { name: "320", value: 320 },
    { name: "160", value: 160 }, 
  ]
)

// Function to generate the preview image
const generatePreview = async (width: number) => {
  // Create a temporary file path for the preview image 
  const previewImagePath = tmpPath(`preview-${width}.jpg`) 
  // Resize the image to the specified width and save it to the temporary path
  await sharp(imagePath).resize({ width }).toFile(previewImagePath) 
  // Return the preview image path 
  return previewImagePath 
}

// Display the preview image 
setPreview(md(`![Preview Image](${await generatePreview(newWidth)})`)) 

// Prompt the user for confirmation
let shouldResize = await arg("Resize?", ["Yes", "No"]) 

if (shouldResize === "Yes") { 
  // Resize the original image
  await sharp(imagePath).resize({ width: newWidth }).toFile(imagePath) 
  // Display a notification 
  await notify("Image resized successfully!", `${imagePath}`) 
}
```

## Get System Uptime

```typescript
// Name: Get System Uptime
// Description: Displays the system uptime
// Author: johnlindquist

import "@johnlindquist/kit"
import os from "os"

// Get system uptime in seconds
const uptimeInSeconds = os.uptime() 

// Convert uptime to days, hours, minutes, and seconds 
const uptimeDays = Math.floor(uptimeInSeconds / (60 * 60 * 24)); 
const uptimeHours = Math.floor((uptimeInSeconds % (60 * 60 * 24)) / (60 * 60)); 
const uptimeMinutes = Math.floor((uptimeInSeconds % (60 * 60)) / 60); 
const uptimeSeconds = Math.floor(uptimeInSeconds % 60); 

// Create the uptime string
const uptimeString = `System uptime: ${uptimeDays} days, ${uptimeHours} hours, ${uptimeMinutes} minutes, ${uptimeSeconds} seconds`

// Display the uptime in a div
await div(md(`## ${uptimeString}`)) 
```

## List Running Processes

```typescript
// Name: List Running Processes
// Description: Displays a list of running processes
// Author: johnlindquist

import "@johnlindquist/kit"

// Get a list of running processes
const processes = await getProcesses() 

// Prompt the user to select a process
const selectedProcess = await arg( 
  {
    placeholder: "Select a process:",
    // Use a custom width for the prompt
    width: PROMPT.WIDTH.LG, 
  }, 
  processes.map((process) => ({
    name: process.name,
    value: process,
    description: `PID: ${process.pid}`,
  }))
)

// Display information about the selected process in a div
await div(
  md(`## Process Information:

* Name: ${selectedProcess.name} 
* PID: ${selectedProcess.pid} 
* Path: ${selectedProcess.scriptPath}
* Created: ${new Date(selectedProcess.date).toLocaleString()}
`) 
)
```

## Convert Text to Title Case

```typescript
// Name: Title Case Converter
// Description: Converts selected text to title case
// Author: johnlindquist

import "@johnlindquist/kit"
import { titleCase } from "title-case"

// Get the selected text
const text = await getSelectedText()

// Convert the text to title case
const titleCaseText = titleCase(text) 

// Set the selected text to the title-cased text
await setSelectedText(titleCaseText) 
```

## Check for File Duplicates

```typescript
// Name: Duplicate File Finder
// Description: Finds duplicate files in a directory
// Author: johnlindquist

import "@johnlindquist/kit"
import { createHash } from "crypto"

// Prompt the user to select a directory
const directoryPath = await path({
  onlyDirs: true, // Only allow selecting directories
})

// Function to calculate the SHA-256 hash of a file
async function calculateFileHash(filePath: string) {
  const fileBuffer = await readFile(filePath) 
  const hashSum = createHash("sha256")
  hashSum.update(fileBuffer) 
  return hashSum.digest("hex") 
}

// Get all files in the directory
const filePaths = await globby([`${directoryPath}/**/*`], { onlyFiles: true })

// Create a map to store file hashes and their corresponding file paths
const fileHashMap = new Map<string, string[]>() 

// Calculate hashes for each file and store them in the map 
for (const filePath of filePaths) {
  const fileHash = await calculateFileHash(filePath)
  if (fileHashMap.has(fileHash)) {
    fileHashMap.get(fileHash).push(filePath) 
  } else {
    fileHashMap.set(fileHash, [filePath]) 
  }
}

// Find entries with more than one file path (indicating duplicates)
const duplicateFiles = Array.from(fileHashMap.entries()).filter(([, paths]) => paths.length > 1) 

if (duplicateFiles.length > 0) {
  // Display duplicate files in a div
  let html = `
  <h1>Duplicate Files:</h1>
  <ul> 
  ${duplicateFiles.map(([hash, paths]) => `
    <li> 
      <h2>Hash: ${hash}</h2>
      <ul> 
      ${paths.map(path => `<li>${path}</li>`).join("")}
      </ul>
    </li>
  `).join("")}
  </ul>
  `

  await div(html)
} else {
  // Display a message if no duplicates are found
  await div(md(`# No duplicate files found.`)) 
}
```

## Create Event on Google Calendar

```typescript
// Name: Create Google Calendar Event 
// Description: Creates a new event on Google Calendar
// Author: johnlindquist

import "@johnlindquist/kit"
import { google } from "googleapis" 
import { JWT } from "google-auth-library" 

// Get Google Service Account credentials from environment variables
// You can create service account credentials here: https://console.cloud.google.com/apis/credentials 
const serviceAccountEmail = await env("GOOGLE_SERVICE_ACCOUNT_EMAIL") 
const serviceAccountKey = await env("GOOGLE_SERVICE_ACCOUNT_KEY")

// Create a JWT client using the service account credentials
const jwtClient = new JWT({
  email: serviceAccountEmail,
  key: serviceAccountKey,
  scopes: ["https://www.googleapis.com/auth/calendar"],
}) 

// Create a Google Calendar instance
const calendar = google.calendar("v3")

// Prompt for event details 
const eventSummary = await arg("Enter event summary:") 
const eventStartTime = await arg(
  {
    placeholder: "Enter event start time (YYYY-MM-DDTHH:mm:ss):",
    hint: "Example: 2024-03-15T10:00:00", 
  } 
)
const eventEndTime = await arg(
  {
    placeholder: "Enter event end time (YYYY-MM-DDTHH:mm:ss):", 
    hint: "Example: 2024-03-15T11:00:00",
  }
) 

// Create a new calendar event 
calendar.events.insert( 
  {
    auth: jwtClient, 
    calendarId: "primary",
    requestBody: {
      summary: eventSummary,
      start: { dateTime: eventStartTime }, 
      end: { dateTime: eventEndTime }, 
    },
  },
  (err, event) => {
    if (err) {
      console.error("There was an error contacting the Calendar service:", err) 
      return
    }
    console.log("Event created:", event.data.htmlLink)
  } 
) 

// Display a confirmation message
await div(md(`## Google Calendar event created!`))
```
## Get Stock Quotes

```typescript
// Name: Stock Quote Fetcher
// Description: Retrieves and displays stock quotes for a given symbol
// Author: johnlindquist

import "@johnlindquist/kit"

// You can get a free API key from https://www.alphavantage.co/support/#api-key
const ALPHAVANTAGE_API_KEY = await env("ALPHAVANTAGE_API_KEY") 

// Prompt for the stock symbol
const stockSymbol = await arg("Enter stock symbol:") 

// Construct the API URL
const apiUrl = `https://www.alphavantage.co/query?function=GLOBAL_QUOTE&symbol=${stockSymbol}&apikey=${ALPHAVANTAGE_API_KEY}` 

// Fetch the stock quote data
const response = await get(apiUrl)

// Extract the quote information
const quote = response.data["Global Quote"]

// Display the stock quote in a div
await div(
  md(`
## Stock Quote for ${quote["01. symbol"]}:

* Price: ${quote["05. price"]}
* Change: ${quote["09. change"]} (${quote["10. change percent"]}) 
* High: ${quote["03. high"]}
* Low: ${quote["04. low"]}
* Volume: ${quote["06. volume"]}
  `)
)
```

## Check for Broken Links

```typescript
// Name: Broken Link Checker
// Description: Checks for broken links in a Markdown file 
// Author: johnlindquist

import "@johnlindquist/kit"
import { isAbsolute, resolve } from "path"

// Function to check if a link is broken
async function isLinkBroken(url: string): Promise<boolean> {
  try {
    const response = await fetch(url, { method: "HEAD" })
    return !response.ok
  } catch (error) { 
    return true // If there's an error, assume the link is broken
  }
}

// Prompt the user to select a Markdown file
const filePath = await path({
  filters: [
    { name: "Markdown Files", extensions: ["md", "markdown", "mdown", "mkdn"] },
  ], 
})

// Read the contents of the Markdown file
const content = await readFile(filePath, "utf-8")

// Find all Markdown links in the file content
const links = content.match(/\[(.*?)\]\((.*?)\)/g)

const brokenLinks: string[] = []
// Check if any of the links are broken
for (const link of links) {
  let [text, url] = link
    .replace(/\[(.*?)\]\((.*?)\)/, "$1,$2")
    .split(",")

  // If the URL is relative, resolve it to an absolute path
  if (!isAbsolute(url)) { 
    url = resolve(path.dirname(filePath), url)
  } 

  if (await isLinkBroken(url)) {
    brokenLinks.push(link)
  } 
}

if (brokenLinks.length > 0) {
  // Display the broken links to the user 
  await div(md(`
  ## Broken Links: 

  ${brokenLinks.map(link => `- ${link}`).join("\n")}
  `)) 
} else {
  // Display a message if no broken links are found
  await div(md(`## No broken links found! ðŸŽ‰`)) 
} 
```

## Shorten a URL

```typescript
// Name: Shorten URL
// Description: Shortens a URL from the clipboard using the Bitly API 
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the Bitly API token from the environment variables 
// You can create a token here: https://app.bitly.com/settings/api/
const BITLY_ACCESS_TOKEN = await env("BITLY_ACCESS_TOKEN") 

// Get the URL from the clipboard 
const longUrl = await paste()

// Shorten the URL using the Bitly API 
const response = await post( 
  "https://api-ssl.bitly.com/v4/shorten", 
  { long_url: longUrl },
  { headers: { Authorization: `Bearer ${BITLY_ACCESS_TOKEN}` } }
)

// Extract the shortened URL 
const { link: shortUrl } = response.data

// Display the shortened URL 
await div(md(`## Shortened URL:\n\n${shortUrl}`))

// Copy the shortened URL to the clipboard
await copy(shortUrl) 
```

## Send Tweet

```typescript
// Name: Send Tweet
// Description: Sends a tweet using the Twitter API 
// Author: johnlindquist

import "@johnlindquist/kit" 
import TwitterApi from "twitter-api-v2"

// Retrieve Twitter API credentials from environment variables 
// You can create API keys and tokens here: https://developer.twitter.com/en/portal/dashboard
const TWITTER_API_KEY = await env("TWITTER_API_KEY")
const TWITTER_API_SECRET = await env("TWITTER_API_SECRET")
const TWITTER_ACCESS_TOKEN = await env("TWITTER_ACCESS_TOKEN")
const TWITTER_ACCESS_SECRET = await env("TWITTER_ACCESS_SECRET")

// Create a new instance of the Twitter API client
const twitterClient = new TwitterApi({
  appKey: TWITTER_API_KEY,
  appSecret: TWITTER_API_SECRET,
  accessToken: TWITTER_ACCESS_TOKEN,
  accessSecret: TWITTER_ACCESS_SECRET, 
})

// Authenticate with the Twitter API
const client = await twitterClient.readWrite

// Prompt for the tweet content 
const tweetContent = await arg({
  placeholder: "Enter your tweet:", 
  // Allow multiline input for the tweet
  inputHeight: 100, 
}) 

// Send the tweet 
await client.v2.tweet(tweetContent)

// Display a confirmation message
await div(md(`## Tweet sent successfully!`)) 
```

## Get Random Advice

```typescript
// Name: Get Advice
// Description: Displays a random piece of advice 
// Author: johnlindquist

import "@johnlindquist/kit" 

// Fetch a random piece of advice from the Advice Slip API
const response = await get("https://api.adviceslip.com/advice")

// Extract the advice from the response
const { slip } = response.data

// Display the advice in a div
await div(md(`## Advice:\n\n${slip.advice}`))
```

## Get Current Location's Timezone

```typescript
// Name: Get Timezone
// Description: Displays the timezone of the user's current location 
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the user's current location using the browser's geolocation API
const { coords } = await new Promise<GeolocationPosition>((resolve, reject) => {
  navigator.geolocation.getCurrentPosition(resolve, reject)
})

// Fetch timezone information from the Google Time Zone API
const response = await get( 
  `https://maps.googleapis.com/maps/api/timezone/json?location=${coords.latitude},${coords.longitude}&timestamp=${Date.now() / 1000}&key=${await env(
    "GOOGLE_MAPS_API_KEY"
  )}`
) 
// You can get a Google Maps API key here: https://developers.google.com/maps/documentation/javascript/get-api-key

// Extract the timezone name from the response 
const { timeZoneId: timezone } = response.data 

// Display the timezone in a div
await div(md(`## Your Timezone: ${timezone}`))
```

## Create New Project Directory

```typescript
// Name: Create Project Directory
// Description: Creates a new project directory and initializes it as a Git repository
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the project name
const projectName = await arg("Enter project name:") 

// Create the project directory path 
const projectPath = home("dev", projectName)

// Create the directory
await mkdir(projectPath)

// Initialize the directory as a Git repository
await git.init(projectPath)

// Create a README.md file in the project directory
await writeFile(path.join(projectPath, "README.md"), `# ${projectName}`) 

// Open the project directory in VS Code 
await exec(`code ${projectPath}`) 
```
## Convert YouTube Video to GIF

```typescript
// Name: YouTube to GIF Converter
// Description: Converts a YouTube video to a GIF
// Author: johnlindquist

import "@johnlindquist/kit" 
import { pathToFileURL } from "url"

// Prompt for the YouTube video URL
const youtubeUrl = await arg("Enter YouTube Video URL:") 

// Prompt the user for the start and end times of the GIF segment
const startTime = await arg("Enter start time (seconds):") 
const endTime = await arg("Enter end time (seconds):")

// Create a temporary directory for the downloaded video and GIF
const tempDir = await tmpPath()
await ensureDir(tempDir)

// Download the YouTube video using youtube-dl, saving it to the temporary directory
await exec(`youtube-dl -f bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best -o '${tempDir}/%(title)s.%(ext)s' ${youtubeUrl}`, { shell: true }) 

// Find the downloaded video file in the temporary directory
const videoFile = (await globby(`${tempDir}/*.mp4`))[0] 

// Generate the GIF using ffmpeg, specifying the start and end times
await exec(`ffmpeg -y -ss ${startTime} -to ${endTime} -i '${videoFile}' -vf "fps=10,scale=480:-1:flags=lanczos,split[s0][s1];[s0]palettegen[p];[s1][p]paletteuse" -loop 0 '${tempDir}/output.gif'`, { shell: true })

// Prompt the user for the output file path 
const outputFilePath = await path({
  startPath: home("Downloads"),
})

// Move the generated GIF from the temporary directory to the chosen output path 
await mv(`${tempDir}/output.gif`, outputFilePath) 

// Reveal the GIF in Finder 
await revealFile(outputFilePath)
```

## Merge PDF Files

```typescript
// Name: Merge PDF Files
// Description: Merges multiple PDF files into one
// Author: johnlindquist

import "@johnlindquist/kit"
import PDFMerge from "pdf-merge" 

// Prompt the user to select multiple PDF files 
let selectedFilePaths = await getSelectedFile()
// If no files are selected, prompt the user to drop files 
if (!selectedFilePaths) {
  selectedFilePaths = await drop({
    placeholder: "Drop PDF files here...",
    multiple: true,
  })
  // Extract file paths from the dropped files 
  selectedFilePaths = selectedFilePaths.map(file => file.path)
} else {
  // Split the selected file paths into an array 
  selectedFilePaths = selectedFilePaths.split("\n")
}

// Prompt the user for the output file path 
const outputFilePath = await path({
  startPath: home("Downloads"),
})

// Merge the PDFs using the pdf-merge library
await PDFMerge(selectedFilePaths, { output: outputFilePath }).then(buffer => {
  console.log("PDFs merged successfully!") 
}) 

// Reveal the merged PDF in Finder 
await revealFile(outputFilePath)
```

## Get Lyrics for a Song

```typescript
// Name: Get Song Lyrics
// Description: Retrieves and displays lyrics for a song 
// Author: johnlindquist

import "@johnlindquist/kit"
import lyricsFinder from "lyrics-finder" 

// Prompt for the artist and song title 
const artist = await arg("Enter artist name:")
const songTitle = await arg("Enter song title:")

// Fetch lyrics using lyrics-finder 
const lyrics = await lyricsFinder(artist, songTitle).catch(() => "Lyrics not found.")

// Display the lyrics in the editor
await editor(lyrics, {
  language: "text",
  scrollTo: "top",
})
```

## Generate Random Quote

```typescript
// Name: Random Quote
// Description: Displays a random quote
// Author: johnlindquist

import "@johnlindquist/kit" 

// Fetch a random quote from the quotable API 
const response = await get("https://api.quotable.io/random") 

// Extract the quote and author from the response
const { content, author } = response.data

// Display the quote and author in a div
await div(md(`## ${content}\n\nâ€” ${author}`)) 
```

## Check for Available Updates

```typescript
// Name: Check for Updates 
// Description: Checks for updates for npm packages in the current project
// Author: johnlindquist

import "@johnlindquist/kit" 

// Check for outdated packages using npm outdated
let { stdout: outdatedPackages } = await exec("npm outdated --long", {
  cwd: ".", // Run the command in the current directory 
})

if (outdatedPackages) {
  // Display outdated packages in the editor 
  await editor(outdatedPackages, {
    language: "text",
    scrollTo: "top",
  }) 
} else {
  // Display a message if all packages are up to date 
  await div(md(`## All packages are up to date! ðŸŽ‰`))
}
```

## Create New GitHub Repository

```typescript
// Name: Create GitHub Repository
// Description: Creates a new GitHub repository
// Author: johnlindquist

import "@johnlindquist/kit"
import { Octokit } from "@octokit/rest"

// Get GitHub authentication token from environment variables
// You can get a token from here: https://github.com/settings/tokens 
const githubToken = await env("GITHUB_TOKEN")

// Create a new Octokit instance
const octokit = new Octokit({
  auth: githubToken,
}) 

// Prompt for the repository name
const repoName = await arg("Enter repository name:") 

// Prompt for the repository description
const repoDescription = await arg("Enter repository description:") 

// Create the new repository
const { data: newRepo } = await octokit.repos.createForAuthenticatedUser({
  name: repoName,
  description: repoDescription,
  private: false,
}) 

// Display a confirmation message with the repository URL
await div(md(`## Repository created at: ${newRepo.html_url}`)) 

// Open the repository in the browser
await browse(newRepo.html_url) 
```

## Generate Color Palette from Image

```typescript
// Name: Generate Color Palette
// Description: Generates a color palette from an image
// Author: johnlindquist

import "@johnlindquist/kit" 
import { Vibrant } from "node-vibrant" 

// Prompt the user to select an image
const imagePath = await path({
  // Filter choices to only include image files
  filters: [
    { name: "Images", extensions: ["jpg", "jpeg", "png", "gif", "webp"] },
  ],
}) 

// Extract the dominant color palette from the image using Vibrant
const palette = await Vibrant.from(imagePath).getPalette() 

// Create an array of color swatches 
const swatches = Object.values(palette).map(
  swatch => `<div style="background-color: ${swatch.getHex()}; width: 32px; height: 32px;"></div>`
)

// Display the color swatches in a div
await div(
  `<div class="flex flex-row gap-2 p-4"> 
  ${swatches.join("")}
  </div>`
)
```

## Check Website Responsiveness 

```typescript
// Name: Check Website Responsiveness
// Description: Checks a website's responsiveness across different screen sizes
// Author: johnlindquist

import "@johnlindquist/kit"
import puppeteer from "puppeteer"

// Prompt the user to enter the website URL 
const url = await arg("Enter website URL:")

// Define the screen sizes to test 
const screenSizes = [
  { width: 320, height: 480 },
  { width: 768, height: 1024 },
  { width: 1280, height: 720 }, 
  { width: 1920, height: 1080 }, 
]

// Create a div to display a message during the test
const divP = await div(md(`# Checking website responsiveness...`)) 

// Launch a headless browser instance using Puppeteer 
const browser = await puppeteer.launch({ headless: "new" }) 

try { 
  // Iterate through each screen size
  for (const { width, height } of screenSizes) {
    // Create a new page in the browser 
    const page = await browser.newPage() 
    // Set the viewport size 
    await page.setViewport({ width, height }) 
    // Navigate to the provided URL
    await page.goto(url)
    // Capture a screenshot of the page at the current screen size 
    await page.screenshot({ path: tmpPath(`screenshot-${width}x${height}.png`) }) 
  }

  // Display a success message and ask the user if they want to review the screenshots 
  let shouldReview = await div(md(`# Responsiveness check complete!

  Review screenshots?
  `),"flex flex-col gap-2 justify-center items-center text-center") 

  if (shouldReview === "Yes") { 
    // Open the temporary directory containing the screenshots in Finder
    await revealFile(tmpPath())
  }
} finally {
  // Close the browser instance
  await browser.close()
} 
```

## Generate TypeScript Types from JSON

```typescript
// Name: Generate TypeScript Types
// Description: Generates TypeScript types from JSON data
// Author: johnlindquist

import "@johnlindquist/kit" 
import { quicktype, InputData, JSONSchemaInput, FetchingJSONSchemaStore } from "quicktype"

// Prompt the user to select a JSON file
const filePath = await path({
  // Filter choices to only include JSON files
  filters: [{ name: "JSON Files", extensions: ["json"] }],
}) 

// Read the JSON data from the file
const jsonData = await readFile(filePath, "utf-8")

// Configure Quicktype options 
const options: Partial<quicktype.Options> = {
  inputData: new InputData(), // Create a new InputData instance
  lang: "typescript",        // Specify TypeScript as the target language
  rendererOptions: {
    "just-types": "true",    // Generate only type definitions
    "acronym-style": "pascal", // Use PascalCase for acronyms
  }, 
}

// Define the input data for Quicktype as a JSON Schema input 
const jsonInput = new JSONSchemaInput(jsonData)

// Generate TypeScript types using Quicktype, ensuring all necessary await statements are used
await jsonInput.addSource({ name: "data", schema: jsonData }) 

// Fetch the generated TypeScript types from Quicktype
const { lines } = await quicktype({
  ...options, 
  inputData: jsonInput,
})

// Display the generated types in the editor 
await editor(lines.join("\n"), {
  language: "typescript", 
})
```

##  Get Currency Exchange Rates

```typescript
// Name: Currency Converter
// Description: Converts currency from one currency to another
// Author: johnlindquist

import "@johnlindquist/kit"

// Get your API key from here: https://www.exchangerate-api.com/docs/free-plan 
const EXCHANGE_RATE_API_KEY = await env("EXCHANGE_RATE_API_KEY") 

// Prompt the user for the base currency
const baseCurrency = await arg("Enter base currency (e.g., USD):") 

// Prompt for the target currency
const targetCurrency = await arg("Enter target currency (e.g., EUR):") 

// Fetch exchange rates from the API
const response = await get(`https://v6.exchangerate-api.com/v6/${EXCHANGE_RATE_API_KEY}/latest/${baseCurrency}`)

// Extract the exchange rate for the target currency 
const exchangeRate = response.data.conversion_rates[targetCurrency] 

// Prompt for the amount to convert
const amount = parseFloat(await arg("Enter amount:"))

// Calculate the converted amount 
const convertedAmount = amount * exchangeRate

// Display the converted amount
await div(md(`
## ${amount} ${baseCurrency} = ${convertedAmount.toFixed(2)} ${targetCurrency}
`)) 
```

## Get Public IP Address

```typescript
// Name: Get Public IP Address
// Description: Retrieves and displays the user's public IP address
// Author: johnlindquist

import "@johnlindquist/kit" 

// Fetch public IP address from ipify API
const ipAddress = await get("https://api.ipify.org?format=json").then(
  response => response.data.ip
) 

// Display the IP address in a div
await div(md(`## Your public IP address is: ${ipAddress}`))
```

## Generate Random Password with zx

```typescript
// Name: Generate Random Password (zx)
// Description: Generates a strong password using zx and copies it to the clipboard
// Author: johnlindquist

import "@johnlindquist/kit" 

// Generate a random password using openssl and copy it to the clipboard
const password = (await $`openssl rand -base64 32 | tr -dc A-Za-z0-9_!@#$%^&*()_+~\\=\\[\\]\\{\\}\\|\\;\\:\\'\\"\\\,\\.\\<\\>\\/\\?\\\\'`).stdout.trim() 

await copy(password)

// Display a success message 
await div(md(`## Password generated and copied to the clipboard!`)) 
```

## Get System CPU Usage

```typescript
// Name: CPU Monitor 
// Description: Displays the current CPU usage
// Author: johnlindquist 

import "@johnlindquist/kit" 
import si from "systeminformation"

// Create a widget to display CPU usage 
let cpuWidget = await widget(`
<div class="p-4"> 
  <h2 class="text-xl">CPU Usage</h2> 
  <div class="w-full bg-gray-200 rounded-full h-2.5"> 
    <div id="cpu-bar" class="bg-blue-500 h-2.5 rounded-full" style="width: {{cpuLoad}}%"></div>
  </div> 
  <p class="text-sm mt-2">Current Load: {{cpuLoad}}%</p>
</div>
`,{
  // Set a custom width for the widget
  width: 300
}) 

// Update the CPU usage every second
setInterval(async () => { 
  // Get the current CPU load
  const { currentLoad } = await si.currentLoad()

  // Update the widget's state with the current CPU load
  cpuWidget.setState({
    cpuLoad: currentLoad.toFixed(2),
  }) 
}, 1000)
```

## Countdown Timer with Notifications

```typescript
// Name: Countdown Timer with Notifications
// Description: Sets a countdown timer and sends notifications
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt the user to enter the countdown duration in minutes
const durationMinutes = parseFloat(await arg("Enter countdown duration (minutes):")) 

// Calculate the target time in milliseconds
const targetTime = Date.now() + durationMinutes * 60 * 1000 

// Function to send notifications
const sendNotification = (message: string) => {
  notify({
    title: "Countdown Timer", 
    message,
  })
}

// Send an initial notification
sendNotification(`Countdown started for ${durationMinutes} minutes!`)

// Create an interval to check the remaining time every second 
let intervalId = setInterval(() => {
  // Calculate remaining time in milliseconds 
  const timeRemaining = targetTime - Date.now() 

  // Check if the timer has finished 
  if (timeRemaining <= 0) { 
    clearInterval(intervalId)
    sendNotification("Time's up!")
    // Exit the script 
    exit() 
  } else {
    // Calculate remaining minutes and seconds
    const minutes = Math.floor(timeRemaining / (1000 * 60));
    const seconds = Math.floor((timeRemaining % (1000 * 60)) / 1000); 

    // Display remaining time in the console 
    console.log(`Time remaining: ${minutes}:${seconds.toString().padStart(2, "0")}`) 

    // Send notifications at specific intervals
    if (minutes === 5) {
      sendNotification(`5 minutes remaining!`) 
    } else if (minutes === 1) { 
      sendNotification(`1 minute remaining!`) 
    } else if (seconds === 30 && minutes === 0) {
      sendNotification(`30 seconds remaining!`) 
    }
  }
}, 1000)

// Hide the prompt while the timer is running 
hide()
```


## Check npm Package Downloads

```typescript
// Name: Check npm Package Downloads
// Description: Checks the weekly downloads for an npm package
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the package name 
const packageName = await arg("Enter npm package name:")

// Fetch download count from npm API
const response = await get(`https://api.npmjs.org/downloads/point/last-week/${packageName}`)

// Check if the response was successful 
if (response.status === 200) { 
  // Display the download count
  await div(md(`## Weekly downloads for ${packageName}: ${response.data.downloads}`))
} else {
  // Display an error message if the package was not found
  await div(md(`## Package not found: ${packageName}`)) 
}
```

## Convert Text to Markdown

```typescript
// Name: Text to Markdown Converter
// Description: Converts selected text to Markdown and copies it back to the clipboard
// Author: johnlindquist

import "@johnlindquist/kit" 
import { marked } from "marked"
import TurndownService from "turndown" 

// Create a new instance of the TurndownService
const turndownService = new TurndownService() 

// Get the selected text
const text = await getSelectedText()

// Convert the text to Markdown using Turndown
const markdown = turndownService.turndown(text) 

// Copy the Markdown to the clipboard
await copy(markdown) 

// Display a confirmation message with a preview of the Markdown
await div(
  md(`## Text converted to Markdown and copied!
  
  \`\`\`
  ${markdown}
  \`\`\`
  `), {
    // Set a larger height for the div
    height: PROMPT.HEIGHT.LG,
  }
)
```

## Create New File with Template

```typescript
// Name: Create File from Template
// Description: Creates a new file from a selected template
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user to select a directory 
const directoryPath = await path({
  // Only allow selecting directories
  onlyDirs: true, 
})

// Get available templates from a folder
let templates = await readdir(kenvPath("templates")) 

// Prompt the user to select a template
const template = await arg("Choose a template:", templates)

// Read the contents of the selected template
const templateContent = await readFile(
  kenvPath("templates", template), 
  "utf-8"
) 

// Prompt for the new file name
const newFileName = await arg("Enter new file name:") 

// Create the new file path
const newFilePath = path.join(directoryPath, newFileName) 

// Write the template content to the new file
await writeFile(newFilePath, templateContent)

// Open the new file in the editor
await edit(newFilePath)
```

## Check Website Accessibility

```typescript
// Name: Accessibility Checker
// Description: Checks the accessibility of a website using Pa11y
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the website URL 
const url = await arg("Enter website URL:")

// Run Pa11y accessibility test 
let { stdout: pa11yResult } = await exec(
  `npx pa11y ${url} --reporter json`, 
  { shell: true }
) 

// Parse the Pa11y result as JSON 
const accessibilityReport = JSON.parse(pa11yResult) 

// Display the accessibility issues in a div
let errors = accessibilityReport.issues.filter(
  issue => issue.type === "error"
)
let warnings = accessibilityReport.issues.filter(
  issue => issue.type === "warning"
)
let notices = accessibilityReport.issues.filter(
  issue => issue.type === "notice"
)

let html = ""

if (errors?.length) {
  html += md(`## Errors

${errors
  .map(
    e => `- ${e.message} - ${e.context}\n`
  )
  .join("")}

  `)
}

if (warnings?.length) {
  html += md(`## Warnings

${warnings
  .map(
    w => `- ${w.message} - ${w.context}\n`
  )
  .join("")}

  `)
}

if (notices?.length) {
  html += md(`## Notices

${notices
  .map(
    w => `- ${w.message} - ${w.context}\n`
  )
  .join("")}

  `)
}

if (!html) html = md(`## No accessibility issues found. ðŸ‘`)

await div(
  html,
  "p-5 prose prose-sm dark:prose-invert"
)
```

## Generate TypeScript Project

```typescript
// Name: Generate TypeScript Project
// Description: Generates a new TypeScript project using the TypeScript compiler 
// Author: johnlindquist

import "@johnlindquist/kit" 

// Create a new TypeScript project using the TypeScript compiler 
// Includes a "src" directory and a "tsconfig.json" file
await exec(`npx tsc --init --rootDir src --outDir dist --esModuleInterop --resolveJsonModule --lib dom,es2015`, {
  shell: true, 
})

// Display a confirmation message
await div(md(`# TypeScript project initialized!`)) 
```

## Find Unused Files

```typescript
// Name: Unused File Finder
// Description: Finds unused files in a project
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt the user to select a project directory 
const projectPath = await path({
  onlyDirs: true, // Only allow selecting directories
}) 

// Get all files in the project
const allFiles = await globby([`${projectPath}/**/*`]) 

// Get all files imported or required in the project 
let { stdout: usedFiles } = await exec(
  `rg -T ts,tsx,js,jsx,json,html,css,scss,less --no-filename --only-matching "(from|require)\\(['\"]((?!http|https).*)['\"]\\)"`,
  { shell: true, cwd: projectPath }
)

// Extract file paths from the command output
usedFiles = usedFiles
  .split("\n")
  .map((file) => file.trim().replace(/("|')/g, "")) // Remove quotes and trim whitespace
  .filter((file) => file.length > 0) // Remove empty strings

// Convert the relative paths to absolute paths
const absoluteUsedFiles = usedFiles.map((file) => path.resolve(projectPath, file))

// Find unused files by filtering out the used files from all files 
const unusedFiles = allFiles.filter((file) => !absoluteUsedFiles.includes(file)) 

if (unusedFiles.length > 0) {
  // Display unused files in the editor
  await editor(unusedFiles.join("\n"), {
    language: "text", 
  })
} else {
  // Display a message if no unused files are found
  await div(md(`## No unused files found! ðŸŽ‰`))
}
```

##  Create and Publish npm Package

```typescript
// Name: Create and Publish npm Package
// Description: Creates a new npm package and publishes it to the npm registry 
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt for the package name
const packageName = await arg("Enter package name:") 

// Create a new directory for the package
await mkdir(packageName)

// Change to the package directory 
cd(packageName)

// Initialize the package with npm
await exec(`npm init -y`)

// Prompt for the package entry point 
const entryPoint = await arg("Enter package entry point (e.g., index.js):")

// Update the package.json with the entry point 
await $`npm set-script start 'node ${entryPoint}'`

// Display instructions for creating the package content
await div(md(`
# Package initialized!

1. Add your code to \`${entryPoint}\`.
2. Publish with \`npm publish\`.
`))

// Open the package directory in VS Code
await exec(`code .`)
```



## Send Email with Attachment

```typescript
// Name: Send Email with Attachment
// Description: Sends an email with an attachment using Nodemailer
// Author: johnlindquist

import "@johnlindquist/kit"
import nodemailer from "nodemailer" 

// Get email credentials from environment variables
// You can create an app password here: https://support.google.com/accounts/answer/185833?hl=en 
const emailUser = await env("EMAIL_USER")
const emailPassword = await env("EMAIL_PASSWORD")

// Create a Nodemailer transporter
const transporter = nodemailer.createTransport({
  service: "gmail",
  auth: {
    user: emailUser,
    pass: emailPassword, 
  },
}) 

// Prompt for recipient email address
const to = await arg("Enter recipient email address:")

// Prompt for the email subject
const subject = await arg("Enter email subject:") 

// Prompt for the email body
const body = await textarea({
  placeholder: "Enter email body:",
}) 

// Prompt the user to select a file to attach
const attachmentPath = await path()

// Define email options with the attachment
const mailOptions = {
  from: emailUser, 
  to, 
  subject,
  html: body, 
  attachments: [
    {
      // Use the file path as the attachment 
      path: attachmentPath,
    },
  ], 
}

// Send the email
await transporter.sendMail(mailOptions) 

// Display a confirmation message
await div(md(`## Email sent successfully!`))
```

## Resize Images to Fit Dimensions

```typescript
// Name: Resize Image to Fit
// Description: Resizes an image to fit within specified dimensions, maintaining aspect ratio
// Author: johnlindquist

import "@johnlindquist/kit" 
import sharp from "sharp"

// Prompt the user to select an image
const imagePath = await path({
  filters: [{ name: "Images", extensions: ["jpg", "jpeg", "png", "gif", "webp"] }], 
})

// Prompt for the target width and height 
const targetWidth = parseInt(await arg("Enter target width (px):")) 
const targetHeight = parseInt(await arg("Enter target height (px):")) 

// Resize the image using sharp, fitting it within the target dimensions while preserving aspect ratio
await sharp(imagePath) 
  .resize({
    width: targetWidth, 
    height: targetHeight, 
    fit: sharp.fit.inside, // Ensures the image fits within the dimensions
  })
  .toFile(imagePath)

// Display a notification
await notify("Image resized!", `${imagePath}`)
```

## Get System Memory Usage

```typescript
// Name: Memory Monitor
// Description: Displays the current memory usage 
// Author: johnlindquist

import "@johnlindquist/kit" 
import si from "systeminformation"

// Create a widget to display memory usage
let memoryWidget = await widget(`
<div class="p-4">
  <h2 class="text-xl">Memory Usage</h2>
  <div class="w-full bg-gray-200 rounded-full h-2.5">
    <div id="memory-bar" class="bg-green-500 h-2.5 rounded-full" style="width: {{memoryUsedPercent}}%"></div>
  </div> 
  <p class="text-sm mt-2">Used: {{memoryUsed}} of {{memoryTotal}} ({{memoryUsedPercent}}%)</p> 
</div>
`, {
  // Set a custom width for the widget 
  width: 300 
})

// Update memory usage every second
setInterval(async () => { 
  // Get system memory information
  const memoryData = await si.mem()

  // Calculate memory usage percentage
  const memoryUsedPercent = ((memoryData.used / memoryData.total) * 100).toFixed(2) 

  // Update the widget state with memory information
  memoryWidget.setState({
    memoryUsed: filesize(memoryData.used), // Format used memory using filesize
    memoryTotal: filesize(memoryData.total), // Format total memory using filesize 
    memoryUsedPercent, 
  }) 
}, 1000)
```

## Create GitHub Pull Request

```typescript
// Name: Create GitHub Pull Request
// Description: Creates a new pull request on GitHub
// Author: johnlindquist

import "@johnlindquist/kit" 
import { Octokit } from "@octokit/rest"

// Get GitHub authentication token from environment variables
// You can get a token from here: https://github.com/settings/tokens 
const githubToken = await env("GITHUB_TOKEN") 

// Prompt for the repo owner and name (e.g., "johnlindquist/kit") 
const repo = await arg("Enter repo owner/name:") 
// Split the input into owner and name
const [owner, name] = repo.split("/")

// Create a new Octokit instance 
const octokit = new Octokit({
  auth: githubToken,
}) 

// Prompt for the base and head branch names 
const baseBranch = await arg("Enter base branch name:")
const headBranch = await arg("Enter head branch name:")

// Prompt for the pull request title
const title = await arg("Enter pull request title:") 

// Create the pull request
const { data: newPullRequest } = await octokit.pulls.create({
  owner,
  repo: name,
  title, 
  head: headBranch,
  base: baseBranch,
}) 

// Display a confirmation message with the pull request URL
await div(md(`## Pull request created at: ${newPullRequest.html_url}`)) 

// Open the created pull request in the browser
await browse(newPullRequest.html_url)
```

## Run Script on File Save

```typescript
// Name: Run Script on File Save
// Description: Runs a script when a specific file is saved
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt the user to select a file to watch for changes
const filePath = await path()

// Watch for changes to the file
await watch(
  filePath,
  async () => {
    // Prompt for the script to run when the file is saved
    const scriptToRun = await arg("Select script to run:") 

    // Run the selected script
    await run(scriptToRun)
  },
  {
    events: ["change"], 
  } 
)
```

## Get Current Location's Weather

```typescript
// Name: Get Local Weather
// Description: Retrieves and displays weather information for the user's current location
// Author: johnlindquist

import "@johnlindquist/kit"

// Get your OpenWeatherMap API key here: https://openweathermap.org/api
const OPENWEATHERMAP_API_KEY = await env("OPENWEATHERMAP_API_KEY") 

// Get the user's current location using the browser's geolocation API
const { coords } = await new Promise<GeolocationPosition>(
  (resolve, reject) => {
    navigator.geolocation.getCurrentPosition(resolve, reject) 
  }
) 

// Fetch weather data from OpenWeatherMap API
const response = await get(
  `https://api.openweathermap.org/data/2.5/weather?lat=${coords.latitude}&lon=${coords.longitude}&appid=${OPENWEATHERMAP_API_KEY}&units=metric`
)

// Extract relevant weather information
const { name, main, weather } = response.data 
const temperature = main.temp
const description = weather[0].description

// Display weather information in a div
await div( 
  md(`## Weather in ${name}:

* Temperature: ${temperature}Â°C
* Description: ${description}
  `)
)
```

## Find and Replace Across Multiple Files

```typescript
// Name: Multi-File Find and Replace
// Description: Finds and replaces text in multiple files
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt the user to select multiple files 
const filePaths = await selectFile({
  multiple: true, // Allow selecting multiple files
})

// Prompt for the search term 
const searchTerm = await arg("Enter search term:")

// Prompt for the replacement text
const replacementText = await arg("Enter replacement text:")

// Replace the text in each selected file 
for (const filePath of filePaths) {
  await replace({
    files: filePath,
    from: searchTerm,
    to: replacementText,
  })
}

// Display a confirmation message
await div(md(`## Text replaced in ${filePaths.length} files!`)) 
```

## Generate Project Changelog

```typescript
// Name: Generate Changelog
// Description: Generates a changelog for a project using the conventional-changelog library
// Author: johnlindquist

import "@johnlindquist/kit" 

// Generate the changelog using conventional-changelog 
await exec(`npx conventional-changelog -p angular -i CHANGELOG.md -s`, { shell: true }) 

// Display a confirmation message
await div(md(`## CHANGELOG.md generated!`))

// Reveal the changelog file in Finder 
await revealFile("CHANGELOG.md") 
```

##  Batch Rename Files

```typescript
// Name: Batch File Renamer
// Description: Renames multiple files in a directory 
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt the user to select a directory
const directoryPath = await path({
  onlyDirs: true, // Only allow selecting directories 
})

// Prompt for the search pattern 
const searchPattern = await arg("Enter search pattern (use * as wildcard):") 

// Prompt for the replacement pattern
const replacementPattern = await arg("Enter replacement pattern:")

// Rename files using `rename` command with regular expressions, providing an example 
// and requiring user confirmation
const confirmRename = await arg(
  {
    placeholder: "Confirm renaming?", 
    hint: `Example: "file-*.txt" will become "file-{}.txt"`, 
  },
  ["Yes", "No"] 
) 

if (confirmRename === "Yes") {
  // Rename files in the directory
  await exec(`rename 's/${searchPattern}/${replacementPattern}/g' ${directoryPath}/*`, { shell: true })

  // Display a confirmation message
  await div(md(`## Files renamed successfully!`))
}
```

## Check Node.js Version

```typescript
// Name: Check Node Version
// Description: Checks and displays the installed Node.js version
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the Node.js version using the `node -v` command
const nodeVersion = (await $`node -v`).stdout.trim() 

// Display the Node.js version
await div(md(`## Your Node.js version is: ${nodeVersion}`))
```

## Get User's Public GitHub Repositories

```typescript
// Name: List GitHub Repos
// Description: Displays a list of public repositories for a GitHub user 
// Author: johnlindquist

import "@johnlindquist/kit" 
import { Octokit } from "@octokit/rest" 

// Prompt for GitHub username 
const username = await arg("Enter GitHub username:") 

// Create a new Octokit instance, using the provided username
const octokit = new Octokit() 

// Fetch the user's public repositories 
const { data: repos } = await octokit.repos.listForUser({
  username, 
  type: "public",
}) 

// Create an array of choices from the repository data, including a preview
const repoChoices = repos.map((repo) => ({
  name: repo.name, 
  description: repo.description, 
  value: repo.html_url,
  // Display a preview of the repository's README.md file
  preview: async () => { 
    try {
      const readmeResponse = await get(repo.url + "/readme") 
      return md(readmeResponse?.data)
    } catch { 
      return `No README.md found` 
    }
  }, 
}))

// Prompt the user to select a repository
let selectedRepo = await arg({
    placeholder: "Select a repository",
    enter: "Open in Browser", 
  }, repoChoices) 

// Open the selected repository in the browser
await browse(selectedRepo) 
```

## Create and Send a WhatsApp Message

```typescript
// Name: Send WhatsApp Message
// Description: Sends a WhatsApp message using the Twilio API 
// Author: johnlindquist

import "@johnlindquist/kit"

// Get Twilio credentials from the environment variables
// You can get an Account SID and Auth Token from here: https://www.twilio.com/console 
const accountSid = await env("TWILIO_ACCOUNT_SID") 
const authToken = await env("TWILIO_AUTH_TOKEN") 

// Prompt the user for the recipient's phone number
const to = await arg("Enter recipient's phone number (with country code):")

// Prompt for the message body
const body = await arg("Enter message:")

// Initialize the Twilio client 
const twilio = require("twilio")(accountSid, authToken)

// Send the message
twilio.messages
  .create({
    body,
    from: `whatsapp:${await env("TWILIO_WHATSAPP_NUMBER")}`, // Your Twilio WhatsApp number 
    to: `whatsapp:${to}`,
  })
  .then((message) => console.log(`Message SID: ${message.sid}`))
  .catch((error) => console.error("Error sending message:", error))
  

// Display a confirmation message
await div(md(`## WhatsApp message sent!`))
```

## Convert Image to WebP

```typescript
// Name: Convert Image to WebP
// Description: Converts an image to WebP format
// Author: johnlindquist

import "@johnlindquist/kit"
import sharp from "sharp"

// Prompt the user to select an image
const imagePath = await path({
  filters: [{ name: "Images", extensions: ["jpg", "jpeg", "png", "gif"] }], 
})

// Convert the image to WebP format using sharp
await sharp(imagePath)
  .webp({ quality: 80 }) // Set the desired quality
  .toFile(imagePath.replace(/\.(jpg|jpeg|png|gif)$/, ".webp")) 

// Display a confirmation message 
await div(md(`## Image converted to WebP!`)) 

// Reveal the converted image in Finder
await revealFile(imagePath.replace(/\.(jpg|jpeg|png|gif)$/, ".webp"))
```

## Check for GitHub Repository Updates

```typescript
// Name: Check for Repo Updates
// Description: Checks if a GitHub repository has any new commits
// Author: johnlindquist

import "@johnlindquist/kit"
import { Octokit } from "@octokit/rest"

// Prompt for the GitHub repository
const repo = await arg("Enter GitHub repository (owner/name):") 

// Split the input into owner and repository name
const [owner, repoName] = repo.split("/")

// Get the last commit SHA from the local repository 
const { stdout: localCommitSHA } = await exec(`git rev-parse HEAD`, {
  // Run the command in the repository directory 
  cwd: kenvPath("kenvs", repoName),
})

// Get your GitHub authentication token from environment variables
// You can get a token from here: https://github.com/settings/tokens 
const githubToken = await env("GITHUB_TOKEN")

// Create a new Octokit instance
const octokit = new Octokit({
  auth: githubToken,
}) 

// Fetch the latest commit SHA for the repository 
const { data: { object: { sha: latestCommitSHA } } } = await octokit.repos.getBranch({
  owner,
  repo: repoName,
  branch: "main",
}) 

// Compare the local commit SHA with the latest commit SHA 
if (localCommitSHA.trim() === latestCommitSHA) { 
  // Display a message if the repository is up to date
  await div(md(`## Repository is up to date!`)) 
} else {
  // Display a message if there are new commits 
  await div(md(`## New commits are available!`)) 
}
```
## Generate Project Sitemap

```typescript
// Name: Generate Sitemap
// Description: Generates a sitemap.xml for a website
// Author: johnlindquist

import "@johnlindquist/kit"
import { SitemapStream, streamToPromise } from "sitemap"

// Prompt the user for the website URL
const websiteUrl = await arg("Enter your website URL:")

// Create a SitemapStream instance 
const sitemapStream = new SitemapStream({ hostname: websiteUrl })

// Add URLs to the sitemap
sitemapStream.write({ url: "/", changefreq: "daily", priority: 0.9 }) 
sitemapStream.write({ url: "/about", changefreq: "weekly", priority: 0.7 })
sitemapStream.write({ url: "/blog", changefreq: "daily", priority: 0.8 }) 

// End the sitemap stream
sitemapStream.end()

// Convert the sitemap stream to a promise
const sitemapXml = await streamToPromise(sitemapStream)

// Write the sitemap to a file
await writeFile("sitemap.xml", sitemapXml.toString())

// Display a confirmation message 
await div(md(`## sitemap.xml generated!`))

// Reveal the generated sitemap file in Finder
await revealFile("sitemap.xml") 
```

## Convert Text to Handwriting

```typescript
// Name: Convert Text to Handwriting
// Description: Converts text to a handwritten image using the handwriting-io API
// Author: johnlindquist

import "@johnlindquist/kit"

// Get your API key here: https://www.handwriting.io/pricing
const HANDWRITING_API_KEY = await env("HANDWRITING_API_KEY")

// Prompt for the text to convert
const text = await arg("Enter text to convert:")

// Prompt for the handwriting style 
const handwritingStyle = await arg(
  "Select handwriting style:", 
  [
    "BALLPOINT",
    "CURSIVE", 
    "MARKER", 
  ]
) 

// Send a request to the Handwriting.io API
const response = await post( 
  "https://api.handwriting.io/render",
  {
    text,
    handwriting_id: handwritingStyle,
    handwriting_size: "auto", 
    width: "auto", 
    height: "auto",
    color: "000000",
  },
  { headers: { "api-key": HANDWRITING_API_KEY } } 
)

// Extract the image URL from the response
const { image_url } = response.data

// Display the generated image in a div
await div(`<img src="${image_url}" alt="Handwritten Text" />`) 
```

## Compress Images

```typescript
// Name: Image Compressor
// Description: Compresses images in a directory
// Author: johnlindquist

import "@johnlindquist/kit"
import sharp from "sharp"

// Prompt the user to select a directory
const directoryPath = await path({
  onlyDirs: true, // Only allow selecting directories
})

// Prompt for the desired image quality (0-100) 
const quality = parseInt(await arg("Enter desired image quality (0-100):"))

// Get all image files in the selected directory 
const imageFiles = await globby([`${directoryPath}/*.{jpg,jpeg,png}`]) 

// Compress each image using sharp, preserving the original format
for (const imagePath of imageFiles) {
  await sharp(imagePath) 
    .toFormat(path.extname(imagePath).slice(1), { quality }) // Compress to original format
    .toFile(imagePath)
} 

// Display a confirmation message 
await div(md(`## Images compressed successfully!`)) 
```

## Find and Replace Text in Clipboard

```typescript
// Name: Clipboard Find and Replace
// Description: Finds and replaces text in the clipboard
// Author: johnlindquist

import "@johnlindquist/kit"

// Get text from the clipboard 
const text = await paste() 

// Prompt the user for the search string 
const searchString = await arg("Enter search string:") 

// Prompt for the replacement string
const replacementString = await arg("Enter replacement string:") 

// Perform the find and replace operation
const newText = text.replaceAll(searchString, replacementString)

// Copy the modified text back to the clipboard
await copy(newText)

// Display a confirmation message 
await div(md(`## Text replaced and copied to the clipboard!`))
```

##  Generate Random UUID

```typescript
// Name: Generate UUID
// Description: Generates a random UUID and copies it to the clipboard
// Author: johnlindquist

import "@johnlindquist/kit" 

// Generate a random UUID 
const randomUUID = crypto.randomUUID() 

// Copy the UUID to the clipboard
await copy(randomUUID) 

// Display a confirmation message 
await div(md(`## UUID copied to clipboard: ${randomUUID}`)) 
```

## Get System Battery Status

```typescript
// Name: Battery Status
// Description: Displays the current battery status
// Author: johnlindquist

import "@johnlindquist/kit"
import si from "systeminformation"

// Get battery information using the systeminformation library
const batteryData = await si.battery() 

// Extract relevant battery information
const { percent, isCharging } = batteryData 

// Create the battery status string
const batteryStatus = `Battery: ${percent}% ${isCharging ? "(Charging)" : ""}`

// Display the battery status in a div
await div(md(`## ${batteryStatus}`)) 
```

## Generate Project Boilerplate

```typescript
// Name: Generate Project Boilerplate
// Description: Generates a new project from a GitHub template repository
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt for the template repository URL
const repoUrl = await arg("Enter GitHub template repository URL:") 

// Prompt for the project name
const projectName = await arg("Enter project name:") 

// Create the project directory path
const projectPath = home("dev", projectName)

// Clone the template repository using degit
await degit(repoUrl).clone(projectPath)

// Display a confirmation message
await div(md(`## Project boilerplate generated!`)) 

// Open the project directory in VS Code
await exec(`code ${projectPath}`) 
```


## Create and Push a Git Tag

```typescript
// Name: Create Git Tag
// Description: Creates and pushes a new Git tag
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the tag name 
const tagName = await arg("Enter tag name:")

// Prompt for the tag message 
const tagMessage = await arg("Enter tag message:") 

// Create the Git tag
await $`git tag -a ${tagName} -m ${tagMessage}`

// Push the tag to the remote repository
await $`git push origin ${tagName}` 

// Display a confirmation message
await div(md(`## Git tag ${tagName} created and pushed!`))
```

## Check for outdated npm Packages

```typescript
// Name: Check for Outdated Packages
// Description: Checks for outdated npm packages in the current project
// Author: johnlindquist

import "@johnlindquist/kit"

// Run `npm outdated` to check for outdated packages 
let { stdout } = await exec(`npm outdated`)

// Check if there are any outdated packages
if (stdout.trim().length > 0) {
  // Display a list of outdated packages in the editor
  await editor(stdout, { language: "text" })
} else {
  // Display a message if all packages are up to date
  await div(md(`## All npm packages are up to date! ðŸŽ‰`)) 
}
```

## Convert JSON to YAML

```typescript
// Name: JSON to YAML Converter
// Description: Converts JSON data to YAML format
// Author: johnlindquist

import "@johnlindquist/kit"
import yaml from "js-yaml" 

// Prompt the user to select a JSON file 
const filePath = await path({
  filters: [{ name: "JSON Files", extensions: ["json"] }],
}) 

// Read the JSON data from the file 
const jsonData = await readJson(filePath) 

// Convert JSON to YAML using js-yaml
const yamlData = yaml.dump(jsonData) 

// Display the YAML data in the editor 
await editor(yamlData, {
  language: "yaml", 
})
```

## Download and Install an Application

```typescript
// Name: App Installer 
// Description: Downloads and installs an application from a URL
// Author: johnlindquist 

import "@johnlindquist/kit"

// Prompt for the application URL 
const appUrl = await arg("Enter application URL:") 

// Prompt for the app name
const appName = await arg("Enter app name:") 

// Download the application to the Downloads directory
await download(appUrl, home("Downloads"))

// Open the downloaded application file 
// Note: This assumes the application is a DMG file, you might need to adjust for other formats 
await exec(`open ${path.join(home("Downloads"), `${appName}.dmg`)}`)

// Display a notification
await notify(`Installing ${appName}...`)
```

## Get Random Wikipedia Article

```typescript
// Name: Random Wikipedia Article
// Description: Opens a random Wikipedia article in the browser
// Author: johnlindquist

import "@johnlindquist/kit"

// Fetch a random Wikipedia article URL
const response = await get("https://en.wikipedia.org/wiki/Special:Random")

// Extract the URL from the response 
const { url } = response

// Open the random Wikipedia article in the browser 
await browse(url) 
```

## Generate Project License

```typescript
// Name: Generate License
// Description: Generates a license file for a project 
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt for the type of license 
const licenseType = await arg("Select license type:", [
  "MIT",
  "Apache-2.0",
  "GPL-3.0",
])

// Fetch the license text from GitHub's choosealicense.com API 
const licenseText = await get(`https://api.github.com/licenses/${licenseType}`).then( 
  response => response.data.body
)

// Write the license text to a "LICENSE" file in the current directory 
await writeFile("LICENSE", licenseText)

// Display a confirmation message
await div(md(`## LICENSE file generated!`))

// Reveal the generated LICENSE file in Finder 
await revealFile("LICENSE") 
```

##  Check for Typos

```typescript
// Name: Spell Checker
// Description: Checks for spelling errors in a text file
// Author: johnlindquist 

import "@johnlindquist/kit" 
import SpellChecker from "spellchecker"

// Prompt the user to select a text file 
const filePath = await path({ 
  filters: [{ name: "Text Files", extensions: ["txt", "md"] }], 
})

// Read the contents of the file 
const text = await readFile(filePath, "utf-8")

// Check for spelling errors using spellchecker
const misspellings = SpellChecker.checkSpelling(text) 

if (misspellings.length > 0) { 
  // Display misspellings in a div, offering suggestions
  let html = `
    <h1>Misspellings:</h1> 
    <ul>
      ${misspellings.map(misspelling => `
        <li>
          "${misspelling.word}" - Suggestions: ${SpellChecker.getCorrectionsForMisspelling(misspelling.word).join(", ")}
        </li>
      `).join("")}
    </ul>
  `

  await div(html)
} else {
  // Display a message if no misspellings are found
  await div(md(`## No spelling errors found! ðŸ‘`)) 
} 
```
## Send SMS Message

```typescript
// Name: Send SMS Message
// Description: Sends an SMS message using the Twilio API
// Author: johnlindquist

import "@johnlindquist/kit" 

// Get your Account SID and Auth Token from here: https://www.twilio.com/console 
const accountSid = await env("TWILIO_ACCOUNT_SID")
const authToken = await env("TWILIO_AUTH_TOKEN")

// Initialize the Twilio client
const twilio = require("twilio")(accountSid, authToken)

// Prompt for the recipient's phone number
const to = await arg("Enter recipient's phone number (with country code):")

// Prompt for the message to send
const body = await arg("Enter message to send:")

// Send the SMS message
twilio.messages
  .create({
    body,
    from: await env("TWILIO_PHONE_NUMBER"), // Your Twilio phone number 
    to,
  })
  .then((message) => console.log(message.sid))

// Display a confirmation message 
await div(md(`## SMS message sent!`)) 
```

## Create and Share Code Snippet

```typescript
// Name: Share Code Snippet
// Description: Creates a code snippet and shares it as a GitHub Gist
// Author: johnlindquist 

import "@johnlindquist/kit"

// Prompt for the code snippet content 
const codeSnippet = await editor({
  placeholder: "Enter your code snippet:", 
  // Default to JavaScript syntax highlighting
  language: "javascript",
}) 

// Prompt for a description of the snippet
const description = await arg("Enter a description for your snippet:")

// Create a Gist on GitHub
const { html_url: gistUrl } = await createGist(codeSnippet, {
  description,
  fileName: "snippet.js",
})

// Copy the Gist URL to the clipboard 
await copy(gistUrl)

// Display a confirmation message with the Gist URL
await div(md(`## Code snippet shared as a Gist:\n\n${gistUrl}`)) 
```

## Convert Video to MP3

```typescript
// Name: Video to MP3 Converter
// Description: Converts a video file to MP3 audio
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user to select a video file
const videoFilePath = await path({
  filters: [{ name: "Videos", extensions: ["mp4", "mov", "avi", "mkv"] }],
}) 

// Extract the directory and file name from the selected path
const { dir, name } = path.parse(videoFilePath)

// Construct the output file path for the MP3
const outputFilePath = path.join(dir, `${name}.mp3`)

// Convert the video to MP3 using ffmpeg
await exec(`ffmpeg -i '${videoFilePath}' -vn -acodec libmp3lame '${outputFilePath}'`, { shell: true }) 

// Display a notification
await notify("Video converted to MP3!", `Saved to ${outputFilePath}`)

// Reveal the output file in Finder
await revealFile(outputFilePath)
```

## Check if a Website is Down

```typescript
// Name: Website Down Checker
// Description: Checks if a website is down for everyone or just you
// Author: johnlindquist

import "@johnlindquist/kit" 
import isitdown from "isitdown"

// Prompt the user for the website URL 
const url = await arg("Enter website URL:") 

// Check the website status using isitdown
const isDown = await isitdown(url)

// Display the website status
await div(md(`## Website Status: ${isDown ? "Down" : "Up"}`))
```

## Generate Project Structure

```typescript
// Name: Generate Project Structure
// Description: Generates a basic project structure with folders and files
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt for the project name 
const projectName = await arg("Enter project name:")

// Create the project directory path
const projectPath = home("dev", projectName)

// Create the project directory
await mkdir(projectPath)

// Create subdirectories 
await Promise.all([
  mkdir(path.join(projectPath, "src")),
  mkdir(path.join(projectPath, "tests")), 
  mkdir(path.join(projectPath, "docs")),
])

// Create a README.md file in the project directory 
await writeFile(path.join(projectPath, "README.md"), `# ${projectName}\n`)

// Display a confirmation message 
await div(md(`## Project structure generated at: ${projectPath}`))

// Open the project directory in VS Code
await exec(`code ${projectPath}`) 
```

## Create Time-lapse Video from Images

```typescript
// Name: Time-lapse Creator
// Description: Creates a time-lapse video from a sequence of images
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user to select a directory containing images
const directoryPath = await path({
  onlyDirs: true, // Only allow selecting directories
})

// Prompt for the desired frames per second (FPS)
const fps = parseInt(await arg("Enter frames per second (FPS):")) 

// Create the output file path for the time-lapse video
const outputFilePath = path.join(directoryPath, "timelapse.mp4")

// Generate the time-lapse video using ffmpeg
await exec(
  `ffmpeg -y -framerate ${fps} -pattern_type glob -i '${directoryPath}/*.{jpg,jpeg,png}' -c:v libx264 -pix_fmt yuv420p '${outputFilePath}'`, 
  { shell: true }
)

// Display a notification
await notify("Time-lapse video created!", `Saved to ${outputFilePath}`) 

// Reveal the time-lapse video in Finder
await revealFile(outputFilePath)
```

##  Send Email Digest

```typescript
// Name: Send Email Digest
// Description: Sends a daily email digest of news headlines
// Author: johnlindquist

import "@johnlindquist/kit"
import nodemailer from "nodemailer"
import { JSDOM } from "jsdom" 

// Get email credentials from environment variables
// You can create an app password here: https://support.google.com/accounts/answer/185833?hl=en
const emailUser = await env("EMAIL_USER")
const emailPassword = await env("EMAIL_PASSWORD")

// Create a Nodemailer transporter
const transporter = nodemailer.createTransport({
  service: "gmail",
  auth: {
    user: emailUser,
    pass: emailPassword, 
  },
}) 

// Prompt for the recipient's email address 
const to = await arg("Enter recipient email address:")

// Fetch news headlines from a news website (using Hacker News as an example)
const response = await get("https://news.ycombinator.com/") 

// Parse the HTML content
const { window: { document } } = new JSDOM(response.data) 

// Select headlines and URLs from the parsed HTML
const headlines = Array.from(document.querySelectorAll(".titleline > a")).map((a) => ({
  title: a.textContent, 
  url: a.href, 
})) 

// Generate HTML content for the email digest 
const emailHtml = `
  <h1>News Digest</h1> 
  <ul>
    ${headlines.map(headline => `
      <li>
        <a href="${headline.url}">${headline.title}</a>
      </li>
    `).join("")}
  </ul>
` 

// Define email options 
const mailOptions = {
  from: emailUser,
  to, 
  subject: "Your Daily News Digest",
  html: emailHtml, 
}

// Send the email 
await transporter.sendMail(mailOptions) 

// Display a confirmation message 
await div(md(`## Email digest sent!`)) 
```


## Resize Image and Preserve Metadata

```typescript
// Name: Resize Image and Preserve Metadata
// Description: Resizes an image and preserves its metadata using exiftool
// Author: johnlindquist

import "@johnlindquist/kit"
import sharp from "sharp"

// Prompt the user to select an image file
const imagePath = await path({
  filters: [{ name: "Images", extensions: ["jpg", "jpeg", "png"] }], 
})

// Prompt the user to enter the desired width
const width = parseInt(await arg("Enter the desired width (px):")) 

// Create a temporary file to store the resized image
const tempImagePath = tmpPath(`resized-${path.basename(imagePath)}`) 

// Resize the image using sharp
await sharp(imagePath).resize({ width }).toFile(tempImagePath)

// Copy metadata from the original image to the resized image using exiftool 
await exec(`exiftool -TagsFromFile '${imagePath}'  '${tempImagePath}'`, { shell: true }) 

// Replace the original image with the resized image
await mv(tempImagePath, imagePath) 

// Display a notification
await notify("Image resized!", `${imagePath}`)
```

## Check for Code Complexity

```typescript
// Name: Code Complexity Checker
// Description: Checks the complexity of JavaScript code using eslint 
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user to select a JavaScript file
const filePath = await path({
  filters: [{ name: "JavaScript Files", extensions: ["js"] }],
})

// Check code complexity using ESLint with the complexity plugin
// The command outputs the complexity score for each function in the file
let { stdout: complexityResult } = await exec(`npx eslint --plugin complexity --rule 'complexity: [2, 10]' --format json '${filePath}'`, {
  shell: true,
})

// Parse the ESLint result
const complexityReport = JSON.parse(complexityResult)

// Extract the messages from the report
const messages = complexityReport[0].messages 

if (messages.length > 0) {
  // Display complexity warnings in a div
  let html = `
  <h1>Code Complexity Warnings:</h1> 
  <ul>
    ${messages.map(message => `
      <li>
        ${message.message} - Line: ${message.line}, Column: ${message.column}
      </li>
    `).join("")} 
  </ul> 
  `
  await div(html)
} else {
  // Display a message if no complexity issues are found 
  await div(md(`## No code complexity issues found! ðŸŽ‰`))
}
```

## Get User's Twitter Followers

```typescript
// Name: Get Twitter Followers
// Description: Displays a list of followers for a Twitter user
// Author: johnlindquist

import "@johnlindquist/kit"
import TwitterApi from "twitter-api-v2" 

// Retrieve Twitter API credentials from environment variables
// You can create API keys and tokens here: https://developer.twitter.com/en/portal/dashboard
const TWITTER_API_KEY = await env("TWITTER_API_KEY") 
const TWITTER_API_SECRET = await env("TWITTER_API_SECRET")
const TWITTER_ACCESS_TOKEN = await env("TWITTER_ACCESS_TOKEN") 
const TWITTER_ACCESS_SECRET = await env("TWITTER_ACCESS_SECRET")

// Create a new instance of the Twitter API client 
const twitterClient = new TwitterApi({
  appKey: TWITTER_API_KEY,
  appSecret: TWITTER_API_SECRET,
  accessToken: TWITTER_ACCESS_TOKEN, 
  accessSecret: TWITTER_ACCESS_SECRET,
}) 

// Authenticate with the Twitter API
const client = await twitterClient.readWrite 

// Prompt for the Twitter username
const username = await arg("Enter Twitter username:") 

// Fetch followers for the specified user
const followers = await client.v2.followers(username, { 
  // Only retrieve usernames and user IDs
  "user.fields": ["username", "id"], 
  // Retrieve up to 1000 followers
  max_results: 1000, 
})

// Display a list of followers
await div(
  md(`
## Followers for @${username}:

${followers.data.data.map(follower => `- @${follower.username}`).join("\n")}
`)
)
```

## Convert Text to Audio File

```typescript
// Name: Text to Audio Converter
// Description: Converts text to an audio file using the Google Cloud Text-to-Speech API
// Author: johnlindquist

import "@johnlindquist/kit" 
import textToSpeech from "@google-cloud/text-to-speech"

// Get your Google Cloud API key from here: https://cloud.google.com/docs/authentication/api-keys
const GOOGLE_APPLICATION_CREDENTIALS = await env("GOOGLE_APPLICATION_CREDENTIALS") 

// Create a new Text-to-Speech client 
const ttsClient = new textToSpeech.TextToSpeechClient()

// Prompt the user to enter the text 
const text = await arg("Enter text to convert to speech:") 

// Prompt for the language code 
const languageCode = await arg("Enter language code (e.g., 'en-US'):")

// Prompt for the output file name
const outputFileName = await arg("Enter output file name (e.g., audio.mp3):") 

// Configure the text-to-speech request
const request = {
  input: { text }, 
  voice: { languageCode, ssmlGender: "NEUTRAL" }, 
  audioConfig: { audioEncoding: "MP3" }, 
}

// Perform the text-to-speech conversion 
const [response] = await ttsClient.synthesizeSpeech(request)

// Write the audio content to a file
const audioContent = response.audioContent;
const outputPath = path.join(home("Downloads"), outputFileName) 
await writeFile(outputPath, audioContent, "binary") 

// Display a confirmation message
await div(md(`## Audio file generated!`)) 

// Reveal the generated audio file in Finder
await revealFile(outputPath)
```

## Optimize PDF File Size

```typescript
// Name: PDF Optimizer
// Description: Optimizes PDF file size using Ghostscript
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user to select a PDF file
const pdfFilePath = await path({
  filters: [{ name: "PDF Files", extensions: ["pdf"] }], 
}) 

// Create a temporary file path for the optimized PDF
const optimizedPdfPath = tmpPath(`optimized-${path.basename(pdfFilePath)}`) 

// Optimize the PDF file using Ghostscript 
await exec(`gs -sDEVICE=pdfwrite -dCompatibilityLevel=1.4 -dPDFSETTINGS=/screen -dNOPAUSE -dQUIET -dBATCH -sOutputFile='${optimizedPdfPath}' '${pdfFilePath}'`, {
  shell: true,
}) 

// Replace the original PDF with the optimized PDF
await mv(optimizedPdfPath, pdfFilePath)

// Display a notification
await notify("PDF optimized!", `${pdfFilePath}`) 
```

##  Get Trending GitHub Repositories

```typescript
// Name: Trending GitHub Repos
// Description: Displays a list of trending GitHub repositories
// Author: johnlindquist

import "@johnlindquist/kit" 
import { Octokit } from "@octokit/rest"

// Create a new Octokit instance
const octokit = new Octokit() 

// Prompt for the programming language 
const language = await arg("Enter programming language:")

// Fetch trending repositories for the specified language
const { data: repos } = await octokit.repos.listForOrg({
  org: "trending", // Use the "trending" organization for trending repositories 
  type: "public",
  // Use the language as a topic to filter repositories 
  topic: language, 
}) 

// Create choices from the repository data, including a preview
const repoChoices = repos.map((repo) => ({
  name: repo.name,
  description: repo.description,
  value: repo.html_url,
  // Display a preview of the repository's README.md file 
  preview: async () => { 
    try {
      const readmeResponse = await get(repo.url + "/readme")
      return md(readmeResponse?.data)
    } catch {
      return "No README.md found."
    }
  },
}))

// Prompt the user to select a repository
const selectedRepo = await arg({
  placeholder: "Select a repository", 
  enter: "Open in Browser",
}, repoChoices) 

// Open the selected repository in the browser 
await browse(selectedRepo)
```

## Generate Random Jokes

```typescript
// Name: Joke Generator
// Description: Tells a random joke
// Author: johnlindquist

import "@johnlindquist/kit"

// Fetch a random joke from the JokeAPI
const { data: jokeData } = await get(
  "https://v2.jokeapi.dev/joke/Any?blacklistFlags=nsfw,religious,political,racist,sexist,explicit&type=single",
  // Set a timeout for the request (in milliseconds)
  { timeout: 5000 } 
)

// Display the joke in a div
await div(md(`## ${jokeData.joke}`))
```


## Convert Speech to Text

```typescript
// Name: Speech to Text Converter
// Description: Converts speech from the microphone to text using the Google Cloud Speech-to-Text API
// Author: johnlindquist

import "@johnlindquist/kit"
import speech from "@google-cloud/speech"

// Get your Google Cloud API key from here: https://cloud.google.com/docs/authentication/api-keys
const GOOGLE_APPLICATION_CREDENTIALS = await env("GOOGLE_APPLICATION_CREDENTIALS")

// Create a new Speech-to-Text client 
const speechClient = new speech.SpeechClient()

// Prompt the user to start recording 
await div(md(`# Click "Start Recording" to begin speaking.`), "flex flex-col items-center justify-center text-center gap-2")
const audioFilePath = await mic.start()

// Stop recording when the user presses the escape key 
onKeydown(async (event) => {
  if (event.key === "Escape") {
    await mic.stop()
  } 
})

// Read the audio content from the recorded file 
const audioContent = await readFile(audioFilePath) 

// Configure the speech-to-text request
const request = {
  audio: { content: audioContent.toString("base64") }, // Encode audio content as Base64 
  config: {
    encoding: "LINEAR16", 
    sampleRateHertz: 16000,
    languageCode: "en-US",
  },
}

// Perform speech-to-text conversion 
const [response] = await speechClient.recognize(request) 

// Extract and join the transcribed text 
const transcription = response.results.map(result => result.alternatives[0].transcript).join("\n")

// Display the transcribed text in the editor
await editor(transcription, {
  language: "text",
})
```

## Find and Replace in Clipboard

```typescript
// Name: Clipboard Find and Replace
// Description: Finds and replaces text in the clipboard content
// Author: johnlindquist

import "@johnlindquist/kit" 

// Get the text content from the clipboard
const clipboardText = await paste()

// Prompt the user for the text to find
const searchText = await arg("Enter text to find:") 

// Prompt the user for the replacement text 
const replacementText = await arg("Enter replacement text:")

// Perform the find and replace operation
const newClipboardText = clipboardText.replaceAll(searchText, replacementText)

// Write the modified text back to the clipboard
await clipboard.writeText(newClipboardText)

// Display a notification
await notify("Text replaced in clipboard!") 
```

## Create and Send a Telegram Message

```typescript
// Name: Send Telegram Message 
// Description: Sends a message to a Telegram chat using the Telegraf library
// Author: johnlindquist

import "@johnlindquist/kit" 
import { Telegraf } from "telegraf"

// Get your Telegram Bot Token from here: https://t.me/BotFather
const TELEGRAM_BOT_TOKEN = await env("TELEGRAM_BOT_TOKEN") 

// Create a new instance of the Telegraf client
const bot = new Telegraf(TELEGRAM_BOT_TOKEN)

// Prompt for the Telegram chat ID
const chatId = await arg("Enter Telegram chat ID:")

// Prompt for the message
const message = await arg("Enter message to send:")

// Send the message to the specified chat
bot.telegram.sendMessage(chatId, message) 

// Display a confirmation message
await div(md(`## Telegram message sent!`))
```

## Check for Available System Updates

```typescript
// Name: Check for System Updates
// Description: Checks for and displays available system updates 
// Author: johnlindquist

import "@johnlindquist/kit" 

// Check for system updates (macOS only)
if (isMac) {
  // Use the 'softwareupdate' command to list available updates
  let { stdout: updates } = await exec(`softwareupdate --list`) 
  if (updates.includes("No new software available.")) {
    // Display a message if no updates are found 
    await div(md(`## No system updates available.`))
  } else {
    // Display the available updates in the editor
    await editor(updates, { language: "text" })
  }
} else { 
  // Display a message if the script is run on a non-macOS system
  await div(md(`## This script is only supported on macOS.`))
} 
```

## Get Code Completion Suggestions

```typescript
// Name: Get Code Suggestions 
// Description: Gets code completion suggestions for JavaScript using the built-in TypeScript language service 
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user to enter some JavaScript code
const code = await editor({
  language: "javascript",
  placeholder: "Enter your JavaScript code:",
}) 

// Get the cursor position in the editor
const cursorPosition = await editor.getCursorOffset()

// Get code completion suggestions using the TypeScript language service 
let suggestions = await global.getCompletions(code, cursorPosition)

// Filter suggestions to only include properties and methods
suggestions = suggestions.filter(
  suggestion => suggestion.kind === 9 || suggestion.kind === 0
)

// Prompt the user to select a suggestion 
let selectedSuggestion = await arg(
  {
    placeholder: "Select a suggestion:",
  },
  suggestions
) 

// Insert the selected suggestion into the editor
await editor.insertText(selectedSuggestion.insertText)
```

##  Extract Text from PDF

```typescript
// Name: Extract PDF Text
// Description: Extracts text from a PDF file using the pdf-parse library
// Author: johnlindquist 

import "@johnlindquist/kit" 
import { parse } from "pdf-parse"

// Prompt the user to select a PDF file
const filePath = await path({
  filters: [{ name: "PDF Files", extensions: ["pdf"] }],
})

// Extract text from the PDF file using pdf-parse 
const { textContent } = await parse(await readFile(filePath)) 

// Display the extracted text in the editor
await editor(textContent, {
  language: "text",
}) 
```

##  Convert Image to ASCII Art

```typescript
// Name: Image to ASCII Art Converter
// Description: Converts an image to ASCII art
// Author: johnlindquist

import "@johnlindquist/kit" 
import { imageToAscii } from "image-to-ascii"

// Prompt the user to select an image 
const imagePath = await path({
  filters: [{ name: "Images", extensions: ["jpg", "jpeg", "png", "gif"] }], 
})

// Convert the image to ASCII art, adjusting the width and reverse the output
const asciiArt = await imageToAscii(imagePath, {
  width: 80, 
  reverse: true,
})

// Display the ASCII art in the editor
await editor(asciiArt, {
  language: "text", 
}) 
```

## Resize Images with Multiple Options

```typescript
// Name: Advanced Image Resizer
// Description: Resizes an image with various options and previews 
// Author: johnlindquist

import "@johnlindquist/kit"
import sharp from "sharp"

// Prompt the user to select an image
const imagePath = await path({ 
  filters: [{ name: "Images", extensions: ["jpg", "jpeg", "png", "gif", "webp"] }],
})

// Prompt for the new image width 
const width = parseInt(await arg("Enter new width (px):"))

// Prompt for the output format 
const outputFormat = await arg(
  "Select output format:",
  // Provide common image formats as choices 
  [
    "jpg", 
    "jpeg", 
    "png",
    "webp",
  ] 
)

// Function to generate a preview image with the specified width and format
const generatePreview = async (width: number, format: string) => {
  // Create a temporary file path for the preview image
  const previewImagePath = tmpPath(`preview.${format}`)
  // Resize the image and convert it to the specified format
  await sharp(imagePath)
    .resize({ width })
    .toFormat(format) 
    .toFile(previewImagePath) 

  // Return the preview image path
  return previewImagePath
}

// Display the preview image 
setPreview(md(`![Preview Image](${await generatePreview(width, outputFormat)})`))

// Prompt the user for confirmation 
const shouldResize = await arg("Resize?", ["Yes", "No"]) 

if (shouldResize === "Yes") {
  // Resize the original image 
  await sharp(imagePath)
    .resize({ width })
    .toFormat(outputFormat) 
    .toFile(imagePath.replace(/\.(jpg|jpeg|png|gif|webp)$/, `.${outputFormat}`)) 

  // Display a notification
  await notify("Image resized!", `${imagePath}`) 
} 
```

## Get Commit History for a File

```typescript
// Name: Get File Commit History 
// Description: Retrieves and displays the commit history for a selected file
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt the user to select a file
const filePath = await path()

// Get the commit history for the selected file using git log 
const { stdout: commitHistory } = await exec(`git log --pretty="%h - %s - %an" --follow -- "${filePath}"`, {
  shell: true,
})

// Display the commit history in the editor 
await editor(commitHistory, {
  language: "text",
})
```

##  Create a New Trello Card

```typescript
// Name: Create Trello Card
// Description: Creates a new Trello card 
// Author: johnlindquist

import "@johnlindquist/kit"

// Get Trello API credentials and list ID from environment variables 
// You can get your API key and token here: https://trello.com/app-key 
const TRELLO_API_KEY = await env("TRELLO_API_KEY") 
const TRELLO_API_TOKEN = await env("TRELLO_API_TOKEN")
// You can get the List ID from the URL of the Trello list
const TRELLO_LIST_ID = await env("TRELLO_LIST_ID")

// Prompt for the card name
const cardName = await arg("Enter card name:") 

// Prompt for the card description 
const cardDescription = await arg("Enter card description:")

// Construct the API URL 
const apiUrl = `https://api.trello.com/1/cards?idList=${TRELLO_LIST_ID}&name=${encodeURIComponent(cardName)}&desc=${encodeURIComponent(
  cardDescription
)}&key=${TRELLO_API_KEY}&token=${TRELLO_API_TOKEN}`

// Send the request to create the new Trello card
await get(apiUrl) 

// Display a confirmation message
await div(md(`## Trello card created!`)) 
```

## Get User's Spotify Playlists

```typescript
// Name: Get Spotify Playlists
// Description: Displays a list of the user's Spotify playlists
// Author: johnlindquist

import "@johnlindquist/kit"
import SpotifyWebApi from "spotify-web-api-node" 

// Get Spotify API credentials from environment variables
// You can get client ID and client secret here: https://developer.spotify.com/dashboard/applications 
const SPOTIFY_CLIENT_ID = await env("SPOTIFY_CLIENT_ID")
const SPOTIFY_CLIENT_SECRET = await env("SPOTIFY_CLIENT_SECRET") 

// Create a new Spotify API client
const spotifyApi = new SpotifyWebApi({
  clientId: SPOTIFY_CLIENT_ID,
  clientSecret: SPOTIFY_CLIENT_SECRET,
  redirectUri: "http://localhost:8888/callback", // Define a redirect URI for authentication 
})

// Retrieve an access token for the Spotify API 
const { body: { access_token } } = await spotifyApi.clientCredentialsGrant()
spotifyApi.setAccessToken(access_token) 

// Get the user's playlists 
const { body: { items: playlists } } = await spotifyApi.getUserPlaylists(await env("SPOTIFY_USERNAME"), { // Set your Spotify username in the environment variable
  limit: 50, // Limit the number of playlists retrieved
})

// Display the list of playlists in a div
await div(
  md(`
## Your Spotify Playlists:

${playlists.map(playlist => `- [${playlist.name}](${playlist.external_urls.spotify})`).join("\n")}
`) 
)
```

## Check Domain Availability

```typescript
// Name: Domain Checker
// Description: Checks if a domain name is available
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt for the domain name 
const domainName = await arg("Enter domain name to check:")

// Construct the API URL using the whoisxmlapi.com API
const apiUrl = `https://domain-availability-api.whoisxmlapi.com/api/v1?apiKey=${await env(
  "WHOISXMLAPI_KEY"
)}&domainName=${domainName}`
// Get your API key here: https://whoisxmlapi.com/

// Fetch domain availability data from the API
const response = await get(apiUrl)

// Extract availability information 
const isAvailable = response.data.DomainInfo.domainAvailability === "AVAILABLE"

// Display the domain availability status
await div(md(`## Domain Availability: ${isAvailable ? "Available ðŸŽ‰" : "Unavailable ðŸ˜”"}`)) 
```

## Convert Text to QR Code

```typescript
// Name: Text to QR Code
// Description: Generates a QR code from text and saves it as an image
// Author: johnlindquist 

import "@johnlindquist/kit"
import qrcode from "qrcode" 

// Prompt for the text to encode in the QR code 
const text = await arg("Enter text to encode:")

// Prompt for the output file path 
const outputFilePath = await path({
  // Suggest a filename based on the input text, truncated to 20 characters
  startPath: home("Downloads", truncate(text.replace(/\s/g, "_"), 20) + ".png"), 
})

// Generate the QR code and save it as a PNG image
await qrcode.toFile(outputFilePath, text) 

// Display a notification 
await notify("QR code generated!", `Saved to ${outputFilePath}`) 

// Reveal the generated QR code image in Finder 
await revealFile(outputFilePath)
```

##  Get Trending Topics on Twitter

```typescript
// Name: Trending Topics on Twitter 
// Description: Displays trending topics on Twitter 
// Author: johnlindquist

import "@johnlindquist/kit"
import TwitterApi from "twitter-api-v2"

// Retrieve Twitter API credentials from environment variables 
// You can create API keys and tokens here: https://developer.twitter.com/en/portal/dashboard
const TWITTER_BEARER_TOKEN = await env("TWITTER_BEARER_TOKEN")

// Create a new instance of the Twitter API client 
const twitterClient = new TwitterApi(TWITTER_BEARER_TOKEN)

// Prompt for the location's WOEID (Where On Earth ID)
// You can find a location's WOEID using Twitter's API or online resources 
const woeId = await arg("Enter location's WOEID:")

// Fetch trending topics for the specified location 
const { data: trends } = await twitterClient.v2.trendsPlace(woeId) 

// Display trending topics in a div
await div(
  md(`
## Trending Topics: 

${trends[0].trends.map(trend => `- ${trend.name}`).join("\n")} 
`)
)
```


## Merge and Split PDF Pages

```typescript
// Name: PDF Page Manager
// Description: Merges or splits PDF pages based on user selection
// Author: johnlindquist

import "@johnlindquist/kit"
import PDFMerge from "pdf-merge" 
import { PDFDocument } from "pdf-lib"

// Prompt the user to select an action
const action = await arg("Select an action:", ["Merge PDFs", "Split PDF"])

if (action === "Merge PDFs") {
  // Prompt the user to select multiple PDF files
  let selectedFilePaths = await getSelectedFile()
  // If no files are selected, prompt the user to drop files
  if (!selectedFilePaths) {
    selectedFilePaths = await drop({
      placeholder: "Drop PDF files here...",
      multiple: true,
    }) 
    // Extract file paths from the dropped files
    selectedFilePaths = selectedFilePaths.map(file => file.path)
  } else {
    // Split the selected file paths into an array
    selectedFilePaths = selectedFilePaths.split("\n")
  }

  // Prompt the user for the output file path
  const outputFilePath = await path({ 
    startPath: home("Downloads"), 
  }) 

  // Merge the PDFs using the pdf-merge library
  await PDFMerge(selectedFilePaths, { output: outputFilePath }).then(buffer => {
    console.log("PDFs merged successfully!") 
  })
  
  // Reveal the merged PDF in Finder
  await revealFile(outputFilePath)

} else if (action === "Split PDF") {
  // Prompt the user to select a PDF file 
  const pdfFilePath = await path({
    filters: [{ name: "PDF Files", extensions: ["pdf"] }],
  }) 

  // Load the PDF document
  const pdfDoc = await PDFDocument.load(await readFile(pdfFilePath)) 

  // Prompt for the page number to split at
  const splitPageNumber = parseInt(await arg("Enter page number to split at:")) 

  // Split the PDF into two documents
  const [firstPart, secondPart] = await pdfDoc.split(splitPageNumber)

  // Save the split PDFs
  const outputDir = path.dirname(pdfFilePath)
  await writeFile(path.join(outputDir, "part1.pdf"), await firstPart.save()) 
  await writeFile(path.join(outputDir, "part2.pdf"), await secondPart.save()) 

  // Display a notification
  await notify("PDF split successfully!") 
}
```

##  Get Latest News Headlines

```typescript
// Name: News Headlines
// Description: Displays the latest news headlines from a news source
// Author: johnlindquist

import "@johnlindquist/kit"
import { JSDOM } from "jsdom" 

// Prompt for the news source URL 
const newsSourceUrl = await arg("Enter news source URL:")

// Fetch the HTML content from the news source URL
const response = await get(newsSourceUrl) 

// Parse the HTML content 
const dom = new JSDOM(response.data)

// Extract headlines and links from the parsed HTML (adjust selectors based on the website's structure)
const headlines = Array.from(dom.window.document.querySelectorAll("article h2 a")).map((a) => ({
  title: a.textContent.trim(),
  url: a.href,
})) 

// Prompt the user to select a headline to open 
const selectedHeadline = await arg(
  {
    placeholder: "Select a headline",
    enter: "Open in Browser",
  },
  headlines
) 

// Open the selected headline in the browser
await browse(selectedHeadline)
```

## Convert Video to Slow Motion

```typescript
// Name: Slow Motion Video Converter
// Description: Converts a video to slow motion using ffmpeg 
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user to select a video file
const videoFilePath = await path({
  filters: [{ name: "Videos", extensions: ["mp4", "mov", "avi", "mkv"] }],
})

// Prompt for the desired slow motion factor (e.g., 0.5 for half speed, 0.25 for quarter speed) 
const slowMotionFactor = parseFloat(await arg("Enter slow motion factor (e.g., 0.5):"))

// Extract the directory and file name from the selected path
const { dir, name } = path.parse(videoFilePath)

// Construct the output file path for the slow motion video
const outputFilePath = path.join(dir, `${name}-slowmo.mp4`) 

// Use ffmpeg to create a slow motion video, setting the output framerate based on the slow motion factor
await exec(`ffmpeg -y -i '${videoFilePath}' -filter:v 'setpts=${slowMotionFactor}*PTS' -r ${25 * slowMotionFactor} '${outputFilePath}'`, {
  shell: true, 
})

// Display a notification
await notify("Slow motion video created!", `Saved to ${outputFilePath}`) 

// Reveal the slow motion video in Finder
await revealFile(outputFilePath)
```

## Get Code Complexity for a Directory

```typescript
// Name: Directory Code Complexity Checker
// Description: Checks the complexity of JavaScript code in a directory using eslint 
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user to select a directory
const directoryPath = await path({
  onlyDirs: true, // Only allow selecting directories
}) 

// Recursively find all JavaScript files in the directory
const filePaths = await globby([`${directoryPath}/**/*.js`])

// Display a message indicating the start of the analysis
await div(md(`# Analyzing code complexity...`)) 

// Check code complexity for each file using ESLint with the complexity plugin
for (const filePath of filePaths) {
  // Execute ESLint with complexity plugin
  let { stdout: complexityResult } = await exec(`npx eslint --plugin complexity --rule 'complexity: [2, 10]' --format json '${filePath}'`, {
    shell: true,
  })
  // Parse the ESLint result
  const complexityReport = JSON.parse(complexityResult) 

  // Extract messages from the report
  const messages = complexityReport[0].messages

  // Display complexity warnings for each file in separate divs 
  if (messages.length > 0) { 
    let html = `
    <h2>Complexity warnings for ${filePath}:</h2>
    <ul>
      ${messages
        .map(
          message =>
            `<li>${message.message} - Line: ${message.line}, Column: ${message.column}</li>`
        )
        .join("")} 
    </ul> 
    `
    await div(html)
  }
}

// Display a completion message
await div(md(`## Code complexity analysis complete!`)) 
```

## Create and Send HTML Email

```typescript
// Name: Send HTML Email 
// Description: Creates and sends an HTML email using Nodemailer
// Author: johnlindquist 

import "@johnlindquist/kit" 
import nodemailer from "nodemailer" 

// Get email credentials from environment variables 
// You can create an app password here: https://support.google.com/accounts/answer/185833?hl=en 
const emailUser = await env("EMAIL_USER") 
const emailPassword = await env("EMAIL_PASSWORD")

// Create a Nodemailer transporter
const transporter = nodemailer.createTransport({
  service: "gmail",
  auth: {
    user: emailUser,
    pass: emailPassword,
  }, 
})

// Prompt for recipient email address
const to = await arg("Enter recipient email address:")

// Prompt for the email subject 
const subject = await arg("Enter email subject:")

// Create the email content using the editor with HTML syntax highlighting 
const htmlContent = await editor({
  placeholder: "Enter email content (HTML):", 
  language: "html",
}) 

// Define email options 
const mailOptions = {
  from: emailUser, 
  to,
  subject,
  html: htmlContent, 
}

// Send the email
await transporter.sendMail(mailOptions) 

// Display a confirmation message
await div(md(`## HTML email sent successfully!`)) 
```

##  Generate Project Documentation Website

```typescript
// Name: Generate Docs Website
// Description: Generates a documentation website for a TypeScript project using TypeDoc 
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the documentation theme 
const theme = await arg("Select documentation theme:", [
  "default",
  "minimal",
  "sidebar",
  "navigator", 
])

// Generate the documentation website using TypeDoc with the selected theme
await exec(`npx typedoc --out docs src --theme ${theme}`, {
  // Set the current working directory to the project root 
  cwd: ".",
  shell: true,
})

// Display a confirmation message
await div(md(`## Documentation website generated in the 'docs' directory!`)) 

// Open the documentation website in the browser
await browse(`file://${path.resolve("docs", "index.html")}`) 
```

##  Download a File from a URL

```typescript
// Name: Download File
// Description: Downloads a file from a URL and saves it to the Downloads directory
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt for the file URL 
const fileUrl = await arg("Enter file URL:") 

// Download the file using the download utility 
await download(fileUrl, home("Downloads")) 

// Display a confirmation message with the downloaded file path 
await div(md(`## File downloaded to: ${path.join(home("Downloads"), path.basename(fileUrl))}`))
```
## Get System Network Information

```typescript
// Name: Get Network Info
// Description: Displays the system's network information
// Author: johnlindquist

import "@johnlindquist/kit"
import si from "systeminformation"

// Get network information using the systeminformation library
const networkInterfaces = await si.networkInterfaces()

// Format network interface information 
const networkInfo = networkInterfaces.map((iface) => `
### Interface: ${iface.iface}

* IP Address: ${iface.ip4} 
* MAC Address: ${iface.mac}
* Type: ${iface.type}
`).join("\n")

// Display the formatted network information in a div
await div(md(networkInfo))
```

## Convert Text to Morse Code

```typescript
// Name: Text to Morse Code Converter
// Description: Converts text to Morse code
// Author: johnlindquist

import "@johnlindquist/kit" 
import morse from "morse-code-converter"

// Prompt the user for text input 
const text = await arg("Enter text to convert to Morse code:")

// Convert the text to Morse code using morse-code-converter
const morseCode = morse.textToMorse(text)

// Display the Morse code in a div 
await div(md(`## Morse Code:\n\n${morseCode}`))

// Copy the Morse code to the clipboard
await copy(morseCode)
```

## Create New GitHub Project

```typescript
// Name: Create GitHub Project
// Description: Creates a new project on GitHub
// Author: johnlindquist

import "@johnlindquist/kit"
import { Octokit } from "@octokit/rest"

// Get GitHub authentication token from environment variables 
// You can get a token from here: https://github.com/settings/tokens
const githubToken = await env("GITHUB_TOKEN") 

// Prompt the user to select an organization or user
const ownerType = await arg("Create project for:", ["Organization", "User"])

let owner = ""
if (ownerType === "Organization") { 
  // Prompt for the organization name
  owner = await arg("Enter organization name:")
} else {
  // Get the current authenticated user's login
  let user = await getUserJson()
  owner = user.login 
} 

// Create a new Octokit instance
const octokit = new Octokit({
  auth: githubToken,
})

// Prompt for the project name
const projectName = await arg("Enter project name:")

// Create the new project on GitHub 
const { data: newProject } = await octokit.projects.createForOrg({ 
  org: owner,
  name: projectName, 
}) 

// Display a confirmation message with the project URL
await div(md(`## Project created at: ${newProject.html_url}`))

// Open the newly created project in the browser
await browse(newProject.html_url)
```

## Check if Process is Running

```typescript
// Name: Process Checker 
// Description: Checks if a process is running by its name 
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt the user for the process name 
const processName = await arg("Enter process name:")

// Get a list of running processes
const processes = await getProcesses()

// Check if a process with the given name is running 
const isRunning = processes.some(process => process.name === processName)

// Display the process status
if (isRunning) { 
  await div(md(`## Process "${processName}" is running.`))
} else {
  await div(md(`## Process "${processName}" is not running.`))
} 
```

## Create and Send HTML Email with Template

```typescript
// Name: Send Templated HTML Email
// Description: Creates and sends a templated HTML email using Nodemailer and Handlebars
// Author: johnlindquist

import "@johnlindquist/kit"
import nodemailer from "nodemailer" 

// Get email credentials from environment variables 
// You can create an app password here: https://support.google.com/accounts/answer/185833?hl=en
const emailUser = await env("EMAIL_USER")
const emailPassword = await env("EMAIL_PASSWORD") 

// Create a Nodemailer transporter
const transporter = nodemailer.createTransport({
  service: "gmail",
  auth: {
    user: emailUser,
    pass: emailPassword,
  },
})

// Prompt for the recipient's email address 
const to = await arg("Enter recipient email address:")

// Prompt for the email subject
const subject = await arg("Enter email subject:") 

// Prompt the user to select an email template 
const templateFile = await path({
  filters: [{ name: "HTML Templates", extensions: ["html"] }],
})

// Read the contents of the selected template
const templateContent = await readFile(templateFile, "utf-8") 

// Compile the template using Handlebars 
const template = compile(templateContent)

// Prompt for data to use in the template
const templateData = await arg("Enter template data (JSON format):")

// Parse the template data as JSON
const data = JSON.parse(templateData) 

// Render the HTML content using the template and data
const htmlContent = template(data)

// Define email options
const mailOptions = {
  from: emailUser, 
  to,
  subject, 
  html: htmlContent,
} 

// Send the email
await transporter.sendMail(mailOptions) 

// Display a confirmation message
await div(md(`## Templated HTML email sent successfully!`))
```

##  Resize and Optimize Images in Bulk

```typescript
// Name: Bulk Image Optimizer
// Description: Resizes and optimizes images in a directory
// Author: johnlindquist

import "@johnlindquist/kit"
import sharp from "sharp"

// Prompt the user to select a directory
const directoryPath = await path({
  onlyDirs: true, // Only allow selecting directories
})

// Prompt for the desired width
const width = parseInt(await arg("Enter desired width (px):"))

// Get all image files in the directory 
const imageFiles = await globby([`${directoryPath}/*.{jpg,jpeg,png,gif,webp}`])

// Display a progress bar during processing 
let progress = 0 
const progressBar = await div(md(`# Resizing Images

${progress}%`))

// Resize and optimize each image
for (const imagePath of imageFiles) { 
  // Resize the image using sharp, preserving the original format
  await sharp(imagePath)
    .resize({ width })
    .toFormat(path.extname(imagePath).slice(1))
    .toFile(imagePath)

  // Update the progress bar 
  progress = Math.floor((imageFiles.indexOf(imagePath) / imageFiles.length) * 100)
  progressBar.setState({
    html: md(`# Resizing Images 

    ${progress}%`) 
  })
}

// Close the progress bar and display a notification 
progressBar.close()
await notify("Images resized and optimized!", `in ${directoryPath}`)
```

##  Compare Two Files

```typescript
// Name: File Comparator
// Description: Compares two files and displays the differences 
// Author: johnlindquist

import "@johnlindquist/kit" 
import { diffLines } from "diff" 

// Prompt the user to select the first file
const file1Path = await path() 

// Prompt the user to select the second file 
const file2Path = await path()

// Read the contents of both files 
const file1Content = await readFile(file1Path, "utf-8")
const file2Content = await readFile(file2Path, "utf-8")

// Compare the files line by line using diff
const diffResult = diffLines(file1Content, file2Content)

// Generate HTML to display the differences, highlighting added and removed lines
let diffHtml = `<pre class="whitespace-pre-wrap">`

for (const part of diffResult) {
  // Add or remove lines based on diff result
  if (part.added) {
    diffHtml += `<span style="color: green;">+${part.value}</span>` 
  } else if (part.removed) {
    diffHtml += `<span style="color: red;">-${part.value}</span>` 
  } else {
    diffHtml += `<span>${part.value}</span>` 
  }
}

// Close the <pre> tag
diffHtml += `</pre>` 

// Display the differences in a div
await div(diffHtml)
```


## Remove Background from Image

```typescript
// Name: Remove Image Background
// Description: Removes the background from an image using the remove.bg API
// Author: johnlindquist

import "@johnlindquist/kit" 

// Get your API key from here: https://www.remove.bg/
const REMOVE_BG_API_KEY = await env("REMOVE_BG_API_KEY")

// Prompt the user to select an image
const imagePath = await path({
  filters: [{ name: "Images", extensions: ["jpg", "jpeg", "png"] }], 
}) 

// Create a FormData object to send the image to the API
const formData = new FormData() 
formData.append("image_file", createReadStream(imagePath), path.basename(imagePath)) 

// Send the image to the remove.bg API 
const response = await fetch(
  "https://api.remove.bg/v1.0/removebg",
  {
    method: "POST",
    body: formData,
    headers: {
      "X-Api-Key": REMOVE_BG_API_KEY, 
    },
  }
) 

// Save the processed image to a file
const outputImagePath = imagePath.replace(/\.(jpg|jpeg|png)$/, "-nobg.$1") 
await writeFile(outputImagePath, Buffer.from(await response.arrayBuffer()))

// Display a confirmation message
await div(md(`## Background removed!`))

// Reveal the image with the background removed in Finder
await revealFile(outputImagePath) 
```

## Search and Open Stack Overflow Question

```typescript
// Name: Search Stack Overflow
// Description: Searches for a question on Stack Overflow and opens it in the browser
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt for the search query
const query = await arg("Enter your Stack Overflow search query:")

// Encode the query for use in the URL 
const encodedQuery = encodeURIComponent(query) 

// Construct the Stack Overflow search URL 
const searchUrl = `https://stackoverflow.com/search?q=${encodedQuery}`

// Fetch search results from the Stack Overflow API 
const response = await get(`https://api.stackexchange.com/2.3/search/advanced?order=desc&sort=relevance&q=${encodedQuery}&site=stackoverflow`) 

// Extract question URLs from the response
const questionUrls = response.data.items.map((item) => item.link) 

// Display a list of questions and prompt the user to select one 
const selectedQuestionUrl = await arg("Select a question:", questionUrls) 

// Open the selected question in the browser
await browse(selectedQuestionUrl) 
```

## Get Current Location's Time

```typescript
// Name: Get Local Time
// Description: Displays the current time at the user's location
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the user's current location using the browser's geolocation API 
const { coords } = await new Promise<GeolocationPosition>((resolve, reject) => {
  navigator.geolocation.getCurrentPosition(resolve, reject)
}) 

// Fetch timezone information from the Google Time Zone API
const response = await get(
  `https://maps.googleapis.com/maps/api/timezone/json?location=${coords.latitude},${coords.longitude}&timestamp=${Date.now() / 1000}&key=${await env(
    "GOOGLE_MAPS_API_KEY"
  )}`
) 
// You can get a Google Maps API key here: https://developers.google.com/maps/documentation/javascript/get-api-key

// Extract the timezone name and raw offset from UTC (in seconds)
const { timeZoneId: timezone, rawOffset } = response.data 

// Calculate the time at the user's location
const localTime = new Date(Date.now() + rawOffset * 1000) 

// Format the time as a string 
const formattedTime = localTime.toLocaleTimeString([], { 
  // Show hours, minutes, and seconds 
  hour: "2-digit",
  minute: "2-digit",
  second: "2-digit", 
})

// Display the time and timezone in a div
await div(md(`## The current time in ${timezone} is: ${formattedTime}`))
```

## Resize and Convert Images in Bulk

```typescript
// Name: Bulk Image Converter
// Description: Converts and resizes images in a directory to a specified format and width
// Author: johnlindquist 

import "@johnlindquist/kit"
import sharp from "sharp"

// Prompt the user to select a directory 
const directoryPath = await path({
  onlyDirs: true, // Only allow selecting directories
})

// Prompt for the desired output format 
const outputFormat = await arg("Enter output format (e.g., png, webp):")

// Prompt for the desired width
const width = parseInt(await arg("Enter desired width (px):")) 

// Get all image files in the directory 
const imageFiles = await globby([`${directoryPath}/*.{jpg,jpeg,png,gif,webp}`]) 

// Display a progress bar during processing 
let progress = 0
const progressBar = await div(md(`# Converting Images

${progress}%`))

// Convert and resize images 
for (const imagePath of imageFiles) {
  // Convert and resize the image using sharp
  await sharp(imagePath)
    .resize({ width }) 
    .toFormat(outputFormat)
    .toFile(imagePath.replace(/\.(jpg|jpeg|png|gif|webp)$/, `-${width}.${outputFormat}`)) 

  // Update the progress bar 
  progress = Math.floor((imageFiles.indexOf(imagePath) / imageFiles.length) * 100) 
  progressBar.setState({
    html: md(`# Converting Images

    ${progress}%`),
  })
}

// Close the progress bar and display a notification 
progressBar.close() 
await notify("Images converted and resized!", `in ${directoryPath}`) 
```

##  Get Trending Reddit Posts

```typescript
// Name: Reddit Trending Posts 
// Description: Displays trending posts from a subreddit 
// Author: johnlindquist

import "@johnlindquist/kit"
import snoowrap from "snoowrap" 

// Get your Reddit API credentials from here: https://www.reddit.com/prefs/apps 
const REDDIT_CLIENT_ID = await env("REDDIT_CLIENT_ID") 
const REDDIT_CLIENT_SECRET = await env("REDDIT_CLIENT_SECRET") 
const REDDIT_USERNAME = await env("REDDIT_USERNAME")
const REDDIT_PASSWORD = await env("REDDIT_PASSWORD") 

// Create a new Snoowrap instance
const reddit = new snoowrap({ 
  userAgent: "ScriptKitApp",
  clientId: REDDIT_CLIENT_ID,
  clientSecret: REDDIT_CLIENT_SECRET, 
  username: REDDIT_USERNAME, 
  password: REDDIT_PASSWORD, 
}) 

// Prompt for the subreddit name
const subredditName = await arg("Enter subreddit name:") 

// Fetch the hot (trending) posts from the specified subreddit
const hotPosts = await reddit.getSubreddit(subredditName).getHot({ limit: 10 }) 

// Create choices from the fetched posts, including a preview
const postChoices = hotPosts.map((post) => ({
  name: post.title, 
  value: post.url,
  // Display a preview of the post content
  preview: async () => { 
    if (post.is_self) {
      // If it's a text post, display the selftext (post body)
      return md(post.selftext)
    } else {
      // If it's a link post, display the link URL and a preview image if available
      return md(`[${post.url}](${post.url})\n\n${post.preview?.images[0]?.source?.url ? `<img src="${post.preview.images[0].source.url}" alt="${post.title}" />` : ""}`) 
    } 
  },
})) 

// Prompt the user to select a post
const selectedPostUrl = await arg({
  placeholder: "Select a post",
  enter: "Open in Browser", 
}, postChoices) 

// Open the selected post in the browser
await browse(selectedPostUrl) 
```

## Check Spelling and Grammar

```typescript
// Name: Spelling and Grammar Checker
// Description: Checks for spelling and grammar errors in text using LanguageTool
// Author: johnlindquist 

import "@johnlindquist/kit" 
import LanguageTool from "languagetool-api"

// Prompt for the text to check
const text = await editor({
  placeholder: "Enter your text:",
})

// Create a new LanguageTool instance 
const languageTool = new LanguageTool({
  language: "en-US", // Set the language
})

// Check the text for spelling and grammar errors 
const { matches: errors } = await languageTool.check(text)

// Generate HTML for displaying the errors with suggestions
let errorsHtml = `
<h1>Spelling and Grammar Errors:</h1> 
<ul>
  ${errors.map(error => `
    <li>
      <p><b>${error.message}</b> (offset: ${error.offset}, length: ${error.length})</p> 
      <p>Suggestions: ${error.replacements.map(replacement => `"${replacement}"`).join(", ")}</p>
      <p>Context: ...${error.context.text.slice(0, error.context.offset)}<span style="color: red; text-decoration: underline;">${error.context.text.slice(error.context.offset, error.context.offset + error.length)}</span>${error.context.text.slice(error.context.offset + error.length)}...</p> 
    </li>
  `).join("")}
</ul>
`

if (errors.length > 0) { 
  // Display errors and suggestions
  await div(errorsHtml)
} else { 
  // Display a message if no errors are found
  await div(md(`## No spelling or grammar errors found! ðŸŽ‰`))
} 
```

##  Resize All Images in a Directory

```typescript
// Name: Resize All Images
// Description: Resizes all images in a directory to a specific width
// Author: johnlindquist

import "@johnlindquist/kit"
import sharp from "sharp"

// Prompt the user to select a directory
const directoryPath = await path({
  onlyDirs: true,
})

// Prompt the user for the new image width 
const width = parseInt(await arg("Enter new width (px):"))

// Get all images in the selected directory
const images = await globby([`${directoryPath}/*.{jpg,jpeg,png,gif,webp}`])

// Display a progress bar 
let progress = 0
const progressBar = await div(md(`# Resizing Images

${progress}%`))

// Loop through each image and resize
for (const imagePath of images) { 
  await sharp(imagePath).resize({ width }).toFile(imagePath); 

  // Update the progress bar 
  progress = Math.floor((images.indexOf(imagePath) / images.length) * 100) 
  progressBar.setState({
    html: md(`# Resizing Images 

    ${progress}%`),
  })
}

progressBar.close() 
```


## Create Screen Recording

```typescript
// Name: Screen Recorder 
// Description: Records a screen recording using the built-in screen recording functionality
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user to select the screen to record 
let screens = await getScreens()
let screenId = await arg("Select screen to record:", screens.map(s => s.id.toString()))

// Start the screen recording 
let filePath = await screenRecording.start({
  screenId: parseInt(screenId), // Specify the screen ID to record
})

// Prompt the user to stop recording
await div(
  md(`
## Recording... 

Press <kbd>Escape</kbd> to stop recording.
  `), 
  "flex flex-col items-center gap-2 justify-center text-center"
)

// Stop the screen recording when the user presses the escape key
onKeydown(async (event) => { 
  if (event.key === "Escape") {
    // Stop recording 
    await screenRecording.stop()
  }
})

// Reveal the recorded video in Finder
await revealFile(filePath)
```

## Get User's Public Instagram Posts

```typescript
// Name: Instagram Post Fetcher
// Description: Retrieves and displays the latest Instagram posts for a user 
// Author: johnlindquist 

import "@johnlindquist/kit"
import { IgApiClient } from "instagram-private-api" 

// Prompt for the Instagram username
const username = await arg("Enter Instagram username:") 

// Create a new Instagram API client 
const ig = new IgApiClient() 

// Login to Instagram (you might need to set up two-factor authentication for this to work) 
await ig.state.generateDevice(username) 
await ig.account.login(
  username,
  await env("INSTAGRAM_PASSWORD", {
    // Treat the password as a secret
    secret: true
  })
)

// Get the user's ID
const userId = await ig.user.getIdByUsername(username)

// Fetch the user's posts
const posts = await ig.feed.user(userId).request()

// Create choices from the post data
const postChoices = posts.items.map(post => ({
  name: post.caption?.text?.slice(0, 50) || "No Caption",
  description: new Date(post.taken_at * 1000).toLocaleString(),
  value: `https://www.instagram.com/p/${post.code}/`,
  // Display a preview of the post image
  preview: `<img src="${post.image_versions2.candidates[0].url}" alt="Instagram Post" />`,
}))

// Prompt the user to select a post to open
const selectedPost = await arg({
  placeholder: "Select an Instagram post to open",
  enter: "Open in Browser",
}, postChoices) 

// Open the selected post in the browser
await browse(selectedPost)
```

## Extract Images from a PDF 

```typescript
// Name: Extract PDF Images
// Description: Extracts images from a PDF file 
// Author: johnlindquist

import "@johnlindquist/kit" 
import { PDFImage } from "pdf-image" 

// Prompt the user to select a PDF file
const pdfFilePath = await path({
  filters: [{ name: "PDF Files", extensions: ["pdf"] }], 
})

// Create a new PDFImage instance
const pdfImage = new PDFImage(pdfFilePath)

// Get the image paths from the PDF 
const imagePaths = await pdfImage.extract() 

// Display the image paths in a div
await div(md(`
## Images extracted from PDF:

${imagePaths.map((imagePath, index) => `- Image ${index + 1}: ${imagePath}`).join("\n")} 
`))
```

##  Generate Password with Strength Check

```typescript
// Name: Generate Strong Password
// Description: Generates a strong password with a strength check
// Author: johnlindquist

import "@johnlindquist/kit" 
import zxcvbn from "zxcvbn"

// Prompt for the desired password length 
const passwordLength = parseInt(await arg("Enter desired password length:")) 

let password = ""
let passwordStrength = 0

// Generate passwords until a strong password is created
while (passwordStrength < 4) {
  // Generate a random password
  password = await $`openssl rand -base64 32 | tr -dc A-Za-z0-9_!@#$%^&*()_+~\\=\\[\\]\\{\\}\\|\\;\\:\\'\\"\\\,\\.\\<\\>\\/\\?\\\\' | head -c ${passwordLength}`.stdout.trim()
  // Check the password strength using zxcvbn
  const { score } = zxcvbn(password) 
  passwordStrength = score
}

// Copy the password to the clipboard
await copy(password) 

// Display a confirmation message
await div(md(`
## Strong password generated and copied to the clipboard! 

\`\`\`
${password}
\`\`\`
`))
```

## Convert Markdown to PDF

```typescript
// Name: Markdown to PDF Converter
// Description: Converts a Markdown file to PDF
// Author: johnlindquist 

import "@johnlindquist/kit"
import mdToPdf from "md-to-pdf"

// Prompt the user to select a Markdown file
const markdownFilePath = await path({
  filters: [{ name: "Markdown Files", extensions: ["md"] }], 
})

// Prompt for the output file path
const outputFilePath = await path({
  startPath: home("Downloads"), 
})

// Convert the Markdown file to PDF using md-to-pdf
await mdToPdf({ path: markdownFilePath }, { dest: outputFilePath }) 

// Display a confirmation message 
await div(md(`## Markdown converted to PDF!`)) 

// Reveal the PDF file in Finder
await revealFile(outputFilePath) 
```

## Generate File Hash

```typescript
// Name: File Hash Generator
// Description: Generates the SHA-256 hash of a file
// Author: johnlindquist

import "@johnlindquist/kit"
import { createHash } from "crypto"

// Prompt the user to select a file
const filePath = await path()

// Read the file content as a buffer
const fileBuffer = await readFile(filePath)

// Generate the SHA-256 hash of the file content
const fileHash = createHash("sha256").update(fileBuffer).digest("hex")

// Display the hash in a div 
await div(md(`## SHA-256 Hash:\n\n${fileHash}`))

// Copy the hash to the clipboard
await copy(fileHash)
```

## Send a Message to Discord

```typescript
// Name: Send Discord Message
// Description: Sends a message to a Discord channel using the discord.js library
// Author: johnlindquist

import "@johnlindquist/kit" 
import { Client, IntentsBitField } from "discord.js"

// Get your Discord Bot Token from here: https://discord.com/developers/applications
const DISCORD_BOT_TOKEN = await env("DISCORD_BOT_TOKEN")

// Prompt the user for the Discord channel ID
const channelId = await arg("Enter Discord channel ID:") 

// Prompt for the message to send
const message = await arg("Enter message:")

// Create a new Discord client instance
const client = new Client({ intents: [IntentsBitField.Flags.Guilds] })

// Log in to Discord using the bot token
client.login(DISCORD_BOT_TOKEN)

// Send the message to the specified channel once the client is ready
client.on("ready", () => { 
  // Find the channel by its ID
  const channel = client.channels.cache.get(channelId)

  // Send the message to the channel if it exists 
  if (channel?.isTextBased()) {
    channel.send(message)
      .then(() => console.log(`Message sent to channel ${channelId}`))
      .catch((error) => console.error("Error sending message:", error)) 
  } else {
    console.error("Channel not found or not a text channel.") 
  }

  // Disconnect from Discord
  client.destroy() 
}) 
```


## Convert Text to QR Code with Logo

```typescript
// Name: QR Code Generator with Logo
// Description: Generates a QR code with a custom logo image 
// Author: johnlindquist

import "@johnlindquist/kit"
import qrcode from "qrcode"

// Prompt for the text or URL to encode 
const data = await arg("Enter text or URL to encode:") 

// Prompt for the logo image path 
const logoImagePath = await path({ 
  filters: [{ name: "Images", extensions: ["jpg", "jpeg", "png"] }],
})

// Prompt for the output file path 
const outputFilePath = await path({
  startPath: home("Downloads"),
}) 

// Generate the QR code with the logo image 
await qrcode.toFile(outputFilePath, data, {
  // Specify the logo image path and other QR code options 
  logo: logoImagePath, 
  errorCorrectionLevel: "H", // Set error correction level for better readability
  width: 512,               // Set the width of the QR code
})

// Display a notification
await notify("QR code generated!", `Saved to ${outputFilePath}`)

// Reveal the QR code image in Finder 
await revealFile(outputFilePath)
```

## Extract ZIP Archive 

```typescript
// Name: Extract ZIP Archive
// Description: Extracts a ZIP archive to a selected directory 
// Author: johnlindquist

import "@johnlindquist/kit"
import extract from "extract-zip"

// Prompt the user to select a ZIP file
const zipFilePath = await path({ 
  filters: [{ name: "ZIP Archives", extensions: ["zip"] }], 
})

// Prompt the user to select the extraction destination directory 
const destinationPath = await path({
  onlyDirs: true,
})

// Extract the contents of the ZIP file to the selected directory 
await extract(zipFilePath, { dir: destinationPath })

// Display a notification
await notify("ZIP archive extracted!", `to ${destinationPath}`)

// Reveal the extracted files in Finder
await revealFile(destinationPath)
```

## Get System Disk Usage

```typescript
// Name: Disk Space Monitor
// Description: Displays the disk space usage for each mounted drive 
// Author: johnlindquist

import "@johnlindquist/kit"
import si from "systeminformation"

// Get disk layout information
const diskLayout = await si.diskLayout()

// Create an array of disk usage promises 
const diskUsagePromises = diskLayout.map(async (disk) => {
  // Get disk usage information for each disk
  const diskUsage = await si.fsSize({ fstype: disk.fstype })

  // Find the entry for the current disk
  const usage = diskUsage.find(usage => usage.fs === disk.fs)

  // Return disk usage information, including formatted size 
  return {
    name: disk.name, 
    mount: disk.mount,
    size: filesize(usage.size), 
    used: filesize(usage.used), 
    available: filesize(usage.available),
    use: usage.use, 
  }
})

// Resolve all disk usage promises
const diskUsages = await Promise.all(diskUsagePromises)

// Display the disk usage information in a div
await div(
  md(`
## Disk Usage:

${diskUsages.map(disk => `
### Disk: ${disk.name}

* Mount Point: ${disk.mount}
* Total Size: ${disk.size}
* Used: ${disk.used}
* Available: ${disk.available}
* Use%: ${disk.use}
`).join("\n")}
  `)
) 
```

##  Remove Duplicate Lines from Text

```typescript
// Name: Remove Duplicate Lines
// Description: Removes duplicate lines from selected text
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the selected text 
const selectedText = await getSelectedText() 

// Split the text into lines
const lines = selectedText.split("\n") 

// Remove duplicate lines, preserving the order
const uniqueLines = [...new Set(lines)]

// Join the unique lines back into a string
const newText = uniqueLines.join("\n") 

// Replace the selected text with the modified text 
await setSelectedText(newText) 

// Display a confirmation message
await div(md(`## Duplicate lines removed!`))
```

## Generate Project with create-react-app

```typescript
// Name: Generate React Project
// Description: Generates a new React project using create-react-app
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt for the project name
const projectName = await arg("Enter project name:")

// Create a new React project using create-react-app
await exec(`npx create-react-app ${projectName}`, { shell: true }) 

// Display a confirmation message
await div(md(`## React project created!`))

// Open the project directory in VS Code
await exec(`code ${projectName}`)
```

## Get User's Location

```typescript
// Name: Get Location
// Description: Gets the user's current location and displays it on a map
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the user's current location using the browser's geolocation API
const { coords } = await new Promise<GeolocationPosition>(
  (resolve, reject) => {
    navigator.geolocation.getCurrentPosition(resolve, reject) 
  }
)

// Construct the Google Maps URL
const mapUrl = `https://www.google.com/maps/search/?api=1&query=${coords.latitude},${coords.longitude}`

// Open the map URL in the browser 
await browse(mapUrl) 
```

## Convert Image to Grayscale

```typescript
// Name: Convert Image to Grayscale
// Description: Converts an image to grayscale
// Author: johnlindquist

import "@johnlindquist/kit"
import sharp from "sharp"

// Prompt the user to select an image
const imagePath = await path({
  filters: [{ name: "Images", extensions: ["jpg", "jpeg", "png"] }], 
})

// Convert the image to grayscale using sharp
await sharp(imagePath).grayscale().toFile(imagePath)

// Display a notification
await notify("Image converted to grayscale!", `${imagePath}`) 
```


## Check Current Weather with Voice Input

```typescript
// Name: Voice Weather
// Description: Get weather information using voice input
// Author: johnlindquist

import "@johnlindquist/kit"
import OpenAI from "openai"
import { Configuration, OpenAIApi } from "openai"

// Get your OpenAI API key here: https://beta.openai.com/account/api-keys
const OPENAI_API_KEY = await env("OPENAI_API_KEY")

// Get your OpenWeatherMap API key here: https://openweathermap.org/api
const OPENWEATHERMAP_API_KEY = await env("OPENWEATHERMAP_API_KEY")

const configuration = new Configuration({
  apiKey: OPENAI_API_KEY,
});
const openai = new OpenAIApi(configuration);

// Start recording audio from the microphone
const audioFilePath = await mic.start({
  // Optionally, display a placeholder while recording
  placeholder: "Speak your location...",
}) 

// Stop recording when the user releases the space key 
onKeyup(async (event) => { 
  if (event.key === "Space") { 
    await mic.stop() 
  }
}) 

// Read the recorded audio file
const audioBuffer = await readFile(audioFilePath)

// Convert speech to text using the OpenAI API 
const transcriptionResponse = await openai.audio.transcriptions.create({ 
  file: await toFile(audioBuffer, "audio.webm"), // Convert the buffer to a file
  model: "whisper-1",
})

// Extract the transcribed text
const location = transcriptionResponse.text.trim()

// Fetch weather data from the OpenWeatherMap API
const weatherResponse = await get(`https://api.openweathermap.org/data/2.5/weather?q=${location}&appid=${OPENWEATHERMAP_API_KEY}&units=metric`)

// Extract relevant weather information 
const { name, main, weather } = weatherResponse.data
const temperature = main.temp 
const description = weather[0].description 

// Display the weather information in a div
await div(
  md(`## Weather in ${name}:

* Temperature: ${temperature}Â°C 
* Description: ${description}
  `)
) 
```

## Convert Web Page to Markdown

```typescript
// Name: Web Page to Markdown Converter 
// Description: Converts the current web page to Markdown
// Author: johnlindquist

import "@johnlindquist/kit" 
import TurndownService from "turndown"

// Get the URL of the current active tab in Chrome
const url = await getActiveTab("Google Chrome")

// Fetch the HTML content of the webpage
const response = await get(url) 

// Create a new TurndownService instance
const turndownService = new TurndownService() 

// Convert the HTML content to Markdown using Turndown 
const markdown = turndownService.turndown(response.data)

// Display the Markdown in the editor
await editor(markdown, {
  language: "markdown",
})
```

## Get Code Coverage Report

```typescript
// Name: Get Code Coverage Report
// Description: Generates a code coverage report using Jest
// Author: johnlindquist

import "@johnlindquist/kit"

// Run Jest tests with code coverage enabled 
await exec(`npx jest --coverage`, { shell: true, cwd: "." })

// Open the generated coverage report in the browser 
await browse(`file://${path.resolve("coverage/lcov-report/index.html")}`) 
```

##  Check GitHub Profile Views

```typescript
// Name: GitHub Profile View Counter
// Description: Checks the number of views on your GitHub profile
// Author: johnlindquist

import "@johnlindquist/kit" 
import { Octokit } from "@octokit/rest"

// Get GitHub authentication token from environment variables
// You can get a token from here: https://github.com/settings/tokens 
const githubToken = await env("GITHUB_TOKEN") 

// Create a new Octokit instance
const octokit = new Octokit({
  auth: githubToken, 
})

// Fetch traffic data for the authenticated user's profile 
const { data: trafficData } = await octokit.repos.getViews({
  owner: (await getUserJson())?.login || "", // Use the logged-in user's username
  repo: "", // No repository is needed for profile views
})

// Extract the number of views 
const profileViews = trafficData.count

// Display the profile view count in a div
await div(md(`## Your GitHub profile has ${profileViews} views!`)) 
```

## Create and Deploy a Netlify Site

```typescript
// Name: Deploy to Netlify
// Description: Deploys a website to Netlify
// Author: johnlindquist

import "@johnlindquist/kit"
import { execaCommand } from "execa"

// Prompt for the site name 
const siteName = await arg("Enter site name:")

// Create a new Netlify site using the Netlify CLI
// Assumes you have the Netlify CLI installed: https://www.netlify.com/docs/cli/
await execaCommand(`netlify init --manual`, {
  // Use a custom shell
  shell: true, 
  // Set environment variables
  env: {
    NETLIFY_AUTH_TOKEN: await env("NETLIFY_AUTH_TOKEN"), // Get your Netlify Auth Token from here: https://app.netlify.com/user/applications#personal-access-tokens 
    NETLIFY_SITE_NAME: siteName,
  },
})

// Display a confirmation message 
await div(md(`## Site created on Netlify!`))

// Open the Netlify site dashboard in the browser 
await browse(`https://app.netlify.com/sites/${siteName}`) 
```

## Clean Up Downloaded Files

```typescript
// Name: Downloads Cleanup
// Description: Cleans up the Downloads directory
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user to select file types to clean up 
const fileTypes = await select(
  "Select file types to remove:",
  [
    ".zip", 
    ".dmg",
    ".pkg", 
    ".log", 
    ".tmp",
  ],
  {
    // Allow multiple selections
    multiple: true, 
  }
)

// Construct the glob patterns for the selected file types
const globPatterns = fileTypes.map((fileType) => `${home("Downloads")}/*${fileType}`)

// Remove files matching the selected file types
await trash(globPatterns, { glob: true }) 

// Display a confirmation message
await div(md(`## Downloads cleaned up!`)) 
```

##  Check Website Performance

```typescript
// Name: Website Performance Checker
// Description: Checks the performance of a website using PageSpeed Insights 
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the website URL
const websiteUrl = await arg("Enter website URL:")

// Fetch performance data from PageSpeed Insights API
const performanceData = await get(`https://www.googleapis.com/pagespeedonline/v5/runPagespeed?url=${websiteUrl}&strategy=mobile`)
// You'll need a Google API key for this to work, but you can run the report
// manually for now: https://pagespeed.web.dev/

// Extract relevant performance metrics
const {
  data: {
    lighthouseResult: {
      categories: { performance }, 
      audits,
    },
  }, 
} = performanceData

// Display the performance score 
await div(md(`## Performance Score: ${Math.round(performance.score * 100)}`))

// Display suggestions for improvement
const suggestions = [ 
  // "first-contentful-paint", 
  // "speed-index",
  "largest-contentful-paint",
  "interactive",
  // "total-blocking-time",
  "cumulative-layout-shift",
]

// Create an array of promises for fetching audit details 
const suggestionsHtml = (
  await Promise.all(
    suggestions.map(async s => {
      try {
        return `
  - **${audits[s].title}**: ${
          audits[s].displayValue
        } (<a href="${
          audits[s].description
        }">More info</a>)`
      } catch (error) {}
    })
  )
)
  .filter(Boolean)
  .join("\n")

await div(md(`## Suggestions:
  
${suggestionsHtml}
  `))
```
## Create and Schedule a Zoom Meeting

```typescript
// Name: Schedule Zoom Meeting
// Description: Creates and schedules a Zoom meeting using the Zoom API
// Author: johnlindquist

import "@johnlindquist/kit"

// Get Zoom API credentials from environment variables
// You can create API keys and tokens here: https://marketplace.zoom.us/develop/create
const ZOOM_API_KEY = await env("ZOOM_API_KEY")
const ZOOM_API_SECRET = await env("ZOOM_API_SECRET")

// Import the zoomus library for interacting with the Zoom API
import zoomus from "zoomus"

// Initialize the Zoom client
const zoom = zoomus({
  apiKey: ZOOM_API_KEY, 
  apiSecret: ZOOM_API_SECRET,
})

// Prompt for the meeting topic
const topic = await arg("Enter meeting topic:")

// Prompt for the meeting start time (in UTC)
const startTime = await arg(
  {
    placeholder: "Enter meeting start time (YYYY-MM-DDTHH:mm:ssZ):", 
    hint: "Example: 2024-03-20T10:00:00Z",
  }
)

// Create the Zoom meeting
const { data: meeting } = await new Promise((resolve, reject) => {
  zoom.meeting.create({ 
    topic,
    type: 2, // Scheduled meeting
    start_time: startTime,
    duration: 60, // Meeting duration in minutes (default: 60)
    timezone: "UTC", 
    password: generator.generate({ length: 10, numbers: true }), // Generate a random password for the meeting 
  },
  (error, meeting) => {
    if (error) { 
      reject(error) 
    } else { 
      resolve(meeting)
    }
  }) 
}) 

// Display the meeting join URL
await div(md(`## Join Zoom Meeting:\n\n${meeting.join_url}`)) 

// Copy the join URL to the clipboard 
await copy(meeting.join_url)
```

## Summarize Text from Clipboard

```typescript
// Name: Text Summarizer
// Description: Summarizes text from the clipboard using the OpenAI API
// Author: johnlindquist

import "@johnlindquist/kit" 
import OpenAI from "openai"

// Get your OpenAI API key from here: https://beta.openai.com/account/api-keys
const OPENAI_API_KEY = await env("OPENAI_API_KEY") 

// Create a new OpenAI instance 
const openai = new OpenAI({
  apiKey: OPENAI_API_KEY, 
})

// Get text from clipboard 
const text = await paste()

// Summarize the text using the OpenAI API 
const completion = await openai.completions.create({
  model: "text-davinci-003", 
  prompt: `Please summarize the following text:\n\n${text}`, 
  max_tokens: 100, // Limit the summary length
})

// Extract the summary from the API response
const summary = completion.choices[0].text

// Display the summary in a div 
await div(md(`
## Summary:

${summary} 
`))
```

## Generate Random Data for Testing

```typescript
// Name: Test Data Generator
// Description: Generates random data for testing purposes using Faker.js
// Author: johnlindquist 

import "@johnlindquist/kit" 
import { faker } from "@faker-js/faker" 

// Prompt for the data type to generate
const dataType = await arg("Select data type to generate:", [ 
  "Name",
  "Email",
  "Address",
  "Phone Number", 
]) 

// Generate data based on the selected data type
let generatedData = "";
switch (dataType) {
  case "Name":
    generatedData = faker.person.fullName(); 
    break
  case "Email": 
    generatedData = faker.internet.email() 
    break
  case "Address": 
    generatedData = faker.location.streetAddress(true)
    break 
  case "Phone Number": 
    generatedData = faker.phone.number()
    break
}

// Display the generated data in the editor 
await editor(generatedData, {
  language: "text", 
})
```

##  Clean Up Unused Docker Images

```typescript
// Name: Docker Image Cleanup 
// Description: Removes unused Docker images
// Author: johnlindquist

import "@johnlindquist/kit"

// Run the `docker image prune -a` command to remove unused Docker images, prompting for confirmation before proceeding 
let shouldPrune = await arg("Remove unused Docker images?", ["Yes", "No"])

if (shouldPrune === "Yes") {
  await exec(`docker image prune -a`, { shell: true }) 
  await div(md(`## Unused Docker images removed!`))
}
```

## Extract Audio from Video

```typescript
// Name: Extract Audio from Video
// Description: Extracts audio from a video file using ffmpeg
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user to select a video file
const videoFilePath = await path({
  filters: [{ name: "Videos", extensions: ["mp4", "mov", "avi", "mkv"] }], 
})

// Extract the directory and file name from the selected path 
const { dir, name } = path.parse(videoFilePath)

// Construct the output file path for the extracted audio 
const audioFilePath = path.join(dir, `${name}.mp3`)

// Extract audio from the video using ffmpeg 
await exec(`ffmpeg -i '${videoFilePath}' -vn -acodec libmp3lame '${audioFilePath}'`, { shell: true })

// Display a notification 
await notify("Audio extracted!", `Saved to ${audioFilePath}`)

// Reveal the extracted audio file in Finder
await revealFile(audioFilePath)
```

## Create and Share a Screenshot

```typescript
// Name: Capture and Share Screenshot 
// Description: Captures a screenshot and shares it as a link using Imgur
// Author: johnlindquist

import "@johnlindquist/kit"
import imgur from "imgur" 

// Get the Imgur client ID from environment variables
// You can get a Client ID here: https://api.imgur.com/oauth2/addclient
const IMGUR_CLIENT_ID = await env("IMGUR_CLIENT_ID")

// Set the Imgur client ID
imgur.setClientId(IMGUR_CLIENT_ID)

// Prompt the user to select the area for the screenshot
await div(md(`# Select Area for Screenshot`)) 
const screenshotPath = await captureScreen({
  formats: ["png"],
})

// Upload the screenshot to Imgur
const response = await imgur.uploadFile(screenshotPath) 

// Extract the image link from the response 
const imageUrl = response.data.link

// Display the image link in a div
await div(md(`## Screenshot Link:\n\n${imageUrl}`))

// Copy the link to the clipboard
await copy(imageUrl)
```

##  Generate Code Snippet with GitHub Copilot

```typescript
// Name: Generate Code Snippet
// Description: Generates a code snippet using GitHub Copilot 
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt for the desired programming language 
const language = await arg("Enter programming language:") 

// Prompt for a description of the desired code snippet 
const description = await arg("Enter code snippet description:") 

// Generate a code snippet using GitHub Copilot, pasting the description into the editor and triggering the Copilot suggestions 
await editor({
  // Set the language mode for syntax highlighting
  language,
  // Paste the description into the editor as a comment
  value: `// ${description}`, 
  // Move the cursor to the end of the description 
  scrollTo: "bottom",
  // Add a shortcut to accept the first Copilot suggestion 
  shortcuts: [
    {
      name: "Accept Suggestion",
      key: "tab", 
      onPress: async () => {
        // Trigger a tab key press to accept the suggestion 
        await keyboard.type(Key.Tab) 
      },
    }, 
  ], 
})
```


## Send Message to Discord Webhook

```typescript
// Name: Send Discord Webhook Message
// Description: Sends a message to a Discord webhook URL 
// Author: johnlindquist 

import "@johnlindquist/kit"

// Prompt for the Discord Webhook URL 
const webhookUrl = await env("DISCORD_WEBHOOK_URL", { 
  hint: `Get a Webhook URL from Discord's Channel settings -> Integrations -> Webhooks`
})

// Prompt for the message content 
const message = await arg("Enter message:") 

// Send the message to the Discord webhook using a POST request 
await post(webhookUrl, {
  content: message, 
}) 

// Display a confirmation message
await div(md(`## Message sent to Discord webhook!`)) 
```

## Combine Text Files

```typescript
// Name: Combine Text Files
// Description: Combines multiple text files into one
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the output file path
const outputFilePath = await path({
  startPath: home("Downloads"),
})

// Prompt the user to select or drop text files 
let inputFilePaths = await getSelectedFile()
// If no files are selected, prompt the user to drop files
if (!inputFilePaths) {
  inputFilePaths = await drop({
    placeholder: "Drop text files here...", 
    multiple: true, 
  }) 
  // Extract file paths from the dropped files 
  inputFilePaths = inputFilePaths.map(file => file.path) 
} else { 
  // Split the selected file paths into an array 
  inputFilePaths = inputFilePaths.split("\n") 
}

// Combine the content of the selected text files
let combinedContent = ""
for (const filePath of inputFilePaths) {
  combinedContent += await readFile(filePath, "utf-8") + "\n"
}

// Write the combined content to the output file
await writeFile(outputFilePath, combinedContent)

// Display a confirmation message 
await div(md(`## Files combined!`))

// Reveal the output file in Finder
await revealFile(outputFilePath)
```

## Create Animated GIF from Images

```typescript
// Name: GIF Creator
// Description: Creates an animated GIF from a sequence of images
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the output file path
const outputFilePath = await path({
  startPath: home("Downloads"), 
})

// Prompt for the directory containing the image sequence
const directoryPath = await path({
  onlyDirs: true, // Only allow selecting directories
}) 

// Prompt for the desired frames per second (FPS) for the GIF
const fps = parseInt(await arg("Enter frames per second (FPS):"))

// Generate the animated GIF using ffmpeg
await exec(`ffmpeg -y -framerate ${fps} -pattern_type glob -i '${directoryPath}/*.{jpg,jpeg,png}' -f gif '${outputFilePath}'`, { shell: true }) 

// Display a notification 
await notify("Animated GIF created!", `Saved to ${outputFilePath}`)

// Reveal the GIF file in Finder
await revealFile(outputFilePath)
```

## Check for Unused CSS

```typescript
// Name: Unused CSS Finder
// Description: Finds unused CSS classes in a project
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the project directory
const projectPath = await path({
  onlyDirs: true,
})

// Prompt for the glob pattern for HTML files
const htmlGlob = await arg({
  placeholder: "Enter glob pattern for HTML files (e.g., **/*.html):",
  // Provide a default value for the glob pattern 
  defaultValue: "**/*.html",
})

// Prompt for the glob pattern for CSS files
const cssGlob = await arg({
  placeholder: "Enter glob pattern for CSS files (e.g., **/*.css):",
  // Provide a default value for the glob pattern 
  defaultValue: "**/*.css",
})

// Run the PurgeCSS CLI to find unused CSS classes 
// This assumes you have PurgeCSS installed globally or locally: https://purgecss.com/ 
let { stdout: unusedCss } = await exec(`npx purgecss --content '${projectPath}/${htmlGlob}' --css '${projectPath}/${cssGlob}' --output -`, { shell: true })

// Display the unused CSS classes in the editor 
await editor(unusedCss, { language: "css" })
```

## Check Website for SSL Certificate Issues

```typescript
// Name: Check SSL Certificate
// Description: Checks the SSL certificate of a website 
// Author: johnlindquist

import "@johnlindquist/kit"
import sslCertificate from "get-ssl-certificate"

// Prompt for the website URL 
const url = await arg("Enter website URL:") 

// Retrieve SSL certificate information for the website
const certificateInfo = await sslCertificate.get(url)
  .catch(error => ({ valid_from: "Error", valid_to: "Error", subject: { C: "", CN: "" }})) // Handle errors gracefully

// Extract relevant information from the certificate 
const { valid_from, valid_to, subject: { C: country, CN: commonName } } = certificateInfo

// Display certificate details in a div
await div(
  md(`
## SSL Certificate for ${url}:

* Issued to: ${commonName} 
* Issued by: ${certificateInfo?.issuer?.C} ${certificateInfo?.issuer?.O} 
* Valid from: ${valid_from}
* Valid to: ${valid_to}
`)
)
```

## Extract Text from Images (OCR)

```typescript
// Name: Image to Text (OCR)
// Description: Extracts text from images using Tesseract OCR
// Author: johnlindquist

import "@johnlindquist/kit" 
import Tesseract from "tesseract.js" 

// Prompt the user to select an image or drop multiple images 
let imagePath = await getSelectedFile()
let imagePaths: string[] = []

// If no file is selected, prompt for file drops 
if (!imagePath) {
  const droppedFiles = await drop({
    placeholder: "Drop image files here...",
    multiple: true, 
  })

  // Extract file paths from dropped files 
  imagePaths = droppedFiles.map((file) => file.path)
} else {
  // If a file is selected, create an array with the single file path 
  imagePaths = [imagePath]
}

// Process each image 
for (const imagePath of imagePaths) {
  // Display a progress message 
  await div(md(`# Extracting text from: ${imagePath}`)) 

  // Perform OCR using Tesseract
  const { data: { text } } = await Tesseract.recognize(imagePath) 

  // Append extracted text to a temporary file
  const outputFilePath = tmpPath("extracted-text.txt")
  await appendFile(outputFilePath, `\n--- ${imagePath} ---\n${text}`) 
} 

// Display a notification and open the temporary file with extracted text 
await notify("Text extraction complete!") 
await edit(tmpPath("extracted-text.txt")) 
```

## Create and Deploy a Serverless Function

```typescript
// Name: Deploy Serverless Function
// Description: Deploys a serverless function to Vercel
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the function name
const functionName = await arg("Enter function name:")

// Create the directory for the function
await mkdir(functionName) 

// Change to the function directory 
cd(functionName)

// Create a basic "api/index.js" file 
await writeFile(
  "api/index.js",
  ` 
  export default (req, res) => {
    res.status(200).send("Hello from Vercel!")
  }
`
) 

// Initialize a new Vercel project
await exec(`npx vercel`, { shell: true })

// Deploy the function to Vercel
await exec(`npx vercel --prod`, { shell: true }) 

// Display a confirmation message
await div(md(`## Function deployed to Vercel!`))
```


## Create and Send a Gmail Draft

```typescript
// Name: Create Gmail Draft
// Description: Creates a new draft email in Gmail using the Gmail API
// Author: johnlindquist

import "@johnlindquist/kit"
import { google } from "googleapis"
import { JWT } from "google-auth-library"

// Get credentials for Google Service Account through environment variables
let SA_EMAIL = await env("GOOGLE_SA_EMAIL")
let SA_KEY = await env("GOOGLE_SA_CREDS")

// Define the scopes and client
let jwtClient = new JWT({
  email: SA_EMAIL,
  key: SA_KEY,
  scopes: ["https://www.googleapis.com/auth/gmail.compose"],
})

let gmail = google.gmail("v1")

// Function to create a draft email
async function createDraft(auth, to, subject, body) {
  // Encode the email subject and body
  const encodedSubject = Buffer.from(subject).toString("base64url")
  const encodedBody = Buffer.from(body).toString("base64url")

  // Create the email message in RFC 2822 format
  const raw = `To: ${to}\r\nSubject: =?utf-8?B?${encodedSubject}?= \r\nContent-Type: text/html; charset=utf-8\r\n\r\n${encodedBody}`

  // Create the draft using the Gmail API
  const response = await gmail.users.drafts.create({
    userId: "me",
    auth,
    requestBody: {
      message: {
        raw: Buffer.from(raw).toString("base64url"),
      },
    },
  })

  // Display the draft ID and a message
  console.log(`Draft ID: ${response.data.id}`)
  await div(md(`## Draft created successfully!`))
}

// Prompt for email details
let to = await arg("Enter recipient email address:")
let subject = await arg("Enter email subject:")
let body = await textarea({
  placeholder: "Enter email body:",
})

// Create the draft
await createDraft(jwtClient, to, subject, body)
```

## Generate TypeScript Documentation 

```typescript 
// Name: Generate TypeScript Docs 
// Description: Generates documentation for a TypeScript project using Typedoc
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt for the output directory for the documentation
const outputDir = await arg("Enter output directory for documentation:")

// Generate documentation using Typedoc, passing in the output directory and other options
await exec(`npx typedoc --out ${outputDir} --exclude '**/*.test.ts' --mode modules --theme default --ignoreCompilerErrors src`, { shell: true }) 

// Display a notification
await notify("Documentation generated!", `Saved to ${outputDir}`) 
```

## Check for GitHub Security Alerts

```typescript
// Name: GitHub Security Alert Checker
// Description: Checks for security alerts in a GitHub repository
// Author: johnlindquist

import "@johnlindquist/kit" 
import { Octokit } from "@octokit/rest"

// Get your GitHub Personal Access Token from: https://github.com/settings/tokens
const GITHUB_PERSONAL_ACCESS_TOKEN = await env("GITHUB_PERSONAL_ACCESS_TOKEN")

// Prompt for the repository name (owner/repo)
const repo = await arg("Enter repository name (owner/repo):") 

// Split the repo input into owner and repo name
const [owner, repoName] = repo.split("/") 

// Create a new Octokit instance
const octokit = new Octokit({
  auth: GITHUB_PERSONAL_ACCESS_TOKEN,
})

// Fetch security alerts for the specified repository 
const { data: alerts } = await octokit.repos.listVulnerabilityAlerts({
  owner,
  repo: repoName,
}) 

if (alerts.length > 0) {
  // Display security alerts in a div
  let alertHtml = `
  <h1>Security Alerts for ${repo}:</h1>
  <ul>
    ${alerts.map(alert => `
      <li>
        <a href="${alert.html_url}">${alert.securityAdvisory.summary}</a>
      </li>
    `).join("")}
  </ul>
  ` 
  await div(alertHtml) 
} else {
  // Display a message if no security alerts are found
  await div(md(`## No security alerts found for ${repo}! ðŸŽ‰`))
}
```

## Convert Video to Animated GIF

```typescript
// Name: Video to GIF Converter
// Description: Converts a video file to an animated GIF using ffmpeg
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user to select a video file
const videoFilePath = await path({
  filters: [{ name: "Videos", extensions: ["mp4", "mov", "avi", "mkv"] }], 
})

// Prompt for the start and end times for the GIF segment
const startTime = parseFloat(await arg("Enter start time (seconds):"))
const endTime = parseFloat(await arg("Enter end time (seconds):")) 

// Calculate the duration of the GIF segment 
const duration = endTime - startTime

// Extract the directory and file name from the selected video path
const { dir, name } = path.parse(videoFilePath)

// Create the output file path for the GIF
const outputFilePath = path.join(dir, `${name}.gif`) 

// Convert the video to an animated GIF using ffmpeg, specifying the start time, duration, and other options 
await exec(`ffmpeg -y -ss ${startTime} -t ${duration} -i "${videoFilePath}" -vf "fps=10,scale=480:-1:flags=lanczos,split[s0][s1];[s0]palettegen[p];[s1][p]paletteuse" -loop 0 "${outputFilePath}"`, {
  shell: true,
})

// Display a notification
await notify("Video converted to GIF!", `Saved to ${outputFilePath}`)

// Reveal the GIF in Finder
await revealFile(outputFilePath)
```

## Get System Network Usage

```typescript
// Name: Network Usage Monitor
// Description: Displays the current network usage
// Author: johnlindquist

import "@johnlindquist/kit" 
import si from "systeminformation"

// Create a widget to display the network usage
let networkWidget = await widget(`
<div class="p-4">
  <h2 class="text-xl">Network Usage</h2>
  <div class="flex flex-col gap-2">
    <div>
      <span class="font-bold">Download:</span> {{downloadSpeed}}/s
    </div> 
    <div>
      <span class="font-bold">Upload:</span> {{uploadSpeed}}/s
    </div> 
  </div> 
</div>
`, {
  width: 200, // Set a custom width for the widget 
})

// Update network usage every second 
setInterval(async () => {
  // Get the current network stats
  const networkStats = await si.networkStats() 

  // Get the current network interface
  const defaultInterface = networkStats.find(
    iface => iface.default
  )

  // Update the widget state with the download and upload speeds
  networkWidget.setState({
    downloadSpeed: filesize(defaultInterface.rx_sec),
    uploadSpeed: filesize(defaultInterface.tx_sec),
  }) 
}, 1000)
```

## Translate Text from Clipboard

```typescript
// Name: Clipboard Translator
// Description: Translates text from the clipboard
// Author: johnlindquist

import "@johnlindquist/kit" 
import translate from "@vitalets/google-translate-api" 

// Get text from clipboard
const text = await paste()

// Prompt the user for the target language code
const targetLanguage = await arg("Enter target language code (e.g., 'es' for Spanish):")

// Translate the text using google-translate-api
const { text: translatedText } = await translate(text, { to: targetLanguage })

// Copy the translated text to the clipboard
await copy(translatedText)

// Display a confirmation message
await div(md(`## Text translated and copied to the clipboard!`))
```

## Generate API Documentation

```typescript
// Name: Generate API Documentation
// Description: Generates API documentation for a Node.js project using Swagger
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user for the entry point file of the API 
const entryPoint = await arg("Enter API entry point file (e.g., index.js):")

// Generate API documentation using Swagger JSDoc
// This assumes you have Swagger JSDoc installed: https://www.npmjs.com/package/swagger-jsdoc
await exec(`npx swagger-jsdoc -d ./swagger.config.js -o ./docs`, {
  shell: true, 
  // Pass environment variables to the command
  env: {
    API_ENTRY_POINT: entryPoint, 
  },
})

// Display a confirmation message
await div(md(`## API documentation generated in the 'docs' directory!`))
```


## Convert Speech to Text with Real-time Transcription

```typescript
// Name: Live Transcribe
// Description: Transcribes speech from the microphone in real-time using the Deepgram API
// Author: johnlindquist

import "@johnlindquist/kit"
import Deepgram from "@deepgram/sdk"

// Get your Deepgram API key from here: https://console.deepgram.com/ 
const DEEPGRAM_API_KEY = await env("DEEPGRAM_API_KEY") 

// Create a Deepgram client 
const deepgram = new Deepgram.Deepgram(DEEPGRAM_API_KEY)

// Initialize the live transcription socket
const socket = deepgram.transcription.live({
  punctuate: true, // Enable punctuation in the transcript
  interim_results: true, // Include interim results (not yet finalized)
})

// Create an editor to display the transcript
const editorInstance = await editor({
  placeholder: "Transcript will appear here...",
  language: "text",
  // Disable automatic resizing to avoid flickering
  resize: false,
})

// Display a message indicating that the microphone is ready 
await div(md(`# Start speaking into the microphone...`))

// Connect to the microphone
await mic.start()

// Handle incoming transcript chunks
socket.on("transcriptReceived", (message) => {
  // Parse the transcript data
  const transcriptData = JSON.parse(message)

  // Extract the transcript from the data
  const transcript = transcriptData.channel.alternatives[0].transcript

  // Append the transcript to the editor
  editorInstance.append(transcript)
})

// Handle microphone stream data 
mic.stream.on("data", (chunk) => {
  // Send audio data to Deepgram for transcription
  socket.send(chunk)
})

// Stop transcription when the microphone stream ends
mic.stream.on("end", () => { 
  // Close the transcription socket
  socket.close()
}) 
```

## Find Large Files

```typescript
// Name: Large File Finder
// Description: Finds files larger than a specified size in a directory
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt the user to select a directory
const directoryPath = await path({ 
  onlyDirs: true,
})

// Prompt for the minimum file size in MB
const minSizeMB = parseFloat(await arg("Enter minimum file size (MB):"))

// Calculate the minimum file size in bytes
const minSizeBytes = minSizeMB * 1024 * 1024 

// Get files in the directory
const files = await globby([`${directoryPath}/**/*`], { onlyFiles: true }) 

// Filter files larger than the minimum size, including their sizes in the output
const largeFiles = (
  await Promise.all(
    files.map(async (file) => {
      const { size } = await stat(file) 
      return size > minSizeBytes ? { path: file, size } : null
    })
  )
)
  // Filter out null values
  .filter(Boolean)

// Sort large files by size in descending order
largeFiles.sort((a, b) => b.size - a.size) 

// Display the large files and their sizes in a div
await div(
  md(`
## Large Files:

${largeFiles.map(file => `- ${file.path} (${filesize(file.size)})`).join("\n")} 
  `)
)
```

## Send Email with Template and Data from Clipboard

```typescript
// Name: Send Templated Email from Clipboard
// Description: Sends an email using a template and data from the clipboard
// Author: johnlindquist

import "@johnlindquist/kit"
import nodemailer from "nodemailer" 
import Handlebars from "handlebars"

// Get email credentials from environment variables
// You can create an app password here: https://support.google.com/accounts/answer/185833?hl=en
const emailUser = await env("EMAIL_USER")
const emailPassword = await env("EMAIL_PASSWORD")

// Create a Nodemailer transporter
const transporter = nodemailer.createTransport({
  service: "gmail",
  auth: {
    user: emailUser,
    pass: emailPassword,
  },
}) 

// Prompt for the recipient's email address
const to = await arg("Enter recipient email address:")

// Prompt for the email subject
const subject = await arg("Enter email subject:")

// Prompt the user to select an HTML email template
const templateFile = await path({
  filters: [{ name: "HTML Templates", extensions: ["html"] }], 
})

// Read the contents of the selected template
const templateContent = await readFile(templateFile, "utf-8")

// Compile the template using Handlebars
const template = Handlebars.compile(templateContent)

// Get data from clipboard, assumed to be in JSON format
const clipboardData = await paste()

// Parse the clipboard data as JSON
const data = JSON.parse(clipboardData)

// Render the HTML content using the template and data 
const htmlContent = template(data) 

// Define email options 
const mailOptions = {
  from: emailUser,
  to, 
  subject,
  html: htmlContent,
}

// Send the email 
await transporter.sendMail(mailOptions) 

// Display a confirmation message
await div(md(`## Templated email sent successfully!`)) 
```

## Create and Manage To-Do List

```typescript
// Name: To-Do List Manager
// Description: Create and manage a to-do list 
// Author: johnlindquist

import "@johnlindquist/kit"

// Initialize a database to store the to-do list 
let toDos = await db({ todos: [] as { id: string; task: string; completed: boolean }[] })

// Function to display and manage the to-do list
const manageTodos = async () => {
  // Prompt the user to select a to-do item
  const selectedTodo = await arg(
    {
      placeholder: "Select a to-do item:", 
      // Allow the prompt to be resized
      resize: true,
      // Add actions to add, mark as complete, or remove to-do items 
      actions: [
        {
          name: "Add", 
          shortcut: `${cmd}+a`, 
          onAction: async () => {
            // Prompt for the new task 
            const newTask = await arg("Enter new task:")
            // Add the new task to the to-do list
            toDos.todos.push({ id: uuid(), task: newTask, completed: false }) 
            await toDos.write()
            // Refresh the to-do list prompt
            await manageTodos() 
          },
        }, 
        {
          name: "Toggle Complete",
          shortcut: `${cmd}+enter`,
          onAction: async (input, state) => {
            // Toggle the "completed" status of the selected to-do item
            const todo = toDos.todos.find(todo => todo.id === state.focused.id)
            if (todo) { 
              todo.completed = !todo.completed
              await toDos.write()
              // Refresh the to-do list prompt
              await manageTodos()
            }
          },
        },
        {
          name: "Remove",
          shortcut: `${cmd}+d`,
          onAction: async (input, state) => {
            // Remove the selected to-do item
            toDos.todos = toDos.todos.filter(todo => todo.id !== state.focused.id) 
            await toDos.write()
            // Refresh the to-do list prompt 
            await manageTodos()
          }, 
        }, 
      ], 
    },
    // Display the to-do list items as choices 
    toDos.todos.map(todo => ({
      name: `${todo.completed ? "âœ…" : "â˜"} ${todo.task}`, 
      id: todo.id,
      value: todo,
    }))
  )
}

// Start managing the to-do list
await manageTodos()
```

##  Convert Timestamp to Date

```typescript
// Name: Timestamp to Date Converter
// Description: Converts a timestamp to a human-readable date
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user to enter a timestamp
const timestamp = parseInt(await arg("Enter a timestamp (in seconds):"))

// Create a new Date object from the timestamp 
const date = new Date(timestamp * 1000) 

// Format the date as a string 
const formattedDate = date.toLocaleString() 

// Display the formatted date in a div 
await div(md(`## Date: ${formattedDate}`))
```

##  Get GitHub Repository Contributors

```typescript
// Name: Get Repo Contributors 
// Description: Displays a list of contributors for a GitHub repository 
// Author: johnlindquist

import "@johnlindquist/kit"
import { Octokit } from "@octokit/rest"

// Prompt for the repository name (owner/repo) 
const repo = await arg("Enter repository name (owner/repo):")

// Split the repo input into owner and repo name 
const [owner, repoName] = repo.split("/")

// Create a new Octokit instance
const octokit = new Octokit()

// Fetch the list of contributors for the specified repository
const { data: contributors } = await octokit.repos.listContributors({ 
  owner,
  repo: repoName,
})

// Display the list of contributors in a div 
await div(
  md(`
## Contributors for ${repo}:

${contributors.map(contributor => `- [${contributor.login}](${contributor.html_url}) (${contributor.contributions} contributions)`).join("\n")}
`)
)
```

## Optimize Images for Web

```typescript
// Name: Web Image Optimizer
// Description: Optimizes images for web use 
// Author: johnlindquist

import "@johnlindquist/kit"
import sharp from "sharp"

// Prompt the user to select or drop image files
let imagePaths = await getSelectedFile()

// If no files are selected, prompt the user to drop files
if (!imagePaths) {
  imagePaths = await drop({
    placeholder: "Drop image files here...", 
    multiple: true, 
  })
  // Extract file paths from the dropped files 
  imagePaths = imagePaths.map(file => file.path)
} else {
  // Split the selected file paths into an array
  imagePaths = imagePaths.split("\n") 
}

// Display a progress bar during processing
let progress = 0 
const progressBar = await div(md(`# Optimizing images...

${progress}%`))

// Optimize each image for web use
for (const imagePath of imagePaths) {
  // Resize the image if it's larger than 1920px in width 
  const metadata = await sharp(imagePath).metadata() 
  if (metadata.width > 1920) {
    await sharp(imagePath).resize(1920).toFile(imagePath) 
  } 

  // Convert the image to WebP format if the original format is JPEG or PNG 
  if (imagePath.endsWith(".jpg") || imagePath.endsWith(".jpeg") || imagePath.endsWith(".png")) {
    await sharp(imagePath)
      .webp({ quality: 80 }) 
      .toFile(imagePath.replace(/\.(jpg|jpeg|png)$/, ".webp")) 
  } 

  // Update the progress bar 
  progress = Math.floor((imagePaths.indexOf(imagePath) / imagePaths.length) * 100)
  progressBar.setState({
    html: md(`# Optimizing images...

    ${progress}%`),
  }) 
}

// Close the progress bar and display a notification
progressBar.close() 
await notify("Images optimized for web!") 
```
## Get Directions 

```typescript
// Name: Get Directions
// Description: Gets directions between two locations using the Google Maps Directions API
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the starting location
const origin = await arg("Enter starting location:") 

// Prompt for the destination location
const destination = await arg("Enter destination:")

// Construct the Google Maps Directions API URL
const directionsUrl = `https://www.google.com/maps/dir/?api=1&origin=${encodeURIComponent(origin)}&destination=${encodeURIComponent(destination)}`
// You'll need a Google Maps API key to use the Directions API, but you can 
// run this manually in the browser: https://developers.google.com/maps/documentation/directions/get-api-key

// Open the directions in the browser 
await browse(directionsUrl) 
```

## Generate Color Shades

```typescript
// Name: Generate Color Shades
// Description: Generates shades of a color using the chroma.js library
// Author: johnlindquist

import "@johnlindquist/kit"
import chroma from "chroma-js"

// Prompt for the base color in hexadecimal format
const color = await arg("Enter a hexadecimal color:")

// Generate an array of color shades using chroma.js, ranging from light to dark 
const shades = chroma.scale([color, "black"]).colors(5)

// Display the color shades as swatches in a div
await div(
  `<div class="flex flex-row gap-2 p-4"> 
  ${shades.map(shade => `<div style="background-color: ${shade}; width: 64px; height: 64px;"></div>`).join("")}
  </div>`
) 
```

## Find and Remove Empty Directories

```typescript
// Name: Empty Directory Cleanup
// Description: Finds and removes empty directories within a directory
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user to select a directory
const directoryPath = await path({
  onlyDirs: true, // Only allow selecting directories
})

// Find empty directories using the `find` command
let { stdout: emptyDirs } = await exec(`find '${directoryPath}' -type d -empty`, { shell: true }) 

// Split the output into an array of directory paths
emptyDirs = emptyDirs.split("\n").filter(dir => dir.length > 0) 

if (emptyDirs.length > 0) {
  // Display a list of empty directories and ask for confirmation to remove them
  let shouldRemove = await arg(
    { 
      placeholder: `Found ${emptyDirs.length} empty directories. Remove them?`, 
    },
    ["Yes", "No"] 
  )

  if (shouldRemove === "Yes") { 
    // Remove the empty directories using the `rm` command 
    await exec(`rm -rf ${emptyDirs.join(" ")}`, { shell: true }) 
    // Display a notification 
    await notify("Empty directories removed!")
  } 
} else {
  // Display a message if no empty directories are found
  await div(md(`## No empty directories found.`)) 
}
```

##  Convert Text to Speech and Save to File

```typescript
// Name: Save Text as Speech
// Description: Converts text to speech and saves it as an MP3 file 
// Author: johnlindquist

import "@johnlindquist/kit"
import OpenAI from "openai"

// Get your API key from here: https://platform.openai.com/account/api-keys 
const OPENAI_API_KEY = await env("OPENAI_API_KEY")

// Create a new OpenAI instance
const openai = new OpenAI({
  apiKey: OPENAI_API_KEY, 
}) 

// Prompt the user to enter text 
const text = await arg("Enter text to convert to speech:")

// Prompt for the output file name 
const outputFileName = await path({
  startPath: home("Downloads"),
  // Use a suggestion for the output file name based on the input text 
  suggestion: `${text.replace(/\s/g, "_").slice(0, 20)}.mp3`
})

// Generate speech audio using the OpenAI API
const response = await openai.audio.speech.create({ 
  model: "tts-1",
  voice: "alloy", 
  input: text,
})

// Save the audio content to a file 
await writeFile(outputFileName, Buffer.from(await response.arrayBuffer())) 

// Display a notification
await notify("Audio file created!", `Saved to ${outputFileName}`)
```

## Create and Push a Git Commit

```typescript
// Name: Git Commit and Push
// Description: Creates a new Git commit and pushes it to the remote repository
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the commit message
const commitMessage = await arg("Enter commit message:") 

// Stage all changes using git add
await $`git add .`

// Create a new commit using git commit
await $`git commit -m "${commitMessage}"`

// Push the commit to the remote repository using git push 
await $`git push` 

// Display a confirmation message
await div(md(`## Committed changes and pushed to remote!`))
```

##  Get Current Location's Time and Weather

```typescript
// Name: Local Time and Weather
// Description: Displays the current time and weather for the user's location
// Author: johnlindquist

import "@johnlindquist/kit" 

// Get your OpenWeatherMap API key from here: https://openweathermap.org/api
const OPENWEATHERMAP_API_KEY = await env("OPENWEATHERMAP_API_KEY")

// Get the user's current location using the browser's geolocation API 
const { coords } = await new Promise<GeolocationPosition>((resolve, reject) => { 
  navigator.geolocation.getCurrentPosition(resolve, reject)
})

// Fetch timezone information from the Google Time Zone API 
const timezoneResponse = await get(
  `https://maps.googleapis.com/maps/api/timezone/json?location=${coords.latitude},${coords.longitude}&timestamp=${
    Date.now() / 1000
  }&key=${await env("GOOGLE_MAPS_API_KEY")}` 
)
// You can get a Google Maps API key here: https://developers.google.com/maps/documentation/javascript/get-api-key

// Extract the timezone name and raw offset from UTC (in seconds)
const { timeZoneId: timezone, rawOffset } =
  timezoneResponse.data

// Calculate the time at the user's location 
const localTime = new Date(Date.now() + rawOffset * 1000)

// Format the time as a string
const formattedTime = localTime.toLocaleTimeString([], {
  // Show hours, minutes, and seconds
  hour: "2-digit",
  minute: "2-digit",
  second: "2-digit", 
})

// Fetch weather data from OpenWeatherMap API
const weatherResponse = await get(
  `https://api.openweathermap.org/data/2.5/weather?lat=${coords.latitude}&lon=${coords.longitude}&appid=${OPENWEATHERMAP_API_KEY}&units=metric`
) 

// Extract relevant weather information 
const { name, main, weather } = weatherResponse.data 
const temperature = main.temp
const description = weather[0].description 

// Display the time, timezone, and weather information in a div
await div( 
  md(`## Local Time and Weather: 

* Location: ${name} 
* Time: ${formattedTime} (${timezone})
* Temperature: ${temperature}Â°C 
* Description: ${description}
  `)
) 
```

## Get a List of Installed Applications

```typescript
// Name: List Installed Apps
// Description: Lists all installed applications on the system (macOS only)
// Author: johnlindquist

import "@johnlindquist/kit"

// Check if the script is running on macOS
if (isMac) {
  // Use the `mdfind` command to search for application bundles 
  let { stdout: appPaths } = await exec(`mdfind 'kMDItemKind = "Application"'`, { shell: true })

  // Split the output into an array of application paths 
  appPaths = appPaths.split("\n").filter(app => app.length > 0) 

  // Extract app names from the file paths 
  const appNames = appPaths.map(appPath => path.basename(appPath).replace(".app", "")) 

  // Display the list of applications in the editor 
  await editor(appNames.join("\n"), {
    language: "text",
  })
} else {
  // Display a message if the script is run on a non-macOS system 
  await div(md(`## This script is only supported on macOS.`))
}
```


## Convert Text to Audio and Play 

```typescript
// Name: Speak Text from Clipboard 
// Description: Converts text from the clipboard to speech and plays it 
// Author: johnlindquist 

import "@johnlindquist/kit" 
import OpenAI from "openai"

// Get your API key from here: https://platform.openai.com/account/api-keys
const OPENAI_API_KEY = await env("OPENAI_API_KEY")

// Create a new OpenAI instance 
const openai = new OpenAI({ 
  apiKey: OPENAI_API_KEY, 
}) 

// Get the text from the clipboard 
const text = await paste() 

// Generate speech audio using the OpenAI API 
const response = await openai.audio.speech.create({
  model: "tts-1",
  voice: "alloy",
  input: text,
}) 

// Play the audio directly from the response stream without saving to a file
await playAudioFile(response.data) 
```

## Find and Delete Duplicate Files 

```typescript 
// Name: Duplicate File Remover
// Description: Finds and removes duplicate files in a directory 
// Author: johnlindquist

import "@johnlindquist/kit" 
import { createHash } from "crypto"

// Prompt the user to select a directory
const directoryPath = await path({
  onlyDirs: true,
})

// Function to calculate the SHA-256 hash of a file
async function calculateFileHash(filePath: string) {
  const fileBuffer = await readFile(filePath)
  const hashSum = createHash("sha256")
  hashSum.update(fileBuffer)
  return hashSum.digest("hex")
}

// Get all files in the directory
const filePaths = await globby([`${directoryPath}/**/*`], { onlyFiles: true })

// Create a map to store file hashes and their corresponding file paths
const fileHashMap = new Map<string, string[]>()

// Calculate hashes for each file and store them in the map
for (const filePath of filePaths) {
  const fileHash = await calculateFileHash(filePath) 
  if (fileHashMap.has(fileHash)) {
    fileHashMap.get(fileHash).push(filePath)
  } else {
    fileHashMap.set(fileHash, [filePath])
  }
} 

// Find entries with more than one file path (indicating duplicates) 
const duplicateFiles = Array.from(fileHashMap.entries()).filter(([, paths]) => paths.length > 1) 

if (duplicateFiles.length > 0) { 
  // Display duplicate files and prompt for confirmation to remove them 
  let shouldRemove = await arg( 
    {
      placeholder: `Found ${duplicateFiles.length} duplicate files. Remove them?`,
      // Use a custom height for the prompt 
      height: PROMPT.HEIGHT.LG, 
    },
    ["Yes", "No"]
  ) 

  if (shouldRemove === "Yes") {
    // Remove duplicate files 
    for (const [, paths] of duplicateFiles) {
      // Keep the first file and remove the rest 
      for (let i = 1; i < paths.length; i++) {
        await trash(paths[i])
      }
    } 
    // Display a notification
    await notify("Duplicate files removed!")
  }
} else {
  // Display a message if no duplicates are found
  await div(md(`## No duplicate files found.`)) 
} 
```

## Create a New Asana Task

```typescript
// Name: Create Asana Task 
// Description: Creates a new task in Asana
// Author: johnlindquist

import "@johnlindquist/kit"

// Get your Asana API token from here: https://app.asana.com/0/developer-console
const ASANA_PERSONAL_ACCESS_TOKEN = await env("ASANA_PERSONAL_ACCESS_TOKEN")

// Prompt for the task name
const taskName = await arg("Enter task name:")

// Prompt for the project ID (you can find the project ID in the Asana project URL)
const projectId = await arg("Enter Asana project ID:")

// Create a new Asana task using the API 
await post(
  `https://app.asana.com/api/1.0/tasks`, 
  {
    data: { 
      name: taskName,
      projects: [projectId],
    },
  }, 
  {
    headers: {
      Authorization: `Bearer ${ASANA_PERSONAL_ACCESS_TOKEN}`,
    },
  }
)

// Display a confirmation message
await div(md(`## Task "${taskName}" created in Asana!`))
```

## Get System Battery Health

```typescript
// Name: Battery Health Check
// Description: Displays the battery health information (macOS only)
// Author: johnlindquist

import "@johnlindquist/kit"

if (isMac) { 
  // Run the `ioreg` command to get battery health information on macOS
  const { stdout: batteryInfo } = await exec(`ioreg -l | grep -i capacity`, {
    shell: true, 
  }) 
  
  // Extract the relevant information 
  const maxCapacity = parseInt(batteryInfo.match(/"MaxCapacity" = (\d+)/)[1]) 
  const currentCapacity = parseInt(
    batteryInfo.match(/"CurrentCapacity" = (\d+)/)[1] 
  )
  const healthPercentage = ((currentCapacity / maxCapacity) * 100).toFixed(2) 

  // Display the battery health information
  await div(
    md(`
## Battery Health:

* Maximum Capacity: ${maxCapacity} 
* Current Capacity: ${currentCapacity}
* Health: ${healthPercentage}%
    `)
  )
} else {
  // Display a message if the script is run on a non-macOS system
  await div(md(`## This script is only supported on macOS.`))
}
```

## Convert Text to Speech with Different Voices

```typescript
// Name: Text to Speech with Voices
// Description: Converts text to speech with different voices using the OpenAI API
// Author: johnlindquist

import "@johnlindquist/kit"
import OpenAI from "openai"

// Get your OpenAI API key from here: https://platform.openai.com/account/api-keys 
const OPENAI_API_KEY = await env("OPENAI_API_KEY")

// Create a new OpenAI instance 
const openai = new OpenAI({
  apiKey: OPENAI_API_KEY, 
}) 

// Prompt the user to enter the text 
const text = await arg("Enter text to convert to speech:")

// Display a list of available voices and allow the user to select one 
const selectedVoice = await arg("Select a voice:", [
  "alloy", 
  "echo",
  "fable", 
  "onyx",
  "nova", 
  "shimmer",
])

// Create speech audio using the OpenAI API with the selected voice
const response = await openai.audio.speech.create({ 
  model: "tts-1",
  voice: selectedVoice,
  input: text, 
})

// Play the audio directly from the response stream
await playAudioFile(response.data)
```

## Create and Manage a Shopping List

```typescript
// Name: Shopping List Manager 
// Description: Create and manage a shopping list
// Author: johnlindquist

import "@johnlindquist/kit" 

// Initialize a database to store the shopping list
let shoppingList = await db({ items: [] as { id: string; item: string; checked: boolean }[] })

// Function to display and manage the shopping list
const manageShoppingList = async () => {
  // Prompt the user to select an item from the shopping list
  const selectedItem = await arg(
    {
      placeholder: "Select an item:",
      resize: true, // Allow the prompt to be resized
      actions: [
        {
          name: "Add", 
          shortcut: `${cmd}+a`,
          onAction: async () => {
            // Prompt for the new item
            const newItem = await arg("Enter new item:") 
            // Add the new item to the shopping list 
            shoppingList.items.push({ id: uuid(), item: newItem, checked: false })
            await shoppingList.write() 
            // Refresh the shopping list prompt 
            await manageShoppingList()
          },
        }, 
        {
          name: "Toggle Checked",
          shortcut: `${cmd}+enter`,
          onAction: async (input, state) => { 
            // Toggle the "checked" status of the selected shopping list item
            const item = shoppingList.items.find(item => item.id === state.focused.id)
            if (item) {
              item.checked = !item.checked
              await shoppingList.write()
              // Refresh the shopping list prompt 
              await manageShoppingList()
            }
          }, 
        }, 
        {
          name: "Remove",
          shortcut: `${cmd}+d`,
          onAction: async (input, state) => {
            // Remove the selected shopping list item 
            shoppingList.items = shoppingList.items.filter(item => item.id !== state.focused.id)
            await shoppingList.write()
            // Refresh the shopping list prompt
            await manageShoppingList() 
          },
        }, 
      ],
    },
    // Display the shopping list items as choices 
    shoppingList.items.map((item) => ({
      name: `${item.checked ? "âœ…" : "â˜"} ${item.item}`, 
      id: item.id,
      value: item, 
    }))
  )
}

// Start managing the shopping list
await manageShoppingList()
```

## Download File with Progress Bar in Widget

```typescript
// Name: Download with Progress Widget
// Description: Downloads a file with a progress bar displayed in a widget 
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt for the file URL
const fileUrl = await arg("Enter file URL:")

// Create a widget to display the progress bar
let progressWidget = await widget(
  `<div class="p-4">
    <h2 class="text-xl">Downloading</h2>
    <div class="w-full bg-gray-200 rounded-full h-2.5"> 
      <div id="progress-bar" class="bg-blue-500 h-2.5 rounded-full" style="width: {{progress}}%"></div>
    </div>
    <p class="text-sm mt-2">{{progress}}%</p>
  </div> 
`, {
    width: 300,
  }
)

// Download the file with progress updates
await download(fileUrl, home("Downloads"), {
  onDownloadProgress: ({ percent }) => {
    // Update the progress bar in the widget
    progressWidget.setState({ progress: (percent * 100).toFixed(2) })
  },
}) 

// Close the widget and display a notification
progressWidget.close()
await notify("File downloaded!", `Saved to ${path.join(home("Downloads"), path.basename(fileUrl))}`)
```




## Create and Share a Shortened URL

```typescript
// Name: Share Shortened URL
// Description: Creates a shortened URL using the Bitly API and copies it to the clipboard
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the Bitly API token from the environment variables
// You can create a token here: https://app.bitly.com/settings/api/
const BITLY_ACCESS_TOKEN = await env("BITLY_ACCESS_TOKEN")

// Prompt for the long URL 
const longUrl = await arg("Enter a long URL to shorten:")

// Shorten the URL using the Bitly API
const response = await post( 
  "https://api-ssl.bitly.com/v4/shorten",
  { long_url: longUrl },
  { headers: { Authorization: `Bearer ${BITLY_ACCESS_TOKEN}` } }
) 

// Extract the shortened URL 
const { link: shortUrl } = response.data

// Copy the shortened URL to the clipboard 
await copy(shortUrl)

// Display a notification with the shortened URL
await notify("Shortened URL copied:", shortUrl) 
```

## Extract Text from Website

```typescript
// Name: Web Page Text Extractor
// Description: Extracts text content from a web page using cheerio
// Author: johnlindquist

import "@johnlindquist/kit"
import * as cheerio from "cheerio"

// Prompt the user for the website URL
const url = await arg("Enter website URL:") 

// Fetch the HTML content of the webpage
const response = await get(url) 

// Load the HTML content into cheerio
const $ = cheerio.load(response.data)

// Extract the text content from the <p> tags using cheerio
const textContent = $("p").text()

// Display the extracted text in the editor
await editor(textContent, { language: "text" }) 
```

## Check for Code Duplication

```typescript
// Name: Code Duplication Checker
// Description: Checks for code duplication in a JavaScript project using jscpd
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt for the project directory
const projectPath = await path({
  onlyDirs: true,
})

// Run jscpd (JavaScript Code Plagiarism Detection) to detect code duplication 
// This assumes you have jscpd installed globally or locally: https://www.npmjs.com/package/jscpd
let { stdout: duplicationReport } = await exec(`npx jscpd '${projectPath}'`, {
  shell: true,
}) 

// Display the duplication report in the editor
await editor(duplicationReport, {
  language: "text", 
}) 
```

## Clean Up Unused Git Branches

```typescript
// Name: Git Branch Cleanup
// Description: Removes local Git branches that have already been merged
// Author: johnlindquist

import "@johnlindquist/kit" 

// List local Git branches, excluding the current branch
let { stdout: localBranches } = await exec(
  `git branch --merged | grep -v \`git branch --show-current\``, 
  { shell: true }
)

// Split the output into an array of branch names
const branches = localBranches.split("\n").map(branch => branch.trim()).filter(Boolean) 

// Prompt the user to select branches to delete
const branchesToDelete = await select(
  { 
    placeholder: "Select branches to delete (use cmd/ctrl for multiple selections):",
    // Allow multiple selections
    multiple: true, 
    // Set a custom width for the prompt
    width: PROMPT.WIDTH.LG,
  },
  // Use the fetched branch names as choices
  branches 
)

// Delete the selected branches
for (const branch of branchesToDelete) {
  await $`git branch -d ${branch}`
}

// Display a confirmation message 
await div(md(`## Selected branches deleted!`)) 
```

## Create GitHub Gist from Selected Code

```typescript
// Name: Create Gist from Selection
// Description: Creates a GitHub Gist from selected code 
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the selected text, assuming it's code
const code = await getSelectedText() 

// Prompt for a description of the Gist
const description = await arg("Enter Gist description:")

// Prompt for the filename (including extension)
const fileName = await arg("Enter file name (with extension):")

// Create a public Gist using the GitHub API
let { html_url: gistUrl } = await createGist(code, { 
  description, 
  fileName,
  isPublic: true, 
})

// Open the created Gist in the browser 
await browse(gistUrl) 
```

## Convert Timestamp to Date and Time

```typescript
// Name: Timestamp Converter
// Description: Converts a timestamp to a human-readable date and time 
// Author: johnlindquist 

import "@johnlindquist/kit" 

// Prompt for a timestamp (in milliseconds)
const timestamp = parseInt(await arg("Enter timestamp (in milliseconds):"), 10) 

// Create a Date object from the timestamp
const date = new Date(timestamp) 

// Format the date and time as a string
const formattedDateTime = date.toLocaleString()

// Display the formatted date and time
await div(md(`## Date and Time: ${formattedDateTime}`))
```

## Create and Schedule a Google Meet

```typescript
// Name: Schedule Google Meet
// Description: Creates and schedules a Google Meet meeting using the Google Calendar API
// Author: johnlindquist 

import "@johnlindquist/kit" 
import { google } from "googleapis" 
import { JWT } from "google-auth-library"

// Get credentials for Google Service Account through environment variables
// You can create service account credentials here: https://console.cloud.google.com/apis/credentials 
let SA_EMAIL = await env("GOOGLE_SA_EMAIL")
let SA_KEY = await env("GOOGLE_SA_CREDS")

// Define the scopes and client
let jwtClient = new JWT({
  email: SA_EMAIL,
  key: SA_KEY,
  scopes: ["https://www.googleapis.com/auth/calendar"],
})

let calendar = google.calendar("v3")

// Function to create a calendar event
async function createEvent(auth, startTime, endTime, emails) {
  // Define attendees
  let attendees = emails.map(email => ({ email }))

  // Define the event
  let event = {
    summary: "Script Kit Meeting", 
    location: "Online",
    description: "A meeting created by a Script Kit script",
    start: {
      dateTime: startTime, 
      timeZone: "UTC", 
    },
    end: {
      dateTime: endTime, 
      timeZone: "UTC", 
    }, 
    attendees, 
    conferenceData: {
      createRequest: {
        // Generate a random request ID
        requestId: Math.random().toString(), 
        conferenceSolutionKey: {
          type: "hangoutsMeet", 
        },
      },
    }, 
  }

  // Insert the event using the Google Calendar API
  await calendar.events.insert({
    auth,
    calendarId: "primary",
    resource: event,
    conferenceDataVersion: 1,
  })

  // Display a confirmation message
  await div(md(`## Google Meet scheduled!`)) 
}

// Prompt for the meeting start and end times
let startTime = await arg("Enter meeting start time (YYYY-MM-DDTHH:mm:ssZ):") 
let endTime = await arg("Enter meeting end time (YYYY-MM-DDTHH:mm:ssZ):")

// Prompt for the participant email addresses
let emails = await arg("Enter participant email addresses (comma-separated):") 
  .split(",")
  .map(email => email.trim())

// Create the Google Meet event
await createEvent(jwtClient, startTime, endTime, emails)
```
## Create a Time-Tracking Widget

```typescript
// Name: Time Tracker
// Description: Tracks time spent on tasks using a widget
// Author: johnlindquist

import "@johnlindquist/kit"

// Initialize a database to store tasks and their tracked time
let tasksDb = await db({ tasks: [] as { id: string; name: string; time: number }[] })

// Create a widget to display and manage tasks
const timeTrackerWidget = await widget(
  `
  <div class="p-4">
    <h2 class="text-xl font-bold">Time Tracker</h2>
    <ul>
      <li v-for="task in tasks" :key="task.id" class="flex items-center justify-between py-2"> 
        <span>{{ task.name }} - {{ formatTime(task.time) }}</span>
        <button @click="startTask(task.id)" class="px-2 py-1 rounded bg-green-500 text-white">Start</button> 
        <button @click="stopTask(task.id)" class="px-2 py-1 rounded bg-red-500 text-white">Stop</button> 
        <button @click="removeTask(task.id)" class="px-2 py-1 rounded bg-gray-500 text-white">Remove</button>
      </li>
    </ul>
    <div class="mt-4">
      <input type="text" v-model="newTaskName" placeholder="Add new task" class="border rounded p-2 mr-2">
      <button @click="addTask" class="px-4 py-2 rounded bg-blue-500 text-white">Add</button>
    </div>
  </div>
`,
  {
    width: 400,
    height: 300,
    // Pass initial state to the widget, including the tasks and a helper function
    state: {
      tasks: tasksDb.tasks,
      newTaskName: "", 
      formatTime: (milliseconds: number) => {
        const seconds = Math.floor(milliseconds / 1000) % 60; 
        const minutes = Math.floor(milliseconds / (1000 * 60)) % 60; 
        const hours = Math.floor(milliseconds / (1000 * 60 * 60)); 
        return `${hours.toString().padStart(2, "0")}:${minutes.toString().padStart(2, "0")}:${seconds.toString().padStart(2, "0")}` 
      }, 
      addTask: async () => { 
        // Add a new task to the database and update the widget state
        tasksDb.tasks.push({
          id: uuid(),
          name: timeTrackerWidget.state.newTaskName, 
          time: 0,
        }) 
        await tasksDb.write()
        timeTrackerWidget.setState({ tasks: tasksDb.tasks, newTaskName: "" }) 
      }, 
      startTask: async (taskId: string) => {
        // Find the task and start tracking time 
        const task = tasksDb.tasks.find((task) => task.id === taskId)
        if (task) {
          task.startTime = Date.now() 
        }
      }, 
      stopTask: async (taskId: string) => {
        // Find the task and stop tracking time
        const task = tasksDb.tasks.find((task) => task.id === taskId) 
        if (task && task.startTime) {
          task.time += Date.now() - task.startTime 
          delete task.startTime
          await tasksDb.write() 
          timeTrackerWidget.setState({ tasks: tasksDb.tasks }) 
        } 
      },
      removeTask: async (taskId: string) => {
        // Remove the task from the database and update the widget state
        tasksDb.tasks = tasksDb.tasks.filter((task) => task.id !== taskId) 
        await tasksDb.write()
        timeTrackerWidget.setState({ tasks: tasksDb.tasks }) 
      },
    }, 
  }
)

// Keep the script running in the background so the widget stays active
hide()
```

##  Convert Image to ASCII Art

```typescript
// Name: Image to ASCII Art Converter
// Description: Converts an image to ASCII art using the image-to-ascii library
// Author: johnlindquist

import "@johnlindquist/kit" 
import { imageToAscii } from "image-to-ascii" 

// Prompt the user to select an image 
const imagePath = await path({ 
  filters: [{ name: "Images", extensions: ["jpg", "jpeg", "png", "gif"] }],
})

// Prompt for the desired width of the ASCII art
const width = parseInt(await arg("Enter desired width (characters):"))

// Convert the image to ASCII art 
const asciiArt = await imageToAscii(imagePath, {
  // Set the width and use the default color mode
  width,
  colored: false,
})

// Display the ASCII art in the editor 
await editor(asciiArt, {
  language: "text", 
  // Disable resizing to prevent layout shifts 
  resize: false, 
})
```

## Get Commits Between Branches

```typescript
// Name: Compare Git Branches
// Description: Shows the commits between two branches
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the first branch name 
const branch1 = await arg("Enter the first branch name:") 

// Prompt for the second branch name
const branch2 = await arg("Enter the second branch name:") 

// Get the commit differences between the two branches using git log
const { stdout: commitDiff } = await exec(`git log ${branch1}..${branch2} --pretty="%h - %s - %an"`, {
  shell: true, 
})

// Display the commit differences in the editor 
await editor(commitDiff, {
  language: "text",
})
```

## Generate TypeScript types from a URL

```typescript
// Name: Generate Types from URL
// Description: Generates TypeScript types from JSON data at a given URL
// Author: johnlindquist

import "@johnlindquist/kit"
import { quicktype, InputData, JSONSchemaInput, FetchingJSONSchemaStore } from "quicktype"

// Prompt for the URL of the JSON data
const url = await arg("Enter URL of JSON data:")

// Fetch the JSON data from the URL
const response = await get(url) 

// Configure Quicktype options 
const options: Partial<quicktype.Options> = {
  inputData: new InputData(), // Create a new InputData instance 
  lang: "typescript",        // Specify TypeScript as the target language
  rendererOptions: {
    "just-types": "true",    // Generate only type definitions
    "acronym-style": "pascal", // Use PascalCase for acronyms 
  },
} 

// Define the input data for Quicktype as a JSON Schema input
const jsonInput = new JSONSchemaInput(JSON.stringify(response.data)) 

// Fetch the generated TypeScript types from Quicktype
const { lines } = await quicktype({
  ...options, 
  inputData: jsonInput, 
})

// Display the generated types in the editor 
await editor(lines.join("\n"), {
  language: "typescript",
}) 
```

## Summarize Text with Word Count Limit

```typescript
// Name: Text Summarizer with Limit
// Description: Summarizes text from the clipboard with a word count limit using the OpenAI API
// Author: johnlindquist

import "@johnlindquist/kit"
import OpenAI from "openai"

// Get your OpenAI API key from here: https://beta.openai.com/account/api-keys
const OPENAI_API_KEY = await env("OPENAI_API_KEY")

// Create a new OpenAI instance
const openai = new OpenAI({ 
  apiKey: OPENAI_API_KEY,
})

// Get text from clipboard 
const text = await paste() 

// Prompt the user for the maximum word count for the summary 
const maxWords = parseInt(await arg("Enter maximum word count for summary:"))

// Summarize the text using the OpenAI API with the specified word count limit
const completion = await openai.chat.completions.create({
  model: "gpt-3.5-turbo",
  messages: [
    { role: "user", content: `Please summarize the following text in at most ${maxWords} words:\n\n${text}` }, 
  ],
  max_tokens: maxWords * 2, // Set a rough estimate for the maximum number of tokens
})

// Extract the summary from the response 
const summary = completion.choices[0].message.content

// Display the summary in a div
await div(md(`## Summary:\n\n${summary}`)) 
```

## Get GitHub Repository Issues

```typescript
// Name: Get GitHub Issues
// Description: Retrieves and displays issues for a GitHub repository
// Author: johnlindquist

import "@johnlindquist/kit"
import { Octokit } from "@octokit/rest"

// Prompt for the GitHub repository name (owner/repo)
const repo = await arg("Enter repository name (owner/repo):")

// Split the input into owner and repository name
const [owner, repoName] = repo.split("/")

// Create a new Octokit instance 
const octokit = new Octokit() 

// Fetch issues for the specified repository
const { data: issues } = await octokit.issues.listForRepo({
  owner,
  repo: repoName, 
  state: "open", // Retrieve only open issues by default 
})

// Create an array of choices from the fetched issues
const issueChoices = issues.map(issue => ({
  name: issue.title, 
  value: issue.html_url, 
  // Display the issue number and labels as the description
  description: `#${issue.number} - ${issue.labels.map(label => label.name).join(", ")}`,
  // Display a preview of the issue body
  preview: md(issue.body), 
}))

// Prompt the user to select an issue to open
const selectedIssueUrl = await arg(
  {
    placeholder: "Select an issue",
    enter: "Open in Browser",
    // Increase the height of the preview section
    previewHeight: 300, 
  },
  issueChoices 
)

// Open the selected issue in the browser 
await browse(selectedIssueUrl)
```

## Create a Countdown Timer Widget

```typescript
// Name: Countdown Timer Widget 
// Description: Creates a countdown timer widget
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user for the countdown duration in minutes
const durationMinutes = parseFloat(await arg("Enter countdown duration (minutes):")) 

// Calculate the end time in milliseconds
const endTime = Date.now() + durationMinutes * 60 * 1000

// Create a widget to display the countdown timer 
const timerWidget = await widget(
  `<div class="p-4">
    <h2 class="text-xl font-bold">Countdown Timer</h2> 
    <p class="text-3xl">{{ formattedTimeRemaining }}</p>
  </div>
`,
  {
    width: 250, // Set a custom width for the widget 
    state: {
      endTime, 
      formattedTimeRemaining: "", 
    },
  }
) 

// Update the countdown timer every second
let intervalId = setInterval(() => {
  // Calculate the remaining time in milliseconds
  const timeRemaining = timerWidget.state.endTime - Date.now() 

  // Calculate minutes and seconds 
  const minutes = Math.floor(timeRemaining / (1000 * 60)) % 60
  const seconds = Math.floor((timeRemaining % (1000 * 60)) / 1000)

  // Format the time remaining
  const formattedTimeRemaining = `${minutes.toString().padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`

  // Update the widget's state 
  timerWidget.setState({
    formattedTimeRemaining,
  }) 

  // Stop the timer when it reaches zero 
  if (timeRemaining <= 0) {
    clearInterval(intervalId) 
    // Update the widget to display a completion message
    timerWidget.setState({ formattedTimeRemaining: "Time's up!" })
  } 
}, 1000) 

// Keep the script running in the background so the widget stays active
hide()
```



## Check for npm Package Updates

```typescript
// Name: Check for Package Updates
// Description: Checks for updates to npm packages in the current project 
// Author: johnlindquist

import "@johnlindquist/kit"

// Run npm outdated and capture the output
let { stdout: outdatedPackages } = await exec(`npm outdated`, {
  // Set the current working directory to the project root 
  cwd: ".",
  // Capture all output (stdout and stderr)
  all: true,
})

// Check if there are any outdated packages
if (outdatedPackages.trim().length > 0) {
  // Display a notification prompting the user to review updates 
  let review = await notify({
    title: "Outdated Packages",
    message: "Some packages are outdated. Review updates?",
    // Wait for user interaction
    wait: true,
  })

  // If the user clicks the notification, display the list of outdated packages in the editor 
  if (review) {
    await editor(outdatedPackages, { language: "text" })
  }
} else {
  // Display a notification indicating all packages are up to date
  await notify("All npm packages are up to date!")
}
```

##  Generate a Table of Contents for Markdown

```typescript
// Name: Generate Table of Contents 
// Description: Generates a table of contents for a Markdown file
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user to select a Markdown file 
const filePath = await path({
  filters: [{ name: "Markdown Files", extensions: ["md"] }], 
})

// Read the file content
const content = await readFile(filePath, "utf-8") 

// Extract headings from the Markdown content using a regular expression
const headings = content.matchAll(/^##\s+(.*)$/gm) 

// Generate the table of contents, creating links to each heading
let tableOfContents = "" 
for (const heading of headings) { 
  const headingText = heading[1] 
  const headingSlug = headingText.toLowerCase().replace(/\s+/g, "-")
  tableOfContents += `- [${headingText}](#${headingSlug})\n` 
}

// Display the generated table of contents in the editor 
await editor(tableOfContents, {
  language: "markdown",
})
```

##  Create and Send a Scheduled Email

```typescript
// Name: Schedule Email
// Description: Schedules an email to be sent at a later time using Nodemailer
// Author: johnlindquist

import "@johnlindquist/kit"
import nodemailer from "nodemailer"
import schedule from "node-schedule" 

// Get email credentials from environment variables
// You can create an app password here: https://support.google.com/accounts/answer/185833?hl=en
const emailUser = await env("EMAIL_USER") 
const emailPassword = await env("EMAIL_PASSWORD")

// Create a Nodemailer transporter
const transporter = nodemailer.createTransport({
  service: "gmail", 
  auth: {
    user: emailUser,
    pass: emailPassword, 
  },
})

// Prompt for recipient email address 
const to = await arg("Enter recipient email address:") 

// Prompt for the email subject
const subject = await arg("Enter email subject:") 

// Prompt for the email body 
const body = await textarea({
  placeholder: "Enter email body:",
})

// Prompt for the scheduled time (in cron format)
// More info: https://www.npmjs.com/package/node-schedule
const scheduleTime = await arg(
  {
    placeholder: "Enter schedule time (cron format):",
    hint: "Example: 0 9 * * * (every day at 9 AM)",
  }
)

// Schedule the email to be sent at the specified time
schedule.scheduleJob(scheduleTime, async () => {
  // Send the email
  await transporter.sendMail({ 
    from: emailUser,
    to,
    subject, 
    html: body, 
  })
  // Display a notification when the email is sent
  await notify("Scheduled email sent!", `to ${to}`)
})

// Display a confirmation message
await div(md(`## Email scheduled to be sent at: ${scheduleTime}`)) 
```

## Remove Duplicate Lines from a File

```typescript
// Name: Remove Duplicate Lines from File
// Description: Removes duplicate lines from a selected text file
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt for the file path 
const filePath = await path()

// Read the file content 
const fileContent = await readFile(filePath, "utf-8") 

// Split the text into lines
const lines = fileContent.split("\n") 

// Remove duplicate lines while preserving their order 
const uniqueLines = [...new Set(lines)]

// Join the unique lines back into a string 
const newFileContent = uniqueLines.join("\n")

// Overwrite the original file with the modified content
await writeFile(filePath, newFileContent)

// Display a confirmation message 
await div(md(`## Duplicate lines removed from ${filePath}!`))
```

##  Find and Replace Text in Directory

```typescript
// Name: Find and Replace in Directory
// Description: Finds and replaces text in all files within a directory 
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the directory to search in 
const directoryPath = await path({ 
  onlyDirs: true, // Only allow selecting directories
})

// Prompt for the text to find
const searchText = await arg("Enter text to find:")

// Prompt for the replacement text 
const replacementText = await arg("Enter replacement text:")

// Perform find and replace in all files in the directory using ripgrep and sed
await exec(`rg '${searchText}' -l '${directoryPath}' | xargs -I {} sed -i '' 's/${searchText}/${replacementText}/g' {}`, { shell: true }) 

// Display a confirmation message 
await div(md(`## Find and replace complete in ${directoryPath}!`)) 
```

##  Get Random Inspirational Quote

```typescript
// Name: Inspirational Quote 
// Description: Displays a random inspirational quote
// Author: johnlindquist

import "@johnlindquist/kit"

// Fetch a random quote from the Zen Quotes API 
const response = await get("https://zenquotes.io/api/random")

// Extract the quote and author from the response 
const { q: quote, a: author } = response.data[0]

// Display the quote and author in a div
await div(md(`## ${quote}\n\nâ€” ${author}`)) 
```

## Clean Up System Cache

```typescript
// Name: Clear System Cache 
// Description: Clears system caches (macOS only)
// Author: johnlindquist 

import "@johnlindquist/kit"

// Check if running on macOS
if (isMac) {
  // Prompt for confirmation before clearing the system caches
  let shouldClearCache = await arg("Are you sure you want to clear system caches?", ["Yes", "No"]) 

  if (shouldClearCache === "Yes") {
    // Clear system caches using the `purge` command (macOS only) 
    await exec(`sudo purge`, { shell: true }) 
    // Display a notification
    await notify("System caches cleared!") 
  }
} else {
  // Display a message if not running on macOS
  await div(md(`## This script is only supported on macOS.`)) 
}
```
## Download and Install a Font

```typescript
// Name: Font Installer
// Description: Downloads and installs a font from a URL
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the font URL
const fontUrl = await arg("Enter font URL:")

// Prompt for the font name 
const fontName = await arg("Enter font name:")

// Download the font file to the Downloads directory
await download(fontUrl, home("Downloads"))

// Construct the font file path 
const fontFilePath = path.join(home("Downloads"), `${fontName}.ttf`) // Assuming TTF format, adjust if necessary

// Install the font on macOS
if (isMac) { 
  // Open the font file, which will trigger the system font installer
  await exec(`open '${fontFilePath}'`)
} else {
  // For other operating systems, display instructions on how to install fonts 
  await div(md(`## Font downloaded to: ${fontFilePath}\n\nPlease install the font manually.`))
}
```

## Get Project Dependencies

```typescript
// Name: Get Project Dependencies
// Description: Lists dependencies for a project from its package.json file
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user to select a directory containing a package.json file
const projectPath = await path({
  onlyDirs: true,
})

// Read the package.json file 
const packageJson = await readJson(path.join(projectPath, "package.json"))

// Prompt the user to choose the type of dependencies to list
const dependencyType = await arg("Select dependency type:", [
  "dependencies",
  "devDependencies",
  "peerDependencies", 
  "optionalDependencies", 
])

// Extract the selected dependencies from the package.json 
const dependencies = packageJson[dependencyType]

if (dependencies) {
  // Display the dependencies and their versions in a div
  let html = `
    <h1>${dependencyType}:</h1> 
    <ul> 
      ${Object.entries(dependencies).map(([name, version]) => `
        <li>
          ${name}: ${version} 
        </li>
      `).join("")} 
    </ul>
  `
  await div(html) 
} else {
  // Display a message if no dependencies of the selected type are found 
  await div(md(`## No ${dependencyType} found in package.json.`))
}
```

## Generate a New SSH Key Pair

```typescript
// Name: Generate SSH Key Pair
// Description: Generates a new SSH key pair
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the desired key type (rsa, dsa, ecdsa, ed25519)
const keyType = await arg("Enter key type (rsa, dsa, ecdsa, ed25519):") 

// Prompt for the file path for the private key 
const privateKeyPath = await path({
  startPath: home(".ssh"), 
  suggestion: `id_${keyType}`,
})

// Generate the SSH key pair using the `ssh-keygen` command,
// passing the key type, file path, and a comment 
await exec(`ssh-keygen -t ${keyType} -f '${privateKeyPath}' -C "${os.userInfo().username}@${os.hostname()}"`, { shell: true })

// Display a confirmation message
await div(md(`## SSH key pair generated!`)) 

// Reveal the private key file in Finder
await revealFile(privateKeyPath) 
```

##  Send a Message to a Microsoft Teams Channel

```typescript
// Name: Send Microsoft Teams Message
// Description: Sends a message to a Microsoft Teams channel using the Bot Framework SDK 
// Author: johnlindquist

import "@johnlindquist/kit" 
import { TeamsActivityHandler, TurnContext, MessageFactory } from "botbuilder"

// Get the Microsoft Teams App ID and App Password from environment variables
// You can get them from the Azure portal after registering your bot: https://docs.microsoft.com/en-us/azure/bot-service/bot-builder-basics?view=azure-bot-service-4.0
const TEAMS_APP_ID = await env("TEAMS_APP_ID")
const TEAMS_APP_PASSWORD = await env("TEAMS_APP_PASSWORD")

// Prompt for the Microsoft Teams channel ID
// You can find the channel ID in the Teams channel URL
const channelId = await arg("Enter Microsoft Teams channel ID:")

// Prompt for the message to send
const message = await arg("Enter message:") 

// Create a new Teams activity handler for the bot
class TeamsBot extends TeamsActivityHandler { 
  // Handle incoming messages 
  async onMessageActivity(context: TurnContext) {
    // Send the message to the channel
    await context.sendActivity(MessageFactory.text(message)) 
  } 
}

// Create a new bot adapter
const adapter = new BotFrameworkAdapter({
  appId: TEAMS_APP_ID,
  appPassword: TEAMS_APP_PASSWORD,
})

// Create a new instance of the bot 
const bot = new TeamsBot()

// Process the incoming activity (in this case, sending a message)
adapter.processActivity(
  {}, // Mock request object, not relevant for this example
  async (context) => {
    // Route the activity to the bot 
    await bot.run(context) 
  } 
) 

// Display a confirmation message
await div(md(`## Message sent to Microsoft Teams channel!`))
```

##  Convert Image to WebP with Compression Options

```typescript
// Name: Advanced WebP Converter
// Description: Converts an image to WebP format with advanced compression options
// Author: johnlindquist

import "@johnlindquist/kit" 
import sharp from "sharp" 

// Prompt for the image file path 
const imagePath = await path({ 
  filters: [{ name: "Images", extensions: ["jpg", "jpeg", "png"] }],
})

// Prompt for the desired quality level (0-100) 
const quality = parseInt(await arg("Enter desired quality (0-100):"))

// Prompt for the compression method
const method = await arg("Choose compression method:", ["near_lossless", "smart"])

// Convert the image to WebP format using sharp with the specified quality and compression method
await sharp(imagePath)
  .webp({ quality, method: method as any }) // Cast "method" to satisfy type requirements 
  .toFile(imagePath.replace(/\.(jpg|jpeg|png)$/, ".webp"))

// Display a notification
await notify("Image converted to WebP!", `${imagePath}`)
```

## Get CPU Temperature

```typescript
// Name: CPU Temperature Monitor
// Description: Displays the current CPU temperature (macOS only) 
// Author: johnlindquist 

import "@johnlindquist/kit"

// Check if running on macOS
if (isMac) { 
  // Retrieve CPU temperature using the `osx-temperature-sensor` library
  let { cpuTemperature } = await npm("osx-temperature-sensor") 
  let temp = await cpuTemperature()
  await div(md(`## CPU Temperature: ${temp}Â°C`)) 
} else { 
  // Display a message if the script is run on a non-macOS system
  await div(md(`## This script is only supported on macOS.`)) 
}
```

##  Check for GitHub Repository Forks

```typescript
// Name: GitHub Fork Checker
// Description: Checks if a GitHub repository has any forks
// Author: johnlindquist

import "@johnlindquist/kit" 
import { Octokit } from "@octokit/rest" 

// Prompt for the GitHub repository name (owner/repo) 
const repo = await arg("Enter repository name (owner/repo):") 

// Split the repo input into owner and repo name
const [owner, repoName] = repo.split("/")

// Create a new Octokit instance
const octokit = new Octokit() 

// Fetch forks for the specified repository 
const { data: forks } = await octokit.repos.listForks({ 
  owner,
  repo: repoName,
})

// Check if there are any forks 
if (forks.length > 0) {
  // Display the number of forks and a list of fork URLs 
  let forkHtml = `
  <h1>${repo} has ${forks.length} forks:</h1>
  <ul>
    ${forks.map(fork => `
      <li> 
        <a href="${fork.html_url}">${fork.owner.login}</a>
      </li> 
    `).join("")} 
  </ul>
  ` 
  await div(forkHtml)
} else {
  // Display a message if the repository has no forks
  await div(md(`## ${repo} has no forks.`))
}
```


## Add Watermark to Images

```typescript
// Name: Add Watermark to Images 
// Description: Adds a watermark to images in a directory
// Author: johnlindquist

import "@johnlindquist/kit"
import sharp from "sharp"

// Prompt for the directory containing images
const directoryPath = await path({
  onlyDirs: true,
})

// Prompt for the watermark image path 
const watermarkImagePath = await path({
  filters: [{ name: "Images", extensions: ["jpg", "jpeg", "png"] }],
}) 

// Prompt for the watermark position
const watermarkPosition = await arg(
  "Select watermark position:", 
  [
    "top-left", 
    "top-right",
    "bottom-left", 
    "bottom-right", 
    "center",
  ]
)

// Get all image files in the selected directory
const imageFiles = await globby([`${directoryPath}/*.{jpg,jpeg,png}`])

// Create a function to calculate watermark coordinates based on position and image dimensions
const getWatermarkCoordinates = async (
  position: string,
  imageWidth: number,
  imageHeight: number, 
  watermarkWidth: number, 
  watermarkHeight: number
): Promise<{ top: number; left: number }> => { 
  switch (position) {
    case "top-left": 
      return { top: 10, left: 10 }
    case "top-right": 
      return { top: 10, left: imageWidth - watermarkWidth - 10 }
    case "bottom-left":
      return { top: imageHeight - watermarkHeight - 10, left: 10 } 
    case "bottom-right": 
      return { top: imageHeight - watermarkHeight - 10, left: imageWidth - watermarkWidth - 10 } 
    case "center":
      return { top: (imageHeight - watermarkHeight) / 2, left: (imageWidth - watermarkWidth) / 2 } 
    default:
      return { top: 0, left: 0 }
  }
} 

// Add watermark to each image 
for (const imagePath of imageFiles) { 
  // Get the dimensions of the image and watermark 
  const imageMetadata = await sharp(imagePath).metadata()
  const watermarkMetadata = await sharp(watermarkImagePath).metadata() 

  // Calculate the watermark coordinates
  const { top, left } = await getWatermarkCoordinates(
    watermarkPosition, 
    imageMetadata.width,
    imageMetadata.height,
    watermarkMetadata.width,
    watermarkMetadata.height
  ) 

  // Composite the watermark onto the image using sharp 
  await sharp(imagePath)
    .composite([{ input: watermarkImagePath, top, left }]) 
    .toFile(imagePath) 
}

// Display a notification 
await notify("Watermarks added!", `to images in ${directoryPath}`)
```

## Analyze Website Content

```typescript
// Name: Website Content Analyzer 
// Description: Analyzes the content of a website using the OpenAI API
// Author: johnlindquist 

import "@johnlindquist/kit" 
import OpenAI from "openai"

// Get your OpenAI API key here: https://beta.openai.com/account/api-keys 
const OPENAI_API_KEY = await env("OPENAI_API_KEY")

// Create a new OpenAI instance
const openai = new OpenAI({
  apiKey: OPENAI_API_KEY, 
}) 

// Prompt for the website URL 
const url = await arg("Enter website URL:")

// Fetch the HTML content of the website
const response = await get(url) 

// Analyze the website content using the OpenAI API
const completion = await openai.chat.completions.create({ 
  model: "gpt-3.5-turbo",
  messages: [
    {
      role: "user",
      content: `Please provide a brief analysis of the content on this website: ${url}. Include information about the website's purpose, target audience, and overall tone.`,
    },
  ],
}) 

// Extract the analysis from the response 
const analysis = completion.choices[0].message.content 

// Display the analysis in a div 
await div(md(`## Website Content Analysis:

${analysis} 
`))
```

## Create and Publish a Medium Article

```typescript
// Name: Publish to Medium 
// Description: Publishes a Markdown file to Medium
// Author: johnlindquist

import "@johnlindquist/kit"

// Get your Medium Integration Token from here: https://medium.com/me/settings 
const MEDIUM_INTEGRATION_TOKEN = await env("MEDIUM_INTEGRATION_TOKEN") 

// Prompt the user to select a Markdown file
const markdownFilePath = await path({
  filters: [{ name: "Markdown Files", extensions: ["md"] }], 
})

// Read the content of the Markdown file 
const markdownContent = await readFile(markdownFilePath, "utf-8")

// Prompt for the article title
const title = await arg("Enter article title:") 

// Publish the Markdown content to Medium using the API 
const { data: publishedPost } = await post( 
  "https://api.medium.com/v1/users/me/posts", 
  {
    title,
    contentFormat: "markdown",
    content: markdownContent, 
    publishStatus: "public", // Make the article public
    canonicalUrl: null,
    license: "all-rights-reserved",
    tags: ["scriptkit", "automation"], // Add some tags to the article 
  },
  {
    headers: {
      Authorization: `Bearer ${MEDIUM_INTEGRATION_TOKEN}`, 
    }, 
  }
)

// Display a confirmation message with the article URL 
await div(md(`## Article published on Medium!\n\n${publishedPost.url}`))

// Open the published article in the browser
await browse(publishedPost.url) 
```

## Clean Up Download History

```typescript
// Name: Clear Download History
// Description: Clears the download history in the browser (macOS only)
// Author: johnlindquist

import "@johnlindquist/kit"

// Check if running on macOS
if (isMac) {
  // Prompt the user to select the browser
  const browser = await arg("Select browser to clear download history:", ["Chrome", "Safari"]) 

  // Execute AppleScript to clear download history based on the selected browser
  if (browser === "Chrome") {
    await applescript(`
    tell application "Google Chrome"
      delete every download history entry
    end tell
    `) 
  } else if (browser === "Safari") { 
    await applescript(`
    tell application "Safari"
      delete every download history item
    end tell
    `)
  }

  // Display a notification 
  await notify("Download history cleared!") 
} else {
  // Display a message if the script is run on a non-macOS system 
  await div(md(`## This script is only supported on macOS.`))
}
```

## Check for GitHub Pull Request Conflicts

```typescript
// Name: Check for PR Conflicts
// Description: Checks if a GitHub pull request has any conflicts 
// Author: johnlindquist 

import "@johnlindquist/kit"
import { Octokit } from "@octokit/rest"

// Get GitHub authentication token from environment variables
// You can get a token from here: https://github.com/settings/tokens
const githubToken = await env("GITHUB_TOKEN") 

// Prompt for the pull request URL
const prUrl = await arg("Enter pull request URL:")

// Extract owner, repo, and pull request number from the URL
const urlParts = prUrl.match(/https:\/\/github.com\/(.*)\/(.*)\/pull\/(\d+)/) 
const owner = urlParts[1] 
const repo = urlParts[2]
const pullNumber = parseInt(urlParts[3]) 

// Create a new Octokit instance 
const octokit = new Octokit({
  auth: githubToken,
})

// Fetch the pull request information 
const { data: pullRequest } = await octokit.pulls.get({ 
  owner,
  repo,
  pull_number: pullNumber, 
})

// Check the mergeable state of the pull request
if (pullRequest.mergeable) {
  // Display a success message if the pull request is mergeable
  await div(md(`## Pull request is mergeable! ðŸŽ‰`)) 
} else {
  // Display a warning message if the pull request has conflicts
  await div(md(`## Pull request has conflicts. âš ï¸`)) 
}
```

## Convert Text to Handwriting with Custom Options

```typescript
// Name: Custom Handwriting Generator 
// Description: Converts text to handwriting with custom options using the Handwriting.io API
// Author: johnlindquist

import "@johnlindquist/kit" 

// Get your API key here: https://www.handwriting.io/pricing 
const HANDWRITING_API_KEY = await env("HANDWRITING_API_KEY")

// Prompt for the text to convert
const text = await arg("Enter text to convert:") 

// Prompt for the handwriting style
const handwritingStyle = await arg(
  "Select handwriting style:",
  [
    "BALLPOINT",
    "CURSIVE",
    "MARKER",
  ]
) 

// Prompt for the handwriting color (in hexadecimal format)
const color = await arg("Enter handwriting color (hexadecimal):") 

// Prompt for the handwriting size 
const handwritingSize = parseFloat(await arg("Enter handwriting size (1-10):"))

// Send a request to the Handwriting.io API with custom options 
const response = await post( 
  "https://api.handwriting.io/render",
  {
    text, 
    handwriting_id: handwritingStyle, 
    handwriting_size: handwritingSize,
    width: "auto", 
    height: "auto",
    color,
  },
  { headers: { "api-key": HANDWRITING_API_KEY } }
) 

// Extract the image URL from the response
const { image_url } = response.data 

// Display the generated image in a div 
await div(`<img src="${image_url}" alt="Handwritten Text" />`)
```

## Get System Processes with Details

```typescript
// Name: Process Explorer 
// Description: Displays detailed information about system processes
// Author: johnlindquist 

import "@johnlindquist/kit"
import si from "systeminformation"

// Get process information using the systeminformation library
const processes = await si.processes() 

// Prompt the user to select a process
const selectedProcess = await arg(
  {
    placeholder: "Select a process:", 
    // Use a custom width for the prompt
    width: PROMPT.WIDTH.LG, 
  },
  // Create choices from the process list, including a preview with detailed information
  processes.list.map((process) => ({ 
    name: process.name,
    value: process.pid, 
    description: `PID: ${process.pid}, CPU: ${process.cpu}%`, 
    preview: md(`
### Process: ${process.name} 

* PID: ${process.pid} 
* Parent PID: ${process.parentPid}
* CPU Usage: ${process.cpu}%
* Memory Usage: ${filesize(process.mem)} 
* Command: ${process.command} 
`),
  }))
)

// Fetch detailed information for the selected process 
const processDetails = await si.processLoad(selectedProcess) 

// Display the detailed process information in a div
await div(
  md(`
## Process Details:

* Name: ${processDetails.name}
* PID: ${processDetails.pid}
* Parent PID: ${processDetails.parentPid}
* CPU Usage: ${processDetails.cpu}% 
* Memory Usage: ${filesize(processDetails.mem)}
* Command: ${processDetails.command}
  `)
) 
```



##  Upload File to Google Drive

```typescript
// Name: Upload to Google Drive
// Description: Uploads a file to Google Drive 
// Author: johnlindquist

import "@johnlindquist/kit"
import { google } from "googleapis" 
import { JWT } from "google-auth-library"

// Get credentials for Google Service Account through environment variables
// You can create service account credentials here: https://console.cloud.google.com/apis/credentials
let SA_EMAIL = await env("GOOGLE_SA_EMAIL") 
let SA_KEY = await env("GOOGLE_SA_CREDS") 

// Define the scopes and client
let jwtClient = new JWT({
  email: SA_EMAIL, 
  key: SA_KEY,
  scopes: ["https://www.googleapis.com/auth/drive.file"], 
})

let drive = google.drive("v3")

// Function to upload a file to Google Drive
async function uploadFile(auth, filePath, fileName) {
  // Create the file metadata
  const fileMetadata = {
    name: fileName, 
  }

  // Read the file content
  const media = {
    mimeType: mime.getType(filePath),
    body: createReadStream(filePath), 
  }

  // Upload the file using the Google Drive API
  try {
    const response = await drive.files.create({
      auth,
      requestBody: fileMetadata,
      media,
      fields: "id, webViewLink",
    })

    // Display a success message with the file's view link
    await div(md(`## File uploaded to Google Drive!\n\nView Link: ${response.data.webViewLink}`)) 
  } catch (error) {
    // Handle any errors that occur during upload
    console.error(`Error uploading file: ${error}`) 
    await div(md(`## Error uploading file: ${error}`))
  } 
}

// Prompt the user to select a file to upload
const filePath = await path() 

// Extract the file name from the selected path 
const fileName = path.basename(filePath)

// Upload the file
await uploadFile(jwtClient, filePath, fileName)
```

## Generate a Sitemap with Multiple URLs

```typescript
// Name: Generate Multi-URL Sitemap
// Description: Generates a sitemap.xml with multiple URLs 
// Author: johnlindquist

import "@johnlindquist/kit"
import { SitemapStream, streamToPromise } from "sitemap" 

// Prompt the user for the website URL
const websiteUrl = await arg("Enter your website URL:")

// Prompt for the number of URLs to add
const numUrls = parseInt(await arg("Enter number of URLs to add:")) 

// Create an array to store URL data
const urls: any[] = []

// Prompt for each URL, its change frequency, and priority
for (let i = 0; i < numUrls; i++) {
  const url = await arg(`Enter URL ${i + 1}:`)
  const changefreq = await arg(
    `Enter change frequency for ${url} (always, hourly, daily, weekly, monthly, yearly, never):`
  )
  const priority = parseFloat(await arg(`Enter priority for ${url} (0.0 - 1.0):`)) 

  // Add URL data to the array 
  urls.push({ url, changefreq, priority }) 
}

// Create a SitemapStream instance
const sitemapStream = new SitemapStream({ hostname: websiteUrl })

// Add the URLs to the sitemap 
urls.forEach(urlData => {
  sitemapStream.write(urlData)
})

// End the sitemap stream 
sitemapStream.end()

// Convert the sitemap stream to a promise
const sitemapXml = await streamToPromise(sitemapStream)

// Write the sitemap to a file
await writeFile("sitemap.xml", sitemapXml.toString())

// Display a confirmation message
await div(md(`## sitemap.xml generated!`))

// Reveal the generated sitemap file in Finder
await revealFile("sitemap.xml")
```

## Create a Time-lapse from Screenshots

```typescript
// Name: Time-lapse from Screenshots
// Description: Creates a time-lapse video from a sequence of screenshots
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the time interval between screenshots (in seconds)
const intervalSeconds = parseInt(await arg("Enter time interval between screenshots (seconds):"))

// Prompt for the duration of the time-lapse recording (in minutes) 
const durationMinutes = parseFloat(await arg("Enter time-lapse duration (minutes):"))

// Prompt for the output file path 
const outputFilePath = await path({
  startPath: home("Downloads"),
})

// Create a temporary directory to store the screenshots 
const screenshotsDir = tmpPath("screenshots") 
await ensureDir(screenshotsDir) 

// Calculate the total number of screenshots 
const totalScreenshots = Math.floor(durationMinutes * 60 / intervalSeconds)

// Display a progress bar 
let screenshotCount = 0
const progressBar = await div(md(`# Capturing screenshots...

${screenshotCount} of ${totalScreenshots}`))

// Capture screenshots at the specified interval
let intervalId = setInterval(async () => {
  // Capture a screenshot
  const screenshotPath = path.join(
    screenshotsDir,
    `screenshot-${screenshotCount}.png` 
  ) 
  await captureScreen({
    formats: ["png"],
    filePath: screenshotPath,
  }) 
  
  // Increment screenshot count and update progress bar
  screenshotCount++ 
  progressBar.setState({
    html: md(`# Capturing screenshots... 

    ${screenshotCount} of ${totalScreenshots}`)
  })

  // Stop the timer when all screenshots are captured
  if (screenshotCount >= totalScreenshots) {
    clearInterval(intervalId) 
    // Close the progress bar
    progressBar.close()
  }
}, intervalSeconds * 1000)

// Wait for all screenshots to be captured 
await wait(durationMinutes * 60 * 1000)

// Generate the time-lapse video using ffmpeg
await exec(`ffmpeg -y -framerate 30 -pattern_type glob -i '${screenshotsDir}/*.png' -c:v libx264 -pix_fmt yuv420p '${outputFilePath}'`, { shell: true })

// Display a notification 
await notify("Time-lapse video created!", `Saved to ${outputFilePath}`)

// Reveal the time-lapse video in Finder
await revealFile(outputFilePath) 
```

## Remove Unused npm Packages

```typescript
// Name: Remove Unused Packages
// Description: Removes unused npm packages from the current project 
// Author: johnlindquist

import "@johnlindquist/kit" 

// Run `depcheck` to analyze dependencies 
// Requires `depcheck` to be installed globally or locally: https://www.npmjs.com/package/depcheck
let { stdout: depcheckResult } = await exec(`npx depcheck --json`, {
  shell: true,
  cwd: ".",
}) 

// Parse the JSON output of depcheck 
const unusedDependencies = JSON.parse(depcheckResult).dependencies

// Prompt the user to confirm removal of unused dependencies 
let shouldRemove = await arg(
  {
    placeholder: `Found ${unusedDependencies.length} unused dependencies. Remove them?`,
    height: PROMPT.HEIGHT.LG,
  }, 
  ["Yes", "No"] 
) 

if (shouldRemove === "Yes") {
  // Uninstall unused dependencies using npm
  for (const dependency of unusedDependencies) {
    await $`npm uninstall ${dependency}`
  }

  // Display a confirmation message 
  await div(md(`## Unused dependencies removed!`)) 
}
```

##  Upload Files to AWS S3

```typescript
// Name: AWS S3 Uploader
// Description: Uploads files to an AWS S3 bucket
// Author: johnlindquist

import "@johnlindquist/kit"
import AWS from "aws-sdk"

// Get AWS credentials and bucket name from environment variables
// You can configure AWS credentials here: https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/setting-credentials-node.html 
const AWS_ACCESS_KEY_ID = await env("AWS_ACCESS_KEY_ID")
const AWS_SECRET_ACCESS_KEY = await env("AWS_SECRET_ACCESS_KEY")
const S3_BUCKET_NAME = await env("S3_BUCKET_NAME")

// Configure AWS credentials
const s3 = new AWS.S3({
  accessKeyId: AWS_ACCESS_KEY_ID,
  secretAccessKey: AWS_SECRET_ACCESS_KEY, 
}) 

// Prompt for the files to upload
const filePaths = await selectFile({
  multiple: true,
})

// Upload each selected file to S3
for (const filePath of filePaths) { 
  // Get the file name from the path
  const fileName = path.basename(filePath)

  // Configure upload parameters
  const uploadParams = {
    Bucket: S3_BUCKET_NAME,
    Key: fileName, // Use the original file name as the S3 key
    Body: createReadStream(filePath),
    ACL: "public-read", // Make the uploaded file publicly accessible 
  }

  // Upload the file to S3 
  await s3.upload(uploadParams).promise() 

  // Display a confirmation message with the file's public URL
  await div(md(`## File uploaded to S3:\n\nhttps://${S3_BUCKET_NAME}.s3.amazonaws.com/${fileName}`)) 
}
```

## Get User's Public YouTube Videos 

```typescript
// Name: YouTube Video Fetcher
// Description: Displays a list of public videos for a YouTube channel
// Author: johnlindquist

import "@johnlindquist/kit"
import { google } from "googleapis" 

// Get your YouTube Data API key from here: https://console.developers.google.com/apis/api/youtube.googleapis.com/credentials
const YOUTUBE_DATA_API_KEY = await env("YOUTUBE_DATA_API_KEY")

// Create a YouTube Data API client
const youtube = google.youtube("v3")

// Prompt for the YouTube channel ID 
const channelId = await arg("Enter YouTube channel ID:") 

// Fetch the channel's uploads playlist ID
const { data: { items: [playlist] } } = await youtube.channels.list({
  part: "contentDetails",
  id: channelId, 
  key: YOUTUBE_DATA_API_KEY,
}) 

// Fetch video details from the uploads playlist 
const { data: { items: videos } } = await youtube.playlistItems.list({ 
  part: "snippet", 
  playlistId: playlist.contentDetails.relatedPlaylists.uploads,
  key: YOUTUBE_DATA_API_KEY,
})

// Create choices from the fetched videos, including a preview 
const videoChoices = videos.map((video) => ({
  name: video.snippet.title, 
  description: video.snippet.publishedAt,
  value: `https://www.youtube.com/watch?v=${video.snippet.resourceId.videoId}`, 
  // Display a preview of the video thumbnail
  preview: `<img src="${video.snippet.thumbnails.medium.url}" alt="YouTube Thumbnail" />`, 
})) 

// Prompt the user to select a video
const selectedVideo = await arg({
  placeholder: "Select a YouTube video:",
  enter: "Open in Browser", 
}, videoChoices) 

// Open the selected video in the browser
await browse(selectedVideo) 
```

## Convert a Website to PDF 

```typescript
// Name: Convert Web Page to PDF
// Description: Converts a web page to a PDF file using Puppeteer
// Author: johnlindquist

import "@johnlindquist/kit" 
import puppeteer from "puppeteer"

// Prompt for the website URL 
const url = await arg("Enter website URL:")

// Prompt for the output file path
const outputFilePath = await path({ 
  startPath: home("Downloads"),
  suggestion: `${url.replace(/[^a-zA-Z0-9]/g, "_").slice(0, 20)}.pdf`,
})

// Launch a headless browser instance using Puppeteer
const browser = await puppeteer.launch({ headless: "new" }) 

try {
  // Create a new page 
  const page = await browser.newPage()

  // Navigate to the provided URL 
  await page.goto(url, { waitUntil: "networkidle0" })

  // Generate a PDF of the page, setting margins to zero 
  await page.pdf({ path: outputFilePath, margin: { top: 0, right: 0, bottom: 0, left: 0 } })

  // Display a notification
  await notify("PDF generated!", `Saved to ${outputFilePath}`)

  // Reveal the PDF file in Finder 
  await revealFile(outputFilePath)

} finally { 
  // Close the browser instance 
  await browser.close()
}
```

## Create a Screen Recording with Audio

```typescript
// Name: Screen Recorder with Audio
// Description: Records a screen recording with audio using the built-in screen recording functionality
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user to select the screen to record
let screens = await getScreens() 
let screenId = await arg("Select screen to record:", screens.map(s => s.id.toString())) 

// Prompt for the audio input device
let audioInputs = await getMediaDevices()
audioInputs = audioInputs.filter(d => d.kind === "audioinput")
let audioInputId = await arg(
  "Select audio input:",
  audioInputs.map(d => ({ name: d.label, value: d.deviceId }))
)

// Start the screen recording with audio
let filePath = await screenRecording.start({
  screenId: parseInt(screenId), 
  audioDeviceId: audioInputId, // Pass the selected audio input device ID
})

// Prompt the user to stop recording 
await div(
  md(`
## Recording...

Press <kbd>Escape</kbd> to stop recording.
`), 
  "flex flex-col items-center gap-2 justify-center text-center"
) 

// Stop the screen recording when the user presses the escape key
onKeydown(async (event) => { 
  if (event.key === "Escape") {
    // Stop recording
    await screenRecording.stop()
  } 
}) 

// Reveal the recorded video in Finder 
await revealFile(filePath)
```


## Send a Message to a Telegram Group

```typescript
// Name: Send Telegram Group Message
// Description: Sends a message to a Telegram group using the Telegraf library
// Author: johnlindquist

import "@johnlindquist/kit"
import { Telegraf } from "telegraf" 

// Get your Telegram Bot Token from BotFather: https://t.me/BotFather
const TELEGRAM_BOT_TOKEN = await env("TELEGRAM_BOT_TOKEN")

// Create a new Telegraf instance
const bot = new Telegraf(TELEGRAM_BOT_TOKEN)

// Prompt for the Telegram group username (including the "@" symbol)
const groupUsername = await arg("Enter Telegram group username:") 

// Prompt for the message to send
const message = await arg("Enter message:")

// Send the message to the specified Telegram group 
try {
  await bot.telegram.sendMessage(groupUsername, message)
  await div(md(`## Message sent to Telegram group: ${groupUsername}`))
} catch (error) {
  // Handle errors gracefully, providing instructions on how to add the bot to the group 
  await div(
    md(`## Error sending message.

Make sure to add the bot to the group first. 
    `)
  )
}
```

## Create a Meme Image

```typescript
// Name: Meme Generator
// Description: Generates a meme image with custom text using the jimp library 
// Author: johnlindquist

import "@johnlindquist/kit" 
import Jimp from "jimp"

// Prompt the user to select an image for the meme
const imagePath = await path({
  filters: [{ name: "Images", extensions: ["jpg", "jpeg", "png"] }],
})

// Prompt for the top text of the meme
const topText = await arg("Enter top text:")

// Prompt for the bottom text of the meme
const bottomText = await arg("Enter bottom text:")

// Load the image using jimp
const image = await Jimp.read(imagePath) 

// Define the font size and load the font 
const fontSize = Math.min(image.bitmap.width, image.bitmap.height) / 10
const font = await Jimp.loadFont(Jimp.FONT_SANS_64_WHITE)

// Define a function to add text to the image
async function addTextToImage(text: string, yPosition: number) {
  // Calculate text width and center it
  const textWidth = Jimp.measureText(font, text)
  const xPosition = (image.bitmap.width - textWidth) / 2

  // Add text to the image using jimp
  return image.print(font, xPosition, yPosition, text)
}

// Add top and bottom text to the image
await addTextToImage(topText, 10)
await addTextToImage(bottomText, image.bitmap.height - 70)

// Save the meme image to the Downloads directory
const outputPath = path.join(home("Downloads"), `meme-${Date.now()}.jpg`)
await image.writeAsync(outputPath) 

// Display a notification
await notify("Meme created!", `Saved to ${outputPath}`) 

// Reveal the meme image in Finder
await revealFile(outputPath)
```

## Remove Sensitive Information from Files

```typescript
// Name: Sensitive Information Remover
// Description: Removes sensitive information (e.g., API keys, passwords) from files
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user to select a directory
const directoryPath = await path({
  onlyDirs: true, 
})

// Prompt for a list of sensitive information patterns to search for 
const patterns = await arg("Enter sensitive information patterns (comma-separated, use * as wildcard):")
  .split(",")
  .map(pattern => pattern.trim()) 

// Replace sensitive information with redacted text in all files in the directory using ripgrep and sed
for (const pattern of patterns) {
  await exec(`rg '${pattern}' -l '${directoryPath}' | xargs -I {} sed -i '' 's/${pattern}/[REDACTED]/g' {}`, { shell: true })
}

// Display a confirmation message 
await div(md(`## Sensitive information redacted in ${directoryPath}!`)) 
```

## Find and Play a Song

```typescript
// Name: Song Finder
// Description: Finds and plays a song using the Spotify API
// Author: johnlindquist

import "@johnlindquist/kit"
import SpotifyWebApi from "spotify-web-api-node"

// Get Spotify API credentials from environment variables
// You can get client ID and client secret here: https://developer.spotify.com/dashboard/applications
const SPOTIFY_CLIENT_ID = await env("SPOTIFY_CLIENT_ID")
const SPOTIFY_CLIENT_SECRET = await env("SPOTIFY_CLIENT_SECRET") 

// Create a new Spotify API client
const spotifyApi = new SpotifyWebApi({
  clientId: SPOTIFY_CLIENT_ID,
  clientSecret: SPOTIFY_CLIENT_SECRET,
  redirectUri: "http://localhost:8888/callback", // Define a redirect URI for authentication
})

// Retrieve an access token for the Spotify API
const { body: { access_token } } = await spotifyApi.clientCredentialsGrant()
spotifyApi.setAccessToken(access_token)

// Prompt for the song title
const songTitle = await arg("Enter song title:")

// Search for the song on Spotify 
const { body: { tracks } } = await spotifyApi.searchTracks(songTitle, {
  limit: 5,
}) 

// Display a list of matching tracks 
let trackChoices = tracks.items.map(track => ({
  name: track.name,
  value: track, 
  description: track.artists.map(artist => artist.name).join(", "),
  preview: `
  <div class="p-2 flex flex-col gap-2">
    <img src="${track.album.images[0].url}" alt="${track.name}" class="rounded-md w-full" />
    <div class="flex justify-between">
      <p class="text-sm">${track.name}</p>
      <p class="text-xs">${track.album.name}</p>
    </div>
  </div>
  `,
}))

// Prompt for a track selection
const selectedTrack = await arg(
  {
    placeholder: "Select a track:",
    enter: "Play", 
    // Use a custom width for the prompt
    width: 400,
    // Set a custom height for the preview
    previewHeight: 180,
  },
  trackChoices 
) 

// Play the selected track on Spotify
await browse(selectedTrack.external_urls.spotify) 
```

## Convert HTML to Markdown

```typescript
// Name: HTML to Markdown Converter
// Description: Converts HTML to Markdown using Turndown 
// Author: johnlindquist 

import "@johnlindquist/kit" 
import TurndownService from "turndown"

// Create a new TurndownService instance
const turndownService = new TurndownService()

// Prompt the user to enter HTML content 
const htmlContent = await editor({
  placeholder: "Enter HTML content:",
  language: "html", 
}) 

// Convert the HTML to Markdown using Turndown
const markdown = turndownService.turndown(htmlContent)

// Display the Markdown in the editor 
await editor(markdown, {
  language: "markdown",
}) 
```

##  Compress a PDF File

```typescript
// Name: Compress PDF
// Description: Compresses a PDF file to reduce file size 
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user to select a PDF file
const pdfFilePath = await path({
  filters: [{ name: "PDF Files", extensions: ["pdf"] }],
}) 

// Create a temporary file path for the compressed PDF
const compressedPdfPath = tmpPath(`compressed-${path.basename(pdfFilePath)}`)

// Compress the PDF using Ghostscript, using predefined settings for compression
await exec(
  `gs -sDEVICE=pdfwrite -dCompatibilityLevel=1.4 -dPDFSETTINGS=/ebook -dNOPAUSE -dQUIET -dBATCH -sOutputFile='${compressedPdfPath}' '${pdfFilePath}'`,
  { shell: true }
)

// Replace the original PDF with the compressed PDF
await mv(compressedPdfPath, pdfFilePath)

// Display a notification
await notify("PDF compressed!", `${pdfFilePath}`)
```

## Extract Text from Scanned PDF (OCR)

```typescript
// Name: Extract Text from Scanned PDF (OCR)
// Description: Extracts text from a scanned PDF using Tesseract OCR
// Author: johnlindquist

import "@johnlindquist/kit"
import Tesseract from "tesseract.js"

// Prompt the user to select a PDF file 
const pdfFilePath = await path({
  filters: [{ name: "PDF Files", extensions: ["pdf"] }], 
}) 

// Convert the PDF to images using pdftoppm (assuming it's installed) 
await exec(`pdftoppm -png '${pdfFilePath}' output`, { shell: true })

// Get a list of generated image files
const imageFiles = await globby(["output-*.png"])

// Display a progress message 
await div(md(`# Extracting text from images...`))

// Extract text from each image using Tesseract OCR
let extractedText = ""
for (const imagePath of imageFiles) {
  const { data: { text } } = await Tesseract.recognize(imagePath)
  extractedText += text + "\n"
}

// Display the extracted text in the editor
await editor(extractedText, {
  language: "text",
}) 
```

## Create and Send a WhatsApp Message with Media

```typescript
// Name: Send WhatsApp Media Message 
// Description: Sends a WhatsApp message with an image or video attachment using the Twilio API
// Author: johnlindquist

import "@johnlindquist/kit"

// Get your Account SID and Auth Token from here: https://www.twilio.com/console
const accountSid = await env("TWILIO_ACCOUNT_SID") 
const authToken = await env("TWILIO_AUTH_TOKEN")

// Prompt for the recipient's phone number (with country code)
const to = await arg("Enter recipient's phone number (with country code):") 

// Prompt the user to select an image or video file
const mediaFilePath = await path({
  filters: [{ name: "Media", extensions: ["jpg", "jpeg", "png", "gif", "mp4", "mov", "avi"] }],
})

// Initialize the Twilio client 
const twilio = require("twilio")(accountSid, authToken) 

// Send the message with the media attachment
twilio.messages
  .create({ 
    from: `whatsapp:${await env("TWILIO_WHATSAPP_NUMBER")}`, // Your Twilio WhatsApp number 
    to: `whatsapp:${to}`,
    // Include the media file path in the message body 
    body: `Check out this media!`,
    // Specify the media file path as an attachment
    mediaUrl: [mediaFilePath],
  }) 
  .then((message) => console.log(`Message SID: ${message.sid}`)) 
  .catch((error) => console.error("Error sending message:", error)) 

// Display a confirmation message 
await div(md(`## WhatsApp message with media sent!`))
```


## Get Directions with Real-Time Traffic

```typescript
// Name: Get Directions with Traffic
// Description: Gets directions between two locations with real-time traffic information
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the starting location 
const origin = await arg("Enter starting location:")

// Prompt for the destination location
const destination = await arg("Enter destination:")

// Construct the Google Maps Directions API URL with real-time traffic enabled
// Include your Google Maps API key here: 
const directionsUrl = `https://www.google.com/maps/dir/?api=1&origin=${encodeURIComponent(origin)}&destination=${encodeURIComponent(
  destination
)}&departure_time=now`

// Open the directions in the browser
await browse(directionsUrl)
```

## Generate and Preview a Color Palette

```typescript
// Name: Color Palette Generator
// Description: Generates and previews a color palette from an image
// Author: johnlindquist

import "@johnlindquist/kit"
import { Vibrant } from "node-vibrant" 

// Prompt the user to select an image
const imagePath = await path({
  filters: [{ name: "Images", extensions: ["jpg", "jpeg", "png", "gif", "webp"] }],
})

// Extract the dominant color palette from the image using Vibrant 
const palette = await Vibrant.from(imagePath).getPalette()

// Create an array of color swatches, each with a unique ID 
const swatches = Object.entries(palette).map(([name, swatch]) => ({ 
  id: name,
  name: name,
  value: swatch.getHex(),
  // Display the color as a background for the preview 
  preview: `<div style="background-color: ${swatch.getHex()}; width: 100%; height: 100%;"></div>`,
})) 

// Prompt the user to select a color from the generated palette
const selectedColor = await arg(
  {
    placeholder: "Select a color",
    // Enable a larger preview size
    previewHeight: 80, 
  },
  swatches 
) 

// Copy the hexadecimal color code to the clipboard
await copy(selectedColor) 

// Display a notification 
await notify("Color copied to clipboard:", selectedColor)
```

## Remove Duplicate Photos

```typescript
// Name: Duplicate Photo Remover
// Description: Finds and removes duplicate photos in a directory
// Author: johnlindquist

import "@johnlindquist/kit"
import { createHash } from "crypto" 

// Prompt the user to select a directory 
const directoryPath = await path({
  onlyDirs: true,
})

// Function to calculate the perceptual hash of an image using pHash
// Install the 'phash' npm package
// More info: https://www.npmjs.com/package/phash
async function calculateImageHash(imagePath: string) {
  // Calculate the perceptual hash of the image
  const { stdout: pHash } = await exec(`phash "${imagePath}"`, { shell: true }) 
  return pHash.trim()
}

// Get all image files in the directory
const imagePaths = await globby([`${directoryPath}/*.{jpg,jpeg,png,gif,webp}`]) 

// Create a map to store image hashes and their corresponding paths
const imageHashMap = new Map<string, string[]>()

// Display a progress bar while calculating hashes
let progress = 0
const progressBar = await div(md(`# Calculating image hashes...

${progress}%`))

// Calculate hashes for each image
for (const imagePath of imagePaths) {
  const imageHash = await calculateImageHash(imagePath) 
  if (imageHashMap.has(imageHash)) {
    imageHashMap.get(imageHash).push(imagePath)
  } else {
    imageHashMap.set(imageHash, [imagePath])
  }
  // Update the progress bar 
  progress = Math.floor((imagePaths.indexOf(imagePath) / imagePaths.length) * 100) 
  progressBar.setState({
    html: md(`# Calculating image hashes...

    ${progress}%`),
  })
} 

// Close the progress bar
progressBar.close()

// Find entries with more than one file path (indicating duplicates) 
const duplicateImages = Array.from(imageHashMap.entries()).filter(([, paths]) => paths.length > 1)

if (duplicateImages.length > 0) {
  // Display duplicate images and prompt for confirmation to remove them
  let shouldRemove = await arg(
    { 
      placeholder: `Found ${duplicateImages.length} duplicate images. Remove them?`, 
      height: PROMPT.HEIGHT.LG, 
    },
    ["Yes", "No"]
  ) 

  if (shouldRemove === "Yes") {
    // Remove duplicate images, keeping the first occurrence 
    for (const [, paths] of duplicateImages) {
      for (let i = 1; i < paths.length; i++) {
        await trash(paths[i])
      }
    }
    // Display a notification
    await notify("Duplicate images removed!") 
  }
} else {
  // Display a message if no duplicates are found
  await div(md(`## No duplicate images found.`))
}
```

## Get and Set System Volume

```typescript
// Name: System Volume Control 
// Description: Controls the system volume
// Author: johnlindquist

import "@johnlindquist/kit"

// Check if running on macOS
if (isMac) {
  // Get the current system volume usingosascript 
  const currentVolume = parseInt(
    await applescript(`output volume of (get volume settings)`),
    10
  )

  // Prompt the user to adjust the volume, providing the current volume as a hint
  const newVolume = await arg(
    {
      placeholder: "Enter new volume (0-100):",
      hint: `Current volume: ${currentVolume}`,
    }, 
    // Display a range of volume levels as choices
    Array.from({ length: 11 }, (_, i) => i * 10).map(volume => volume.toString()) 
  ) 

  // Set the new system volume using osascript
  await applescript(`set volume output volume ${newVolume}`) 
} else {
  // Display a message if the script is not running on macOS 
  await div(md(`## This script is only supported on macOS.`))
}
```

## Create and Send a Telegram Poll

```typescript
// Name: Create Telegram Poll 
// Description: Creates a poll in a Telegram group or channel 
// Author: johnlindquist

import "@johnlindquist/kit"
import { Telegraf, Context } from "telegraf"

// Get your Telegram Bot Token from BotFather: https://t.me/BotFather
const TELEGRAM_BOT_TOKEN = await env("TELEGRAM_BOT_TOKEN")

// Create a new Telegraf instance
const bot = new Telegraf(TELEGRAM_BOT_TOKEN)

// Prompt for the Telegram chat ID (can be a group or channel ID)
const chatId = await arg("Enter Telegram chat ID:")

// Prompt for the poll question
const question = await arg("Enter poll question:")

// Prompt for the poll options, separated by commas
const options = await arg("Enter poll options (comma-separated):") 
  .split(",")
  .map(option => option.trim())

// Send the poll to the Telegram chat 
bot.telegram.sendPoll(chatId, question, options) 

// Display a confirmation message 
await div(md(`## Poll sent to Telegram chat!`)) 
```

## Convert PDF to Images

```typescript
// Name: PDF to Images Converter
// Description: Converts a PDF file to a sequence of images 
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the PDF file path
const pdfFilePath = await path({
  filters: [{ name: "PDF Files", extensions: ["pdf"] }],
})

// Prompt for the output directory
const outputDir = await path({
  onlyDirs: true,
})

// Convert the PDF to images using pdftoppm
// You'll need to have pdftoppm installed: https://poppler.freedesktop.org/ 
await exec(`pdftoppm -png '${pdfFilePath}' '${outputDir}/page'`, { shell: true })

// Display a notification
await notify("PDF converted to images!", `Saved to ${outputDir}`)

// Reveal the output directory in Finder 
await revealFile(outputDir)
```

## Create and Manage a Personal Dictionary

```typescript
// Name: Personal Dictionary
// Description: Creates and manages a personal dictionary of words 
// Author: johnlindquist 

import "@johnlindquist/kit" 

// Initialize a database to store dictionary words
let dictionaryDb = await db({ words: [] as { id: string; word: string; definition: string }[] }) 

// Function to display and manage the dictionary
const manageDictionary = async () => { 
  // Prompt for the word to search for 
  const searchWord = await arg(
    {
      placeholder: "Enter a word to search or add:",
      // Allow resizing of the prompt window 
      resize: true, 
      // Define actions for adding, editing, or removing words
      actions: [
        {
          name: "Add",
          shortcut: `${cmd}+a`,
          onAction: async () => {
            // Prompt for the new word and its definition
            const newWord = await arg("Enter new word:")
            const newDefinition = await arg("Enter definition:")
            // Add the new word to the dictionary
            dictionaryDb.words.push({ id: uuid(), word: newWord, definition: newDefinition })
            await dictionaryDb.write() 
            // Refresh the dictionary prompt
            await manageDictionary()
          },
        },
        {
          name: "Edit",
          shortcut: `${cmd}+e`,
          onAction: async (input, state) => { 
            // Find the selected word
            const wordToEdit = dictionaryDb.words.find(word => word.id === state.focused.id) 
            if (wordToEdit) {
              // Prompt for the updated definition
              const updatedDefinition = await arg("Enter updated definition:", wordToEdit.definition)
              // Update the word's definition in the dictionary 
              wordToEdit.definition = updatedDefinition 
              await dictionaryDb.write() 
              // Refresh the dictionary prompt 
              await manageDictionary()
            }
          },
        },
        { 
          name: "Remove", 
          shortcut: `${cmd}+d`, 
          onAction: async (input, state) => { 
            // Remove the selected word from the dictionary
            dictionaryDb.words = dictionaryDb.words.filter(word => word.id !== state.focused.id) 
            await dictionaryDb.write()
            // Refresh the dictionary prompt
            await manageDictionary()
          },
        }, 
      ],
    }, 
    // Display dictionary words as choices
    dictionaryDb.words.map(word => ({ 
      name: word.word, 
      id: word.id, 
      value: word,
      // Show the definition in the preview 
      preview: md(word.definition),
    })) 
  )

  // If the user submitted a word, display its definition
  if (selectedWord) {
    await div(md(selectedWord.definition)) 
  }
}

// Start managing the dictionary 
await manageDictionary()
```

##  Create and Share a Code Snippet with Syntax Highlighting

```typescript
// Name: Share Code Snippet with Syntax Highlighting
// Description: Creates a code snippet with syntax highlighting and shares it as a GitHub Gist 
// Author: johnlindquist

import "@johnlindquist/kit"
import { highlight } from "highlight.js" 

// Prompt for the code snippet content
const codeSnippet = await editor({
  placeholder: "Enter your code snippet:", 
})

// Prompt for the programming language 
const language = await arg("Enter programming language:")

// Prompt for a description of the snippet
const description = await arg("Enter a description for your snippet:")

// Highlight the code snippet using highlight.js 
const highlightedCode = highlight(codeSnippet, { language }).value

// Create a Gist on GitHub with the highlighted code
const { html_url: gistUrl } = await createGist(highlightedCode, {
  description, 
  fileName: `snippet.${language}`, 
}) 

// Copy the Gist URL to the clipboard
await copy(gistUrl) 

// Display a confirmation message with the Gist URL
await div(md(`## Code snippet shared as a Gist:\n\n${gistUrl}`)) 
```


## Upload Files to Dropbox

```typescript
// Name: Upload to Dropbox
// Description: Uploads a file to Dropbox using the Dropbox API 
// Author: johnlindquist 

import "@johnlindquist/kit"
import { Dropbox } from "dropbox"

// Get your Dropbox API token from here: https://www.dropbox.com/developers/apps
const DROPBOX_ACCESS_TOKEN = await env("DROPBOX_ACCESS_TOKEN")

// Create a new Dropbox client
const dbx = new Dropbox({ accessToken: DROPBOX_ACCESS_TOKEN })

// Prompt the user to select a file to upload 
const filePath = await path()

// Prompt for the destination path in Dropbox
const destinationPath = await arg("Enter destination path in Dropbox:") 

// Upload the file to Dropbox
await dbx.filesUpload({ path: destinationPath, contents: await readFile(filePath) }) 

// Display a confirmation message
await div(md(`## File uploaded to Dropbox!`)) 
```

## Check Website Load Time

```typescript
// Name: Website Load Time Checker 
// Description: Measures the load time of a website using Puppeteer 
// Author: johnlindquist 

import "@johnlindquist/kit"
import puppeteer from "puppeteer"

// Prompt for the website URL
const url = await arg("Enter website URL:") 

// Launch a headless browser instance using Puppeteer 
const browser = await puppeteer.launch({ headless: "new" })

try {
  // Create a new page 
  const page = await browser.newPage() 

  // Start measuring load time
  const startTime = Date.now()

  // Navigate to the URL 
  await page.goto(url, { waitUntil: "load" })

  // Calculate the load time in milliseconds 
  const loadTime = Date.now() - startTime

  // Display the load time in a div
  await div(md(`## Website Load Time: ${loadTime}ms`)) 
} finally {
  // Close the browser instance 
  await browser.close()
}
```

## Generate TypeScript Project with ESLint and Prettier

```typescript
// Name: Generate TypeScript Project with Linting and Formatting 
// Description: Creates a new TypeScript project with ESLint and Prettier configured
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the project name
const projectName = await arg("Enter project name:")

// Create a new TypeScript project 
await exec(`npx tsc --init --rootDir src --outDir dist --esModuleInterop --resolveJsonModule --lib dom,es2015`, { shell: true }) 

// Change to the project directory
cd(projectName)

// Install ESLint, Prettier, and related packages
await $`npm install --save-dev eslint prettier eslint-config-prettier eslint-plugin-prettier @typescript-eslint/parser @typescript-eslint/eslint-plugin`

// Create a .eslintrc.js configuration file
await writeFile( 
  ".eslintrc.js",
  `module.exports = { 
    parser: "@typescript-eslint/parser",
    extends: [
      "eslint:recommended", 
      "plugin:@typescript-eslint/recommended",
      "prettier", 
    ],
    plugins: ["@typescript-eslint", "prettier"], 
    rules: {
      "prettier/prettier": "error",
    },
  };
  `
)

// Create a .prettierrc configuration file
await writeFile(".prettierrc", `{
  "semi": false, 
  "singleQuote": true,
  "trailingComma": "all", 
}`)

// Display a confirmation message 
await div(md(`# TypeScript project initialized with ESLint and Prettier!`))

// Open the project directory in VS Code
await exec(`code .`) 
```

##  Create and Share a Google Drive Folder

```typescript
// Name: Create and Share Google Drive Folder
// Description: Creates a new folder on Google Drive and shares it with specified users 
// Author: johnlindquist

import "@johnlindquist/kit" 
import { google } from "googleapis"
import { JWT } from "google-auth-library"

// Get credentials for Google Service Account through environment variables
// You can create service account credentials here: https://console.cloud.google.com/apis/credentials
let SA_EMAIL = await env("GOOGLE_SA_EMAIL") 
let SA_KEY = await env("GOOGLE_SA_CREDS") 

// Define the scopes and client 
let jwtClient = new JWT({
  email: SA_EMAIL,
  key: SA_KEY, 
  scopes: ["https://www.googleapis.com/auth/drive"],
})

let drive = google.drive("v3")

// Function to create a folder on Google Drive
async function createFolder(auth, folderName) { 
  // Create the folder metadata
  const fileMetadata = { 
    name: folderName, 
    mimeType: "application/vnd.google-apps.folder",
  }

  // Create the folder
  try {
    const response = await drive.files.create({
      auth, 
      requestBody: fileMetadata,
      fields: "id, webViewLink", 
    }) 

    // Return the folder ID and web view link 
    return response.data 
  } catch (error) { 
    // Handle errors during folder creation 
    console.error(`Error creating folder: ${error}`)
    await div(md(`## Error creating folder: ${error}`)) 
  }
}

// Function to share a folder on Google Drive
async function shareFolder(auth, folderId, email, role) { 
  try {
    // Create a permission for the specified user
    await drive.permissions.create({
      auth, 
      fileId: folderId, 
      requestBody: {
        type: "user",
        role,
        emailAddress: email, 
      }, 
    })
  } catch (error) {
    // Handle errors during sharing
    console.error(`Error sharing folder: ${error}`)
    await div(md(`## Error sharing folder: ${error}`)) 
  } 
}

// Prompt for the folder name 
const folderName = await arg("Enter folder name:")

// Create the folder
const { id: folderId, webViewLink: folderUrl } = await createFolder(jwtClient, folderName)

// Prompt for the number of users to share with 
const numUsers = parseInt(await arg("Enter number of users to share with:"))

// Share the folder with each user 
for (let i = 0; i < numUsers; i++) { 
  const email = await arg(`Enter email address for user ${i + 1}:`) 
  const role = await arg(`Enter role for ${email} (reader, writer, owner):`, ["reader", "writer", "owner"])

  // Share the folder
  await shareFolder(jwtClient, folderId, email, role)
} 

// Display a confirmation message with the folder URL
await div(md(`## Folder created and shared!\n\n${folderUrl}`))
```

## Create a Password Generator Widget

```typescript
// Name: Password Generator Widget
// Description: Generates random passwords with customizable options
// Author: johnlindquist

import "@johnlindquist/kit" 
import generator from "generate-password"

// Create a widget for password generation
const passwordWidget = await widget(
  `
<div class="p-4">
  <h2 class="text-xl font-bold">Password Generator</h2> 
  <div class="flex flex-col gap-2">
    <label for="length">Length:</label>
    <input type="number" id="length" v-model="passwordLength" min="8" max="128" class="border rounded p-2"> 

    <input type="checkbox" id="uppercase" v-model="includeUppercase">
    <label for="uppercase">Include Uppercase</label> 

    <input type="checkbox" id="lowercase" v-model="includeLowercase"> 
    <label for="lowercase">Include Lowercase</label>

    <input type="checkbox" id="numbers" v-model="includeNumbers">
    <label for="numbers">Include Numbers</label>

    <input type="checkbox" id="symbols" v-model="includeSymbols">
    <label for="symbols">Include Symbols</label> 
  </div> 
  <div class="mt-4">
    <button @click="generatePassword" class="px-4 py-2 rounded bg-blue-500 text-white">Generate Password</button> 
  </div>
  <div class="mt-2">
    <input type="text" v-model="generatedPassword" readonly class="border rounded p-2 w-full">
  </div>
</div>
`,
  {
    width: 400,
    height: 300,
    state: {
      passwordLength: 12,
      includeUppercase: true,
      includeLowercase: true, 
      includeNumbers: true,
      includeSymbols: true, 
      generatedPassword: "", // Stores the generated password 
      generatePassword: () => { 
        // Generate a password using generate-password based on the current options 
        const password = generator.generate({
          length: passwordWidget.state.passwordLength, 
          uppercase: passwordWidget.state.includeUppercase, 
          lowercase: passwordWidget.state.includeLowercase,
          numbers: passwordWidget.state.includeNumbers,
          symbols: passwordWidget.state.includeSymbols, 
        }) 

        // Update the generatedPassword state with the new password 
        passwordWidget.setState({
          generatedPassword: password,
        })
      },
    },
  }
)
```

## Get Commit History for a Repository

```typescript
// Name: Get Repo Commit History
// Description: Retrieves and displays the commit history for the current Git repository
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the number of commits to display
const commitCount = parseInt(await arg("Enter number of commits to display:"))

// Get commit history using `git log`, limiting the number of commits and formatting the output
const { stdout: commitHistory } = await exec(`git log --oneline -n ${commitCount}`, {
  shell: true,
}) 

// Display the commit history in the editor
await editor(commitHistory, { 
  language: "text", 
})
```

## Analyze Website Accessibility with Detailed Report

```typescript
// Name: Detailed Accessibility Checker 
// Description: Checks the accessibility of a website using Pa11y and generates a detailed report
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the website URL
const url = await arg("Enter website URL:")

// Run Pa11y accessibility test with JSON reporter and a threshold of "error" (only show errors) 
// Requires Pa11y to be installed: https://pa11y.org/ 
let { stdout: pa11yResult } = await exec(
  `npx pa11y ${url} --reporter json --threshold error`,
  { shell: true }
) 

// Parse the JSON output of Pa11y
const accessibilityReport = JSON.parse(pa11yResult)

// Display the accessibility issues in a div
let html = `
  <h1>Accessibility Errors:</h1>
  <ul>
    ${accessibilityReport.issues.map(issue => `
      <li>
        <h2>${issue.code} - ${issue.type}</h2>
        <p>Message: ${issue.message}</p>
        <p>Context: ${issue.context}</p>
        <p>Selector: ${issue.selector}</p> 
      </li>
    `).join("")}
  </ul>
` 

// Display the accessibility report in a div
await div(html)
```

##  Send Bulk Emails from CSV

```typescript
// Name: Send Bulk Emails from CSV
// Description: Sends bulk emails using data from a CSV file and Nodemailer
// Author: johnlindquist

import "@johnlindquist/kit" 
import nodemailer from "nodemailer" 
import { parse } from "papaparse"

// Get email credentials from environment variables
// You can create an app password here: https://support.google.com/accounts/answer/185833?hl=en
const emailUser = await env("EMAIL_USER") 
const emailPassword = await env("EMAIL_PASSWORD") 

// Create a Nodemailer transporter 
const transporter = nodemailer.createTransport({ 
  service: "gmail", 
  auth: {
    user: emailUser,
    pass: emailPassword,
  },
})

// Prompt the user to select a CSV file containing email data 
const csvFilePath = await path({ 
  filters: [{ name: "CSV Files", extensions: ["csv"] }],
})

// Read the CSV file content
const csvData = await readFile(csvFilePath, "utf-8") 

// Parse the CSV data using papaparse
const { data: csvJson } = parse(csvData, { header: true })

// Prompt for the email subject
const subject = await arg("Enter email subject:") 

// Prompt the user to select an HTML email template
const templateFile = await path({
  filters: [{ name: "HTML Templates", extensions: ["html"] }],
}) 

// Read the contents of the selected template 
const templateContent = await readFile(templateFile, "utf-8") 

// Compile the template using Handlebars
const template = compile(templateContent)

// Send emails to each recipient from the CSV data
for (const row of csvJson) {
  // Render the HTML email content using the template and data from the current CSV row
  const htmlContent = template(row)

  // Define email options 
  const mailOptions = {
    from: emailUser, 
    // Get the recipient's email from the 'email' column in the CSV
    to: row.email, 
    subject,
    html: htmlContent, 
  }

  // Send the email
  await transporter.sendMail(mailOptions) 

  // Display a notification for each email sent
  await notify(`Email sent to ${row.email}!`) 
} 

// Display a confirmation message after all emails are sent 
await div(md(`## Bulk emails sent successfully!`)) 
```

## Create a Custom Terminal Command 

```typescript
// Name: Create Custom Terminal Command
// Description: Creates a custom terminal command using a shell script 
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the command name 
const commandName = await arg("Enter command name:")

// Prompt for the command description
const commandDescription = await arg("Enter command description:")

// Prompt for the command to execute 
const commandToExecute = await arg("Enter the command to execute (including any arguments):") 

// Create the shell script content with the shebang, description, and command to execute
const scriptContent = `#!/bin/bash

# ${commandDescription}

${commandToExecute}
`

// Create the shell script file path
const scriptPath = kenvPath("bin", commandName) 

// Write the script content to the file
await writeFile(scriptPath, scriptContent)

// Make the script executable
await chmod("+x", scriptPath) 

// Display a confirmation message
await div(md(`## Custom terminal command "${commandName}" created!`)) 
```

##  Rename Files in Bulk with a Counter

```typescript
// Name: Batch File Renamer with Counter
// Description: Renames multiple files in a directory, adding a counter to each filename 
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user to select a directory 
const directoryPath = await path({
  onlyDirs: true, // Only allow selecting directories 
})

// Prompt for the new file name prefix 
const fileNamePrefix = await arg("Enter new file name prefix:")

// Prompt for the starting counter value
const startCounter = parseInt(await arg("Enter starting counter value:"))

// Get all files in the directory 
const files = await readdir(directoryPath) 

// Rename files, adding a counter to each filename 
let counter = startCounter
for (const file of files) {
  const oldFilePath = path.join(directoryPath, file) 
  const newFilePath = path.join(directoryPath, `${fileNamePrefix}${counter}${path.extname(file)}`) 
  await mv(oldFilePath, newFilePath) 
  counter++ 
}

// Display a confirmation message
await div(md(`## Files renamed successfully!`))
```

## Check for Website Dead Links

```typescript
// Name: Dead Link Checker 
// Description: Checks for dead links on a website using the 'link-check' CLI tool
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the website URL 
const url = await arg("Enter website URL:")

// Run the 'link-check' command to check for dead links on the website
// This assumes you have 'link-check' installed: https://www.npmjs.com/package/link-check
await exec(`npx link-check -q ${url}`, { shell: true })
```


## Generate PDF from Images

```typescript
// Name: Images to PDF Converter 
// Description: Creates a PDF from a sequence of images 
// Author: johnlindquist

import "@johnlindquist/kit"
import { PDFDocument } from "pdf-lib"

// Prompt the user to select a directory containing images 
const directoryPath = await path({
  onlyDirs: true,
}) 

// Get all image files in the selected directory, supporting various image formats
const imagePaths = await globby([`${directoryPath}/*.{jpg,jpeg,png,gif,webp,tiff}`]) 

// Create a new PDFDocument instance
const pdfDoc = await PDFDocument.create()

// Add each image to the PDF 
for (const imagePath of imagePaths) {
  // Load the image
  const image = await Jimp.read(imagePath) 

  // Convert the image to a PNG buffer (required for embedding in PDF)
  const imageBuffer = await image.getBufferAsync(Jimp.MIME_PNG)

  // Embed the image in the PDF document
  const embeddedImage = await pdfDoc.embedPng(imageBuffer)

  // Add a new page to the PDF document with the image 
  const page = pdfDoc.addPage([
    embeddedImage.width, // Set page width to image width 
    embeddedImage.height, // Set page height to image height
  ])

  // Draw the image on the page
  page.drawImage(embeddedImage, { 
    x: 0, // Place the image at the top-left corner of the page
    y: 0,
    width: embeddedImage.width,
    height: embeddedImage.height,
  })
}

// Prompt for the output file path
const outputFilePath = await path({
  startPath: home("Downloads"), 
}) 

// Save the PDF to the specified path
await writeFile(outputFilePath, await pdfDoc.save()) 

// Display a notification 
await notify("PDF created!", `Saved to ${outputFilePath}`) 

// Reveal the generated PDF in Finder 
await revealFile(outputFilePath)
```

## Get Project Size

```typescript
// Name: Project Size Calculator
// Description: Calculates the size of a project directory 
// Author: johnlindquist 

import "@johnlindquist/kit"
import { readdirSync } from "fs" 

// Prompt for the project directory path 
const directoryPath = await path({ 
  onlyDirs: true, 
})

// Function to calculate the size of a directory recursively 
function getDirectorySize(directory: string): number { 
  // Get all files and subdirectories in the directory
  const files = readdirSync(directory, { withFileTypes: true }) 

  // Calculate the total size
  let size = 0
  for (const file of files) {
    const fullPath = path.join(directory, file.name)
    if (file.isDirectory()) {
      // Recursively calculate the size of subdirectories
      size += getDirectorySize(fullPath) 
    } else {
      // Get the size of the file
      size += (await stat(fullPath)).size 
    }
  }
  return size
} 

// Calculate the size of the project directory
const projectSize = getDirectorySize(directoryPath)

// Display the project size in a div
await div(md(`## Project size: ${filesize(projectSize)}`)) 
```

## Get and Display Stock Chart

```typescript
// Name: Stock Chart Viewer
// Description: Displays a stock chart using the Alpha Vantage API and Chart.js
// Author: johnlindquist 

import "@johnlindquist/kit"
import Chart from "chart.js/auto" // Make sure to install Chart.js

// You can find your API key here: https://www.alphavantage.co/support/#api-key
const ALPHAVANTAGE_API_KEY = await env("ALPHAVANTAGE_API_KEY")

// Prompt for the stock symbol
const stockSymbol = await arg("Enter stock symbol:")

// Fetch daily stock data from the Alpha Vantage API 
const response = await get( 
  `https://www.alphavantage.co/query?function=TIME_SERIES_DAILY&symbol=${stockSymbol}&apikey=${ALPHAVANTAGE_API_KEY}&outputsize=compact` 
)

// Extract historical data 
const timeSeries = response.data["Time Series (Daily)"]

// Prepare data for the chart
const labels = Object.keys(timeSeries).reverse() // Date labels for the chart
const dataPoints = labels.map(date => parseFloat(timeSeries[date]["4. close"])) // Closing prices 

// Create a canvas element for the chart
const canvas = document.createElement("canvas") 
canvas.width = 800 
canvas.height = 400

// Create a new Chart.js chart on the canvas
new Chart(canvas, {
  type: "line", 
  data: {
    labels,
    datasets: [{
      label: "Daily Closing Price",
      data: dataPoints, 
      borderColor: "rgb(75, 192, 192)", 
      tension: 0.1,
    }],
  },
  options: { 
    scales: {
      y: {
        beginAtZero: false,
      }, 
    }, 
  },
})

// Display the chart in a div 
await div(canvas.toDataURL(), "p-4") 
```

## Clean Up Unused Docker Containers

```typescript
// Name: Docker Cleanup
// Description: Removes exited Docker containers
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user to confirm before removing exited containers 
const shouldRemove = await arg("Remove exited Docker containers?", ["Yes", "No"]) 

// Remove exited Docker containers using the `docker container prune` command 
if (shouldRemove === "Yes") { 
  await exec(`docker container prune`, { shell: true }) 
  await div(md(`## Exited Docker containers removed!`)) 
} 
```

## Create and Push to a New Git Branch

```typescript
// Name: Create and Push Git Branch
// Description: Creates a new Git branch, switches to it, and pushes it to the remote repository 
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt for the new branch name
const branchName = await arg("Enter new branch name:") 

// Create the new branch and switch to it
await $`git checkout -b ${branchName}`

// Prompt for confirmation before pushing the new branch
const shouldPush = await arg(`Push new branch "${branchName}" to remote?`, ["Yes", "No"])

if (shouldPush === "Yes") { 
  // Push the branch to the remote repository
  await $`git push origin ${branchName}` 
  await div(md(`## Branch "${branchName}" created and pushed to remote!`))
} else {
  await div(md(`## Branch "${branchName}" created locally!`))
} 
```

##  Convert Speech to Text and Translate

```typescript
// Name: Speech Translator
// Description: Transcribes speech from the microphone and translates it to a selected language 
// Author: johnlindquist 

import "@johnlindquist/kit"
import OpenAI from "openai"
import translate from "@vitalets/google-translate-api"

// Get your OpenAI API key from here: https://beta.openai.com/account/api-keys 
const OPENAI_API_KEY = await env("OPENAI_API_KEY")

// Initialize the OpenAI client 
const openai = new OpenAI({ 
  apiKey: OPENAI_API_KEY, 
})

// Prompt the user to start recording
await div(md(`# Click "Start Recording" to begin speaking.`), "flex flex-col items-center justify-center text-center gap-2")
const audioFilePath = await mic.start()

// Stop recording when the user presses the escape key 
onKeydown(async (event) => { 
  if (event.key === "Escape") {
    await mic.stop() 
  }
}) 

// Read the recorded audio file 
const audioBuffer = await readFile(audioFilePath)

// Convert speech to text using the OpenAI API 
const transcriptionResponse = await openai.audio.transcriptions.create({
  file: await toFile(audioBuffer, "audio.webm"), // Convert the buffer to a file
  model: "whisper-1",
})

// Extract the transcribed text
const transcribedText = transcriptionResponse.text.trim()

// Prompt the user to select the target language for translation
const targetLanguage = await arg("Enter target language code (e.g., 'es' for Spanish):") 

// Translate the transcribed text 
const { text: translatedText } = await translate(transcribedText, { to: targetLanguage }) 

// Display the translated text in the editor 
await editor(translatedText, {
  language: "text",
})
```

## Create and Manage a Personal Knowledge Base

```typescript
// Name: Personal Knowledge Base
// Description: Create and manage a personal knowledge base with notes and links 
// Author: johnlindquist 

import "@johnlindquist/kit"

// Initialize a database to store knowledge base entries 
let knowledgeBase = await db({
  entries: [] as { id: string; title: string; content: string; links: string[] }[], 
})

// Function to display and manage the knowledge base
const manageKnowledgeBase = async () => { 
  // Prompt the user to select an entry from the knowledge base
  const selectedEntry = await arg(
    { 
      placeholder: "Select an entry:",
      // Allow resizing of the prompt window
      resize: true,
      // Define actions for adding, editing, or removing entries
      actions: [
        {
          name: "Add",
          shortcut: `${cmd}+a`,
          onAction: async () => {
            // Prompt for the new entry's title and content
            const newTitle = await arg("Enter new entry title:")
            const newContent = await editor({ placeholder: "Enter entry content:" })
            // Add the new entry to the knowledge base
            knowledgeBase.entries.push({ id: uuid(), title: newTitle, content: newContent, links: [] })
            await knowledgeBase.write() 
            // Refresh the knowledge base prompt 
            await manageKnowledgeBase()
          },
        },
        {
          name: "Edit",
          shortcut: `${cmd}+e`,
          onAction: async (input, state) => {
            // Find the selected entry
            const entryToEdit = knowledgeBase.entries.find(entry => entry.id === state.focused.id) 
            if (entryToEdit) {
              // Prompt for the updated title and content
              const updatedTitle = await arg("Enter updated title:", entryToEdit.title)
              const updatedContent = await editor({
                placeholder: "Enter updated content:",
                value: entryToEdit.content, 
              })
              // Update the entry in the knowledge base 
              entryToEdit.title = updatedTitle
              entryToEdit.content = updatedContent 
              await knowledgeBase.write()
              // Refresh the knowledge base prompt 
              await manageKnowledgeBase()
            }
          },
        }, 
        {
          name: "Remove",
          shortcut: `${cmd}+d`, 
          onAction: async (input, state) => {
            // Remove the selected entry from the knowledge base
            knowledgeBase.entries = knowledgeBase.entries.filter(entry => entry.id !== state.focused.id) 
            await knowledgeBase.write() 
            // Refresh the knowledge base prompt
            await manageKnowledgeBase()
          }, 
        },
      ],
    },
    // Display knowledge base entries as choices
    knowledgeBase.entries.map(entry => ({ 
      name: entry.title,
      id: entry.id, 
      value: entry,
      // Show the content preview in markdown format
      preview: md(entry.content),
    }))
  )

  // If the user submitted an entry, display its content 
  if (selectedEntry) {
    await div(md(selectedEntry.content)) 
  }
}

// Start managing the knowledge base
await manageKnowledgeBase()
```

##  Generate a QR Code from the Clipboard

```typescript
// Name: QR Code from Clipboard 
// Description: Generates a QR code from the text in the clipboard 
// Author: johnlindquist

import "@johnlindquist/kit"
import qrcode from "qrcode" 

// Get the text from the clipboard
const clipboardText = await paste() 

// Prompt for the output file path 
const outputFilePath = await path({
  startPath: home("Downloads"),
  // Suggest a filename based on the clipboard text
  suggestion: `${clipboardText.replace(/\s/g, "_").slice(0, 20)}.png`,
})

// Generate the QR code and save it as a PNG image 
await qrcode.toFile(outputFilePath, clipboardText) 

// Display a notification 
await notify("QR code generated!", `Saved to ${outputFilePath}`)

// Reveal the QR code image in Finder 
await revealFile(outputFilePath) 
```



## Send Message to Multiple Discord Channels

```typescript
// Name: Multi-Channel Discord Messenger 
// Description: Sends a message to multiple Discord channels
// Author: johnlindquist

import "@johnlindquist/kit"
import { Client, IntentsBitField } from "discord.js" 

// Get your Discord Bot Token here: https://discord.com/developers/applications
const DISCORD_BOT_TOKEN = await env("DISCORD_BOT_TOKEN")

// Prompt for the number of channels to send to
const numChannels = parseInt(await arg("Enter the number of channels to send to:")) 

// Prompt for the message to send
const message = await arg("Enter message:") 

// Collect channel IDs
let channelIds: string[] = [] 
for (let i = 0; i < numChannels; i++) {
  // Prompt the user for each channel ID 
  channelIds.push(await arg(`Enter channel ID ${i + 1}:`)) 
}

// Create a new Discord client instance
const client = new Client({ intents: [IntentsBitField.Flags.Guilds] }) 

// Log in to Discord using the bot token
client.login(DISCORD_BOT_TOKEN) 

// Send the message to each specified channel
client.on("ready", async () => {
  for (const channelId of channelIds) {
    // Find the channel by its ID
    const channel = client.channels.cache.get(channelId)

    // Send the message to the channel if it exists
    if (channel?.isTextBased()) {
      await channel.send(message)
      console.log(`Message sent to channel ${channelId}`) 
    } else { 
      console.error(`Channel ${channelId} not found or not a text channel.`) 
    }
  }

  // Disconnect from Discord 
  client.destroy()
})
```

## Check for Node.js Security Vulnerabilities

```typescript
// Name: Node.js Vulnerability Checker
// Description: Checks for known vulnerabilities in npm packages using 'npm audit' 
// Author: johnlindquist

import "@johnlindquist/kit" 

// Run 'npm audit' to check for vulnerabilities in the current project
let { stdout: auditResult } = await exec(`npm audit --json`, { shell: true, cwd: "." }) 

// Parse the JSON output
const vulnerabilities = JSON.parse(auditResult).vulnerabilities

// Check if any vulnerabilities were found 
if (Object.keys(vulnerabilities).length > 0) { 
  // Display the vulnerability report in the editor
  await editor(JSON.stringify(vulnerabilities, null, 2), { language: "json" })
} else {
  // Display a message if no vulnerabilities are found
  await div(md(`## No known vulnerabilities found! ðŸŽ‰`)) 
} 
```

## Download and Install a VS Code Extension

```typescript
// Name: VS Code Extension Installer
// Description: Downloads and installs a VS Code extension from the VS Code Marketplace
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the extension ID
// You can find the extension ID on the VS Code Marketplace page for the extension 
const extensionId = await arg("Enter VS Code extension ID:") 

// Install the extension using the 'code' command line interface 
// This assumes you have VS Code installed and the 'code' command is in your PATH 
await exec(`code --install-extension ${extensionId}`, { shell: true })

// Display a notification
await notify(`Extension ${extensionId} installed!`)
```

##  Get Latest Tweets from a User

```typescript
// Name: Twitter Timeline Viewer
// Description: Displays the latest tweets from a Twitter user
// Author: johnlindquist

import "@johnlindquist/kit" 
import TwitterApi from "twitter-api-v2"

// Get your Twitter Bearer Token here: https://developer.twitter.com/en/portal/dashboard
const TWITTER_BEARER_TOKEN = await env("TWITTER_BEARER_TOKEN")

// Create a new TwitterApi instance
const twitterClient = new TwitterApi(TWITTER_BEARER_TOKEN)

// Prompt for the Twitter username
const username = await arg("Enter Twitter username:")

// Fetch the user's latest tweets
const { data: tweets } = await twitterClient.v2.userTimeline(username, {
  // Exclude replies and retweets 
  "exclude": "replies,retweets",
  // Include user information in the response 
  "tweet.fields": ["author_id"],
  // Limit the number of tweets fetched 
  max_results: 10,
})

// Display the latest tweets in a div
await div(
  md(`## Latest Tweets from @${username}: 

  ${tweets.map(tweet => `- ${tweet.text}\n`).join("")}`)
)
```

## Generate a Random Password with zx

```typescript
// Name: Random Password Generator
// Description: Generates a random password with a specified length using zx
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user for the desired password length
const length = await arg("Enter password length:")

// Generate a random password using openssl and zx
const password = (await $`openssl rand -base64 48 | tr -dc A-Za-z0-9 | head -c${length}`).stdout.trim()

// Copy the password to the clipboard
await copy(password)

// Display a notification 
await notify("Password copied to clipboard:", password) 
```

##  Check Website Uptime

```typescript
// Name: Uptime Checker
// Description: Checks the uptime of a website using the 'uptime-kuma' API
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the Uptime Kuma API token and URL from environment variables
// You can get your API token and server URL from your Uptime Kuma instance
const UPTIME_KUMA_API_TOKEN = await env("UPTIME_KUMA_API_TOKEN") 
const UPTIME_KUMA_URL = await env("UPTIME_KUMA_URL") 

// Prompt for the monitor ID 
// You can find the Monitor ID in the URL for the monitor in Uptime Kuma
const monitorId = await arg("Enter Uptime Kuma monitor ID:")

// Construct the API URL for fetching monitor status
const apiUrl = `${UPTIME_KUMA_URL}/api/monitor/${monitorId}/status` 

// Fetch the monitor status from the Uptime Kuma API 
const response = await get(apiUrl, {
  headers: {
    "x-api-key": UPTIME_KUMA_API_TOKEN, 
  }, 
}) 

// Extract the status and uptime from the response
const { status: monitorStatus, uptime: monitorUptime } = response.data

// Calculate uptime percentage
const uptimePercentage = parseFloat(monitorUptime) * 100 

// Display the uptime information in a div
await div(
  md(`## Monitor Status: ${monitorStatus}

  Uptime: ${uptimePercentage.toFixed(2)}% 
  `)
)
```

## Compress PDF Files in Bulk

```typescript
// Name: Bulk PDF Compressor
// Description: Compresses multiple PDF files using Ghostscript 
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user to select PDF files
let pdfFilePaths = await getSelectedFile() 

// If no files are selected, prompt the user to drop files
if (!pdfFilePaths) {
  pdfFilePaths = await drop({
    placeholder: "Drop PDF files here...",
    multiple: true,
  })
  // Extract file paths from the dropped files
  pdfFilePaths = pdfFilePaths.map(file => file.path) 
} else {
  // Split the selected file paths into an array
  pdfFilePaths = pdfFilePaths.split("\n") 
}

// Compress each selected PDF using Ghostscript, using a loop
for (const pdfFilePath of pdfFilePaths) { 
  // Display a progress message
  await div(md(`# Compressing ${path.basename(pdfFilePath)}...`))

  // Create a temporary file for the compressed PDF 
  const compressedPdfPath = tmpPath(`compressed-${path.basename(pdfFilePath)}`) 

  // Compress the PDF using Ghostscript, specifying compression settings 
  await exec(`gs -sDEVICE=pdfwrite -dCompatibilityLevel=1.4 -dPDFSETTINGS=/ebook -dNOPAUSE -dQUIET -dBATCH -sOutputFile='${compressedPdfPath}' '${pdfFilePath}'`, {
    shell: true, 
  })

  // Replace the original PDF with the compressed PDF
  await mv(compressedPdfPath, pdfFilePath) 
}

// Display a notification after all PDFs are compressed
await notify("PDFs compressed!", `${pdfFilePaths.length} PDFs compressed successfully!`) 
```




## Create and Share a Google Calendar Event

```typescript
// Name: Share Google Calendar Event
// Description: Creates a Google Calendar event and shares the event link 
// Author: johnlindquist

import "@johnlindquist/kit"
import { google } from "googleapis";
import { JWT } from "google-auth-library";

// Get credentials for Google Service Account through environment variables
// You can create service account credentials here: https://console.cloud.google.com/apis/credentials
let SA_EMAIL = await env("GOOGLE_SA_EMAIL") 
let SA_KEY = await env("GOOGLE_SA_CREDS") 

// Define the scopes and client
let jwtClient = new JWT({
  email: SA_EMAIL,
  key: SA_KEY,
  scopes: ["https://www.googleapis.com/auth/calendar"], 
});

let calendar = google.calendar("v3");

// Function to create a calendar event
async function createEvent(auth, event) {
  // Create the event using the Google Calendar API 
  const response = await calendar.events.insert({
    auth, 
    calendarId: "primary", 
    requestBody: event,
    conferenceDataVersion: 1, 
  });

  // Return the event's HTML link
  return response.data.htmlLink;
}

// Prompt for event details
let eventSummary = await arg("Enter event summary:")
let eventStartTime = await arg("Enter event start time (YYYY-MM-DDTHH:mm:ssZ):"); 
let eventEndTime = await arg("Enter event end time (YYYY-MM-DDTHH:mm:ssZ):"); 

// Create the event object
let event = {
  summary: eventSummary,
  start: { dateTime: eventStartTime, timeZone: "UTC" },
  end: { dateTime: eventEndTime, timeZone: "UTC" }, 
};

// Create the event and get the event link
const eventLink = await createEvent(jwtClient, event); 

// Display a confirmation message with the event link
await div(md(`## Event created: [${eventLink}](${eventLink})`))

// Copy the event link to the clipboard
await copy(eventLink);
```

## Check for Unused JavaScript Code

```typescript
// Name: Unused JavaScript Code Finder
// Description: Finds unused JavaScript code using JSCodeShift 
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the project directory
const projectPath = await path({
  onlyDirs: true, 
}) 

// Prompt for a glob pattern to specify the JavaScript files to analyze 
const fileGlob = await arg({ 
  placeholder: "Enter glob pattern for JavaScript files (e.g., src/**/*.js):",
  // Provide a default value for the glob pattern
  defaultValue: "src/**/*.js",
})

// Run JSCodeShift with a custom script to find unused variables 
// This assumes you have JSCodeShift installed: https://www.npmjs.com/package/jscodeshift 
await exec(`npx jscodeshift -t ${kitPath("templates", "codeshift", "find-unused-variables.js")} ${projectPath}/${fileGlob} --dry --print`, {
  shell: true,
})
```

##  Create and Share a Google Docs Document

```typescript
// Name: Create and Share Google Doc
// Description: Creates a new Google Doc and shares it with specified users
// Author: johnlindquist

import "@johnlindquist/kit"
import { google } from "googleapis" 
import { JWT } from "google-auth-library"

// Get credentials for Google Service Account through environment variables
// You can create service account credentials here: https://console.cloud.google.com/apis/credentials
let SA_EMAIL = await env("GOOGLE_SA_EMAIL")
let SA_KEY = await env("GOOGLE_SA_CREDS")

// Define the scopes and client
let jwtClient = new JWT({ 
  email: SA_EMAIL,
  key: SA_KEY,
  scopes: ["https://www.googleapis.com/auth/documents"],
}) 

let docs = google.docs("v1")

// Function to create a new Google Doc
async function createDocument(auth, title) { 
  try {
    // Create the document
    const response = await docs.documents.create({
      auth, 
      requestBody: {
        title, 
      },
    })

    // Return the document ID and URL 
    return response.data 
  } catch (error) {
    // Handle errors during document creation 
    console.error(`Error creating document: ${error}`) 
    await div(md(`## Error creating document: ${error}`))
  } 
}

// Function to share a Google Doc with a user 
async function shareDocument(auth, documentId, email, role) { 
  try {
    // Create a permission for the specified user
    await drive.permissions.create({ 
      auth,
      fileId: documentId,
      requestBody: {
        type: "user", 
        role, 
        emailAddress: email, 
      },
    })
  } catch (error) {
    // Handle errors during sharing 
    console.error(`Error sharing document: ${error}`) 
    await div(md(`## Error sharing document: ${error}`)) 
  }
}

// Prompt for the document title
const documentTitle = await arg("Enter document title:") 

// Create the Google Doc 
const { documentId, url: documentUrl } = await createDocument(
  jwtClient, 
  documentTitle
)

// Prompt for the number of users to share the document with
const numUsers = parseInt(await arg("Enter number of users to share with:"))

// Share the document with each user 
for (let i = 0; i < numUsers; i++) {
  const email = await arg(`Enter email address for user ${i + 1}:`) 
  const role = await arg(`Enter role for ${email} (reader, writer, owner):`, ["reader", "writer", "owner"])

  await shareDocument(jwtClient, documentId, email, role)
} 

// Display a confirmation message with the document URL 
await div(md(`## Document created and shared!\n\n${documentUrl}`))
```

## Optimize JPEG Images

```typescript 
// Name: Optimize JPEGs
// Description: Optimizes JPEG images in a directory using mozjpeg
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the directory containing images
const directoryPath = await path({ 
  onlyDirs: true,
})

// Get all JPEG files in the directory 
const imageFiles = await globby([`${directoryPath}/*.{jpg,jpeg}`]) 

// Optimize each JPEG image using mozjpeg (assuming it's installed)
for (const imagePath of imageFiles) {
  // Display a progress message 
  await div(md(`# Optimizing ${path.basename(imagePath)}...`)) 

  // Use mozjpeg to compress the image with a quality of 80
  await exec(`cjpeg -quality 80 '${imagePath}' > '${imagePath.replace(/\.(jpg|jpeg)$/, "-optimized.$1")}'`, { shell: true })
  await mv(imagePath.replace(/\.(jpg|jpeg)$/, "-optimized.$1"), imagePath)
}

// Display a notification after all JPEGs are optimized
await notify("JPEG images optimized!", `in ${directoryPath}`)
```

## Compare Two Directories

```typescript
// Name: Directory Comparator
// Description: Compares two directories and displays the differences
// Author: johnlindquist

import "@johnlindquist/kit"
import { diff, Change } from "diff" 

// Prompt the user to select the first directory 
const directory1Path = await path({
  onlyDirs: true,
})

// Prompt the user to select the second directory
const directory2Path = await path({ 
  onlyDirs: true,
})

// Read the contents of both directories
const directory1Files = await readdir(directory1Path)
const directory2Files = await readdir(directory2Path)

// Compare the directory listings
const diffResult: Change[] = diff(directory1Files, directory2Files) 

// Generate HTML to display the differences 
let diffHtml = `<pre class="whitespace-pre-wrap">`

for (const part of diffResult) {
  // Highlight added and removed files 
  if (part.added) {
    diffHtml += `<span style="color: green;">+${part.value}</span>`
  } else if (part.removed) { 
    diffHtml += `<span style="color: red;">-${part.value}</span>`
  } else {
    diffHtml += `<span>${part.value}</span>`
  } 
}

// Close the <pre> tag
diffHtml += `</pre>` 

// Display the differences in a div
await div(diffHtml)
```

## Generate a React Component 

```typescript
// Name: React Component Generator
// Description: Generates a React component boilerplate
// Author: johnlindquist 

import "@johnlindquist/kit"

// Prompt for the component name
const componentName = await arg("Enter component name:")

// Create a directory for the component 
await mkdir(componentName) 

// Create the component file (e.g., MyComponent.tsx) 
const componentFilePath = path.join(componentName, `${componentName}.tsx`) 

// Create the component boilerplate code
const componentCode = `import React from "react";

interface ${componentName}Props {}

const ${componentName}: React.FC<${componentName}Props> = () => { 
  return (
    <div> 
      {/* Your component code here */} 
    </div>
  );
}; 

export default ${componentName};
`

// Write the component code to the file 
await writeFile(componentFilePath, componentCode) 

// Display a confirmation message 
await div(md(`## React component "${componentName}" created!`)) 

// Open the component file in the editor 
await edit(componentFilePath)
```

##  Get Latest Hacker News Stories

```typescript
// Name: Hacker News Reader
// Description: Displays the latest Hacker News stories
// Author: johnlindquist 

import "@johnlindquist/kit" 
import { JSDOM } from "jsdom" 

// Fetch the Hacker News homepage HTML content 
const response = await get("https://news.ycombinator.com/") 

// Parse the HTML content using JSDOM
const dom = new JSDOM(response.data)

// Extract story titles, links, and scores from the parsed HTML 
const stories = Array.from(dom.window.document.querySelectorAll(".athing")).map((article) => { 
  const titleElement = article.querySelector(".titleline > a")
  const scoreElement = article.nextElementSibling.querySelector(".score") 
  return { 
    title: titleElement.textContent.trim(),
    url: titleElement.href,
    score: scoreElement ? scoreElement.textContent.trim() : "0 points", // Handle cases where the score is missing
  }
}) 

// Display the stories as choices, including previews 
const storyChoices = stories.map(story => ({
  name: story.title,
  value: story.url,
  description: story.score, 
  // Display the story link and a short excerpt as the preview 
  preview: md(`[${story.url}](${story.url})\n\n${story.title.slice(0, 100)}...`), 
})) 

// Prompt the user to select a story
const selectedStoryUrl = await arg({
  placeholder: "Select a story:", 
  enter: "Open in Browser",
}, storyChoices) 

// Open the selected story in the browser
await browse(selectedStoryUrl) 
```

##  Convert Images to a Different Format

```typescript
// Name: Image Format Converter
// Description: Converts images in a directory to a specified format
// Author: johnlindquist 

import "@johnlindquist/kit" 
import sharp from "sharp" 

// Prompt the user to select a directory
const directoryPath = await path({ 
  onlyDirs: true,
}) 

// Prompt for the desired output format
const outputFormat = await arg("Enter desired output format (e.g., png, webp):")

// Get all image files in the directory 
const imageFiles = await globby([`${directoryPath}/*.{jpg,jpeg,png,gif,webp,tiff}`]) 

// Display a progress bar while converting images 
let progress = 0; 
const progressBar = await div(md(`# Converting images... 

${progress}%`)) 

// Convert each image to the specified format
for (const imagePath of imageFiles) {
  // Convert the image using sharp
  await sharp(imagePath)
    .toFormat(outputFormat) 
    .toFile(imagePath.replace(/\..+$/, `.${outputFormat}`)) 

  // Update the progress bar
  progress = Math.floor((imageFiles.indexOf(imagePath) / imageFiles.length) * 100) 
  progressBar.setState({
    html: md(`# Converting images... 

    ${progress}%`),
  })
}

// Close the progress bar and display a notification
progressBar.close() 
await notify("Images converted!", `in ${directoryPath}`)
```
## Find and Open Log File

```typescript
// Name: Open Log File
// Description: Finds and opens a log file in the editor
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the log file name
const logFileName = await arg("Enter log file name (e.g., error.log):") 

// Search for the log file in the kenv's "logs" directory
const logFilePath = await find(logFileName, {
  onlyin: kenvPath("logs"),
}) 

// Open the log file in the editor
await editor({
  file: logFilePath,
  language: "text", 
})
```

##  Convert CSV to Markdown Table

```typescript
// Name: CSV to Markdown Table Converter
// Description: Converts CSV data to a Markdown table 
// Author: johnlindquist

import "@johnlindquist/kit"
import { parse } from "papaparse" 

// Prompt the user to select a CSV file
const filePath = await path({
  filters: [{ name: "CSV Files", extensions: ["csv"] }],
})

// Read the CSV file content
const csvData = await readFile(filePath, "utf-8")

// Parse the CSV data using papaparse 
const { data: csvJson } = parse(csvData, {
  header: true, 
}) 

// Extract the headers from the parsed CSV data
const headers = Object.keys(csvJson[0]) 

// Generate the Markdown table header row
let markdownTable = `| ${headers.join(" | ")} |\n` 
markdownTable += `| ${headers.map(() => "---").join(" | ")} |\n`

// Generate table rows from CSV data 
csvJson.forEach(row => {
  markdownTable += `| ${headers.map(header => row[header]).join(" | ")} |\n` 
})

// Display the Markdown table in the editor
await editor(markdownTable, {
  language: "markdown",
})
```

## Create and Send a Scheduled Slack Message

```typescript
// Name: Schedule Slack Message
// Description: Schedules a message to be sent to a Slack channel at a specified time
// Author: johnlindquist

import "@johnlindquist/kit" 
import { WebClient } from "@slack/web-api" 
import schedule from "node-schedule"

// Get your Slack API token from here: https://api.slack.com/apps
const SLACK_API_TOKEN = await env("SLACK_API_TOKEN")

// Create a new instance of the Slack WebClient
const slackClient = new WebClient(SLACK_API_TOKEN)

// Prompt for the Slack channel
const channel = await arg("Enter Slack channel:")

// Prompt for the message content 
const message = await arg("Enter message to send:")

// Prompt for the scheduled time (in cron format)
const scheduleTime = await arg(
  {
    placeholder: "Enter schedule time (cron format):",
    hint: "Example: 0 9 * * * (every day at 9 AM)", 
  }
)

// Schedule the message to be sent at the specified time 
schedule.scheduleJob(scheduleTime, async () => { 
  // Send the message to the Slack channel
  await slackClient.chat.postMessage({ channel, text: message }) 

  // Display a notification
  await notify("Scheduled Slack message sent!", `to ${channel}`) 
}) 

// Display a confirmation message 
await div(md(`## Message scheduled to be sent to Slack at: ${scheduleTime}`))
```

## Clean Up Unused Docker Volumes

```typescript
// Name: Docker Volume Cleanup
// Description: Removes unused Docker volumes 
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user to confirm before removing unused volumes
const shouldRemove = await arg("Remove unused Docker volumes?", ["Yes", "No"]) 

// Remove unused Docker volumes using the docker volume prune command
if (shouldRemove === "Yes") {
  await exec(`docker volume prune`, { shell: true })
  // Display a confirmation message 
  await div(md(`## Unused Docker volumes removed!`)) 
}
```

##  Download a File from Google Drive

```typescript
// Name: Download from Google Drive 
// Description: Downloads a file from Google Drive
// Author: johnlindquist

import "@johnlindquist/kit"
import { google } from "googleapis" 
import { JWT } from "google-auth-library" 

// Get credentials for Google Service Account through environment variables 
// You can create service account credentials here: https://console.cloud.google.com/apis/credentials
let SA_EMAIL = await env("GOOGLE_SA_EMAIL") 
let SA_KEY = await env("GOOGLE_SA_CREDS")

// Define the scopes and client
let jwtClient = new JWT({ 
  email: SA_EMAIL,
  key: SA_KEY,
  scopes: ["https://www.googleapis.com/auth/drive.readonly"], 
})

let drive = google.drive("v3")

// Function to download a file from Google Drive
async function downloadFile(auth, fileId, outputPath) {
  try {
    // Get the file's metadata to determine the file name
    const fileResponse = await drive.files.get({
      fileId,
      auth,
      fields: "name", 
    })

    // Extract the file name from the response
    const fileName = fileResponse.data.name 

    // Download the file content 
    const response = await drive.files.get({ fileId, auth, alt: "media" }, { responseType: "stream" })

    // Create a write stream to save the file 
    const dest = createWriteStream(path.join(outputPath, fileName))

    // Pipe the downloaded data to the output file 
    response.data
      .on("end", () => {
        console.log(`Downloaded ${fileName}`) 
      }) 
      .on("error", (err) => {
        console.error("Error downloading file:", err) 
      }) 
      .pipe(dest)
  } catch (error) {
    // Handle any errors during the download process
    console.error(`Error downloading file: ${error}`)
    await div(md(`## Error downloading file: ${error}`))
  }
}

// Prompt for the Google Drive file ID
const fileId = await arg("Enter Google Drive file ID:")

// Prompt for the output directory
const outputPath = await path({
  onlyDirs: true, 
})

// Download the file to the specified directory 
await downloadFile(jwtClient, fileId, outputPath)
```

## Clean Up Old Files

```typescript 
// Name: Old File Cleanup 
// Description: Removes files older than a specified number of days 
// Author: johnlindquist 

import "@johnlindquist/kit"

// Prompt for the directory to clean up
const directoryPath = await path({
  onlyDirs: true,
})

// Prompt for the number of days
const daysOld = parseInt(await arg("Enter number of days:"))

// Get the current timestamp
const now = Date.now()

// Get files in the directory 
const files = await globby([`${directoryPath}/**/*`]) 

// Filter files older than the specified number of days 
const oldFiles = (
  await Promise.all(
    files.map(async (file) => {
      const { mtimeMs } = await stat(file)
      // Calculate the age of the file in days
      const fileAgeDays = (now - mtimeMs) / (1000 * 60 * 60 * 24) 
      return fileAgeDays > daysOld ? file : null
    }) 
  )
).filter(Boolean)

// Display a list of files to be removed and prompt for confirmation
if (oldFiles.length > 0) {
  let shouldRemove = await arg(
    {
      placeholder: `Found ${oldFiles.length} files older than ${daysOld} days. Remove them?`,
      // Display the file list in the preview
      preview: md(oldFiles.map(file => `- ${file}`).join("\n")), 
      height: PROMPT.HEIGHT.LG,
    },
    ["Yes", "No"]
  )

  if (shouldRemove === "Yes") {
    // Remove the old files 
    await trash(oldFiles) 
    await notify("Old files removed!") 
  } 
} else {
  // Display a message if no old files are found
  await div(md(`## No files older than ${daysOld} days found.`)) 
}
```

## Check WordPress Plugin for Updates

```typescript
// Name: WordPress Plugin Update Checker
// Description: Checks for updates to a WordPress plugin 
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt for the plugin slug (e.g., "akismet")
const pluginSlug = await arg("Enter WordPress plugin slug:")

// Fetch plugin information from the WordPress.org API
const response = await get(`https://api.wordpress.org/plugins/info/1.2/?action=plugin_information&request[slug]=${pluginSlug}`)

// Extract the latest version from the response
const latestVersion = response.data.version 

// Get the current plugin version from the project (this assumes you're in the plugin's directory) 
const currentVersion = (await readJson("package.json")).version

// Compare the current and latest versions 
if (currentVersion === latestVersion) { 
  await div(md(`## Plugin is up to date!`))
} else {
  await div(md(`## New plugin version available: ${latestVersion}`))
}
```


## Download and Install Homebrew Packages

```typescript
// Name: Homebrew Package Installer
// Description: Installs Homebrew packages
// Author: johnlindquist 

import "@johnlindquist/kit"

// Prompt for the package name(s) to install, separated by spaces 
const packageNames = await arg("Enter package name(s) to install (separated by spaces):") 

// Split the input into an array of package names
const packages = packageNames.split(" ")

// Install each package using Homebrew
for (const packageName of packages) {
  await div(
    md(`# Installing ${packageName}...`),
    "flex flex-col items-center gap-2 justify-center text-center"
  ) 

  // Install the package using the `brew install` command 
  await exec(`brew install ${packageName}`, { shell: true })
} 

// Display a notification 
await notify("Packages installed!", `Installed ${packageNames}`) 
```

## Extract Text from Image with Options

```typescript
// Name: Extract Image Text with Options 
// Description: Extracts text from an image with options for language and output format using Tesseract OCR
// Author: johnlindquist

import "@johnlindquist/kit" 
import Tesseract from "tesseract.js"

// Prompt for the image file path
const imagePath = await path({
  filters: [{ name: "Images", extensions: ["jpg", "jpeg", "png", "gif"] }], 
})

// Prompt for the language to use for OCR 
const language = await arg("Enter language code (e.g., eng, spa):") 

// Prompt for the desired output format
const outputFormat = await arg("Select output format:", ["txt", "pdf"])

// Perform OCR using Tesseract with the specified language 
const { data: { text } } = await Tesseract.recognize(imagePath, language)

if (outputFormat === "txt") {
  // Display the extracted text in the editor
  await editor(text, {
    language: "text",
  })
} else if (outputFormat === "pdf") {
  // Create a temporary file path for the PDF
  const pdfFilePath = tmpPath("extracted-text.pdf")

  // Convert the extracted text to PDF using Pandoc 
  // Assumes Pandoc is installed: https://pandoc.org/installing.html
  await exec(`pandoc -o '${pdfFilePath}' -`, {
    shell: true,
    input: text, // Pass the extracted text as input to Pandoc 
  })

  // Reveal the PDF file in Finder 
  await revealFile(pdfFilePath)
}
```

## Create a Trello Board

```typescript
// Name: Create Trello Board 
// Description: Creates a new Trello board 
// Author: johnlindquist 

import "@johnlindquist/kit"

// Get Trello API credentials from environment variables 
// You can get your API key and token here: https://trello.com/app-key 
const TRELLO_API_KEY = await env("TRELLO_API_KEY")
const TRELLO_API_TOKEN = await env("TRELLO_API_TOKEN") 

// Prompt for the board name
const boardName = await arg("Enter board name:")

// Prompt for the board's default list names (comma-separated)
const defaultLists = await arg("Enter default list names (comma-separated):") 
  .split(",") 
  .map(list => list.trim()) 
  
// Create the new Trello board using the API
const response = await post( 
  `https://api.trello.com/1/boards/?name=${encodeURIComponent(boardName)}&key=${TRELLO_API_KEY}&token=${TRELLO_API_TOKEN}` 
)

// Extract the board ID 
const { id: boardId } = response.data

// Create default lists on the new board 
for (const listName of defaultLists) {
  await post(
    `https://api.trello.com/1/lists?name=${encodeURIComponent(listName)}&idBoard=${boardId}&key=${TRELLO_API_KEY}&token=${TRELLO_API_TOKEN}`
  ) 
}

// Display a confirmation message with the board URL 
await div(md(`## Trello board created!\n\nhttps://trello.com/b/${boardId}`)) 

// Open the Trello board in the browser
await browse(`https://trello.com/b/${boardId}`) 
```

## Get CPU Usage History

```typescript
// Name: CPU Usage History 
// Description: Displays a history of CPU usage 
// Author: johnlindquist 

import "@johnlindquist/kit" 
import si from "systeminformation"
import Chart from "chart.js/auto" // Make sure to install Chart.js

// Initialize an array to store CPU usage data 
const cpuUsageData: number[] = [] 

// Create a widget to display the CPU usage chart
const cpuChartWidget = await widget(
  `<canvas id="cpu-chart" width="400" height="200"></canvas>`, 
  {
    width: 400,
    height: 250,
  } 
) 

// Create a Chart.js instance in the widget 
const cpuChart = new Chart(
  cpuChartWidget.querySelector("#cpu-chart"), 
  {
    type: "line",
    data: {
      // Use an empty array for labels initially, we'll update them dynamically 
      labels: [], 
      datasets: [
        {
          label: "CPU Usage",
          data: cpuUsageData, 
          borderColor: "rgb(75, 192, 192)",
          tension: 0.1, 
          fill: true, // Fill the area under the chart line 
        },
      ], 
    },
    options: {
      scales: {
        y: {
          // Set the y-axis scale to be from 0 to 100 (percentage) 
          min: 0,
          max: 100, 
        },
      }, 
    },
  }
)

// Update CPU usage data and chart every second 
setInterval(async () => {
  // Get the current CPU load 
  const { currentLoad } = await si.currentLoad() 

  // Add the current load to the data array 
  cpuUsageData.push(currentLoad)

  // Limit the data array to the last 60 data points (1 minute of data) 
  if (cpuUsageData.length > 60) {
    cpuUsageData.shift() 
  }

  // Update the chart labels to display the last 60 seconds 
  cpuChart.data.labels = Array.from({ length: 60 }, (_, i) => `${60 - i}s`).reverse() 

  // Update the chart with the new data
  cpuChart.update() 
}, 1000)

// Keep the script running in the background to maintain the chart 
hide()
```

## Create and Format Code Snippet

```typescript
// Name: Formatted Code Snippet Generator
// Description: Creates a formatted code snippet with syntax highlighting using highlight.js
// Author: johnlindquist 

import "@johnlindquist/kit"
import { highlight } from "highlight.js"

// Prompt for the code snippet content 
const codeSnippet = await editor({
  placeholder: "Enter your code snippet:",
}) 

// Prompt for the programming language
const language = await arg("Enter programming language:") 

// Highlight the code snippet using highlight.js 
const highlightedCode = highlight(codeSnippet, { language }).value

// Copy the highlighted code to the clipboard 
await copy(highlightedCode) 

// Display the highlighted code in a div 
await div(highlightedCode)
```

## Send a Message to a Slack Channel with a File Attachment

```typescript
// Name: Send Slack Message with File
// Description: Sends a message to a Slack channel with a file attachment 
// Author: johnlindquist 

import "@johnlindquist/kit"
import { WebClient } from "@slack/web-api" 

// Get your Slack API token from here: https://api.slack.com/apps
const slackToken = await env("SLACK_API_TOKEN")

// Prompt for the Slack channel 
const channel = await arg("Enter Slack channel:")

// Prompt for the message content
const message = await arg("Enter message:") 

// Prompt the user to select a file to attach
const filePath = await path() 

// Create a new instance of the Slack WebClient 
const slackClient = new WebClient(slackToken) 

// Upload the file and send the message with the file attachment 
await slackClient.files.upload({
  // Specify the file path 
  file: fs.createReadStream(filePath),
  // Set the file name 
  filename: path.basename(filePath),
  // Provide initial comment for the file
  initial_comment: message,
  // Specify the Slack channel 
  channels: channel, 
})

// Display a confirmation message 
await div(md(`## Message with file attachment sent to Slack!`))
```

##  Clean Up Trash

```typescript
// Name: Empty Trash
// Description: Empties the trash 
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for confirmation before emptying the trash
const shouldEmptyTrash = await arg("Are you sure you want to empty the trash?", ["Yes", "No"]) 

// Empty the trash 
if (shouldEmptyTrash === "Yes") {
  await trash(home(".Trash/*")) // Assuming the default trash location, adjust if necessary 
  await notify("Trash emptied!")
}
```

##  Compress Images in a Directory

```typescript
// Name: Bulk Image Compressor
// Description: Compresses images in a directory using sharp
// Author: johnlindquist

import "@johnlindquist/kit"
import sharp from "sharp"

// Prompt the user to select a directory 
const directoryPath = await path({ 
  onlyDirs: true,
})

// Prompt for the desired image quality (0-100)
const quality = parseInt(await arg("Enter desired image quality (0-100):")) 

// Get all image files in the directory
const imageFiles = await globby([`${directoryPath}/*.{jpg,jpeg,png,gif,webp}`])

// Create a progress bar 
let progress = 0
const progressBar = await div(md(`# Compressing Images

${progress}%`))

// Compress each image 
for (const imagePath of imageFiles) {
  // Compress the image using sharp
  await sharp(imagePath)
    // Preserve the original format
    .toFormat(path.extname(imagePath).slice(1), { quality })
    .toFile(imagePath)

  // Update the progress bar
  progress = Math.floor((imageFiles.indexOf(imagePath) / imageFiles.length) * 100) 
  progressBar.setState({
    html: md(`# Compressing Images 

    ${progress}%`),
  })
}

// Close the progress bar and display a notification 
progressBar.close()
await notify("Images compressed!", `in ${directoryPath}`)
```



## Check for Spelling Errors in Code Comments

```typescript
// Name: Code Comment Spell Checker
// Description: Checks for spelling errors in code comments using cspell
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the project directory
const directoryPath = await path({
  onlyDirs: true, 
})

// Run cspell to check for spelling errors in code comments within the directory 
// Requires cspell to be installed globally or locally: https://www.npmjs.com/package/cspell
await exec(`npx cspell "${directoryPath}/**/*.{js,ts,jsx,tsx}"`)
```

##  Get a List of Installed npm Packages

```typescript
// Name: List Installed npm Packages
// Description: Displays a list of installed npm packages in the current project
// Author: johnlindquist

import "@johnlindquist/kit" 

// Read the package.json file
const packageJson = await readJson(path.join(process.cwd(), "package.json"))

// Prompt for the type of dependencies to list 
const dependencyType = await arg("Select dependency type:", [ 
  "dependencies",
  "devDependencies",
  "peerDependencies",
  "optionalDependencies",
])

// Extract the selected dependencies from package.json
const dependencies = packageJson[dependencyType]

if (dependencies) {
  // Display the dependencies in the editor
  await editor(JSON.stringify(dependencies, null, 2), { language: "json" })
} else {
  // Display a message if no dependencies are found
  await div(md(`## No ${dependencyType} found in package.json.`))
}
```

## Create a New Google Sheets Spreadsheet

```typescript
// Name: Create Google Spreadsheet
// Description: Creates a new spreadsheet in Google Sheets
// Author: johnlindquist

import "@johnlindquist/kit"
import { google } from "googleapis" 
import { JWT } from "google-auth-library" 

// Get credentials for Google Service Account through environment variables 
// You can create service account credentials here: https://console.cloud.google.com/apis/credentials 
let SA_EMAIL = await env("GOOGLE_SA_EMAIL")
let SA_KEY = await env("GOOGLE_SA_CREDS") 

// Define the scopes and client
let jwtClient = new JWT({
  email: SA_EMAIL,
  key: SA_KEY,
  scopes: ["https://www.googleapis.com/auth/spreadsheets"],
}) 

// Create a new Google Sheets instance 
let sheets = google.sheets("v4")

// Prompt for the spreadsheet title
const spreadsheetTitle = await arg("Enter spreadsheet title:") 

// Create a new spreadsheet using the Google Sheets API
const { data: newSpreadsheet } = await sheets.spreadsheets.create({
  auth: jwtClient,
  requestBody: {
    properties: {
      title: spreadsheetTitle, 
    },
  },
})

// Display a confirmation message with the spreadsheet URL 
await div(md(`## Spreadsheet created at: ${newSpreadsheet.spreadsheetUrl}`)) 

// Open the newly created spreadsheet in the browser
await browse(newSpreadsheet.spreadsheetUrl)
```

##  Check for Available Software Updates (macOS)

```typescript
// Name: Check for Software Updates
// Description: Checks for and lists available software updates (macOS only) 
// Author: johnlindquist

import "@johnlindquist/kit"

// Check if running on macOS
if (isMac) { 
  // Run the 'softwareupdate' command to list available updates 
  let { stdout: updates } = await exec(`softwareupdate --list`, { shell: true }) 

  if (updates.includes("No new software available.")) {
    // Display a notification if no updates are available 
    await notify("No software updates available.")
  } else {
    // Display the available updates in the editor
    await editor(updates, {
      language: "text", 
    }) 
  } 
} else { 
  // Display a message if the script is run on a non-macOS system
  await div(md(`## This script is only supported on macOS.`)) 
}
```

## Download and Extract a ZIP File

```typescript
// Name: Download and Extract ZIP
// Description: Downloads and extracts a ZIP file from a URL 
// Author: johnlindquist

import "@johnlindquist/kit" 
import download from "download"

// Prompt for the ZIP file URL
const fileUrl = await arg("Enter ZIP file URL:") 

// Prompt the user to select a directory to extract the ZIP file to
const destinationPath = await path({ 
  onlyDirs: true, 
}) 

// Download and extract the ZIP file using the 'download' package
// This combines downloading and extraction in one step
await download(fileUrl, destinationPath, { extract: true }) 

// Display a notification 
await notify("ZIP file downloaded and extracted!", `to ${destinationPath}`) 
```

## Find and Remove Unused Images

```typescript
// Name: Unused Image Finder 
// Description: Finds and removes unused images in a project directory
// Author: johnlindquist 

import "@johnlindquist/kit" 

// Prompt the user to select a project directory
const projectPath = await path({ 
  onlyDirs: true,
}) 

// Prompt for the glob pattern for the project's source code files
const codeGlob = await arg({
  placeholder: "Enter glob pattern for code files (e.g., src/**/*.{js,ts,jsx,tsx,html,css}): ", 
  defaultValue: "src/**/*.{js,ts,jsx,tsx,html,css}", 
})

// Prompt for the glob pattern for the image directory 
const imagesGlob = await arg({
  placeholder: "Enter glob pattern for images (e.g., public/images/**/*):", 
  defaultValue: "public/images/**/*",
})

// Use ripgrep to find image file names that are referenced in the source code
// Extract the matched file names using a capture group
let { stdout: usedImages } = await exec(`rg -T ts,tsx,js,jsx,json,html,css,scss,less --no-filename --only-matching "['\"]((?:images|assets)\\/.*?)['\"]" ${projectPath}/${codeGlob}`, { shell: true })

// Split the output into an array of image paths
usedImages = usedImages
  .split("\n") 
  .map(image => image.trim().replace(/("|')/g, "")) // Remove quotes from image paths 
  .filter(image => image.length > 0) // Remove any empty strings

// Get the list of all image files in the image directory
const allImages = await globby([`${projectPath}/${imagesGlob}`]) 

// Find unused images by filtering out the used images from all images 
const unusedImages = allImages.filter((image) => !usedImages.includes(path.basename(image))) 

if (unusedImages.length > 0) {
  // Display a list of unused images and prompt for confirmation to remove them 
  let shouldRemove = await arg(
    {
      placeholder: `Found ${unusedImages.length} unused images. Remove them?`,
      // Display the unused image paths in the preview 
      preview: md(unusedImages.map(image => `- ${image}`).join("\n")),
      // Set a custom height for the prompt
      height: PROMPT.HEIGHT.LG,
    },
    ["Yes", "No"]
  )

  if (shouldRemove === "Yes") {
    // Remove the unused images
    await trash(unusedImages)
    await notify("Unused images removed!") 
  }
} else {
  // Display a message if no unused images are found
  await div(md(`## No unused images found.`)) 
} 
```

## Generate a Project Timeline

```typescript
// Name: Generate Project Timeline
// Description: Creates a project timeline visualization using the Git history and Mermaid.js
// Author: johnlindquist 

import "@johnlindquist/kit"

// Prompt for the project directory path 
const projectPath = await path({ 
  onlyDirs: true,
})

// Get the Git log, formatted for Mermaid.js Gantt chart syntax
const { stdout: gitLog } = await exec(`git log --pretty=format:"%ad | %s" --date=short --no-merges`, {
  shell: true,
  cwd: projectPath, 
}) 

// Create the Mermaid.js code for the Gantt chart
const mermaidCode = `
\`\`\`mermaid 
gantt
  dateFormat YYYY-MM-DD 
  section Project Timeline 
${gitLog.split("\n").map(line => `  ${line.replace("|", ":")}`).join("\n")}
\`\`\`
`

// Display the Mermaid.js code in the editor 
await editor(mermaidCode, {
  language: "markdown",
}) 
```


## Send a Message to a Microsoft Teams Channel

```typescript
// Name: Send Microsoft Teams Message
// Description: Sends a message to a Microsoft Teams channel using the Bot Framework SDK
// Author: johnlindquist 

import "@johnlindquist/kit"
import {
  TeamsActivityHandler,
  TurnContext,
  MessageFactory,
  BotFrameworkAdapter, 
} from "botbuilder"

// Get the Microsoft Teams App ID and App Password from environment variables
// You can get them from the Azure portal after registering your bot: 
// https://docs.microsoft.com/en-us/azure/bot-service/bot-builder-basics?view=azure-bot-service-4.0
const TEAMS_APP_ID = await env("TEAMS_APP_ID") 
const TEAMS_APP_PASSWORD = await env("TEAMS_APP_PASSWORD") 

// Prompt for the Microsoft Teams channel ID
// You can find the channel ID in the Teams channel URL 
const channelId = await arg("Enter Microsoft Teams channel ID:")

// Prompt for the message to send
const message = await arg("Enter message:")

// Create a new Teams activity handler for the bot 
class TeamsBot extends TeamsActivityHandler {
  // Handle incoming messages 
  async onMessageActivity(context: TurnContext) {
    // Send the message to the channel
    await context.sendActivity(MessageFactory.text(message))
  } 
}

// Create a new Bot Framework Adapter
const adapter = new BotFrameworkAdapter({ 
  appId: TEAMS_APP_ID, 
  appPassword: TEAMS_APP_PASSWORD,
}) 

// Create a new instance of the bot
const bot = new TeamsBot()

// Process the incoming activity (in this case, sending a message) 
adapter.processActivity(
  {}, // Mock request object, not relevant for this example 
  async (context) => {
    // Route the activity to the bot
    await bot.run(context)
  }
)

// Display a confirmation message
await div(md(`## Message sent to Microsoft Teams channel!`))
```

## Create a New Notion Page

```typescript
// Name: Create Notion Page
// Description: Creates a new page in Notion using the Notion API 
// Author: johnlindquist

import "@johnlindquist/kit"

// Get your Notion API token from here: https://www.notion.so/my-integrations
const NOTION_API_TOKEN = await env("NOTION_API_TOKEN")

// Prompt for the parent page ID
// You can find the Page ID in the URL of the Notion page
const parentPageId = await arg("Enter parent page ID:")

// Prompt for the title of the new page
const pageTitle = await arg("Enter page title:")

// Create the new page in Notion using the API 
await post( 
  `https://api.notion.com/v1/pages`,
  {
    parent: {
      page_id: parentPageId,
    }, 
    properties: {
      title: [
        {
          text: {
            content: pageTitle,
          },
        }, 
      ],
    },
  }, 
  {
    headers: {
      Authorization: `Bearer ${NOTION_API_TOKEN}`,
      "Content-Type": "application/json", 
      "Notion-Version": "2022-06-28",
    },
  }
)

// Display a confirmation message
await div(md(`## Notion page created successfully!`))
```

## Convert Speech to Text with Whisper

```typescript
// Name: Transcribe Audio with Whisper
// Description: Transcribes speech from an audio file using OpenAI's Whisper API
// Author: johnlindquist

import "@johnlindquist/kit"
import OpenAI from "openai" 

// Get your OpenAI API key from here: https://beta.openai.com/account/api-keys
const OPENAI_API_KEY = await env("OPENAI_API_KEY")

// Create a new OpenAI instance
const openai = new OpenAI({
  apiKey: OPENAI_API_KEY,
})

// Prompt the user to select an audio file
const audioFilePath = await path({
  filters: [{ name: "Audio", extensions: ["mp3", "wav", "m4a", "ogg"] }], 
})

// Read the contents of the audio file 
const audioBuffer = await readFile(audioFilePath)

// Convert the audio buffer to a file for the API
const audioFile = await toFile(audioBuffer, "audio.mp3")

// Transcribe the audio using the Whisper API 
const response = await openai.audio.transcriptions.create({
  file: audioFile,
  model: "whisper-1", 
})

// Extract the transcribed text
const transcribedText = response.text 

// Display the transcribed text in the editor
await editor(transcribedText, {
  language: "text", 
})
```

## Download Files Concurrently

```typescript
// Name: Parallel File Downloader
// Description: Downloads multiple files concurrently using 'p-map' 
// Author: johnlindquist

import "@johnlindquist/kit" 
import pMap from "p-map"

// Prompt the user to enter a comma-separated list of file URLs
const urlsString = await arg("Enter file URLs (comma-separated):") 

// Split the input string into an array of URLs 
const urls = urlsString.split(",").map(url => url.trim()) 

// Download files concurrently using p-map, limiting concurrency to 5
await pMap(
  urls,
  async (url) => {
    // Display a progress message for each file
    await div(md(`# Downloading ${url}...`)) 
    // Download the file to the Downloads directory 
    await download(url, home("Downloads"))
  }, 
  { concurrency: 5 } 
)

// Display a notification 
await notify("Files downloaded!") 
```

## Get User's Public Repositories on GitLab

```typescript
// Name: GitLab Repo Lister
// Description: Displays a list of public repositories for a GitLab user 
// Author: johnlindquist

import "@johnlindquist/kit"

// Get your GitLab Personal Access Token here: https://gitlab.com/-/profile/personal_access_tokens
const GITLAB_ACCESS_TOKEN = await env("GITLAB_ACCESS_TOKEN") 

// Prompt for the GitLab username 
const username = await arg("Enter GitLab username:") 

// Fetch the user's public repositories from the GitLab API
const response = await get(`https://gitlab.com/api/v4/users/${username}/projects`, { 
  headers: {
    Authorization: `Bearer ${GITLAB_ACCESS_TOKEN}`, 
  }, 
}) 

// Extract repository names and URLs 
const repositories = response.data.map(repo => ({ 
  name: repo.name,
  url: repo.web_url, 
})) 

// Display the list of repositories as choices
const selectedRepo = await arg( 
  "Select a repository:",
  repositories
)

// Open the selected repository in the browser 
await browse(selectedRepo)
```

## Check for Outdated Global npm Packages

```typescript
// Name: Global Outdated Package Checker 
// Description: Checks for outdated globally installed npm packages 
// Author: johnlindquist 

import "@johnlindquist/kit" 

// Run 'npm outdated -g --long' to get a list of outdated global packages
let { stdout: outdatedPackages } = await exec("npm outdated -g --long", { shell: true }) 

// Check if any packages are outdated
if (outdatedPackages.trim().length > 0) { 
  // Display the outdated packages in the editor
  await editor(outdatedPackages, { language: "text" }) 
} else {
  // Display a message if no outdated packages are found 
  await div(md(`## All global npm packages are up to date! ðŸŽ‰`))
}
```

## Remove Duplicate Lines from Clipboard

```typescript
// Name: Remove Duplicate Clipboard Lines
// Description: Removes duplicate lines from clipboard content 
// Author: johnlindquist 

import "@johnlindquist/kit"

// Get the text from the clipboard
const text = await paste()

// Split the text into lines
const lines = text.split("\n")

// Remove duplicate lines, preserving the order
const uniqueLines = [...new Set(lines)] 

// Join the unique lines back into a string
const newText = uniqueLines.join("\n") 

// Copy the modified text back to the clipboard
await copy(newText)

// Display a notification 
await notify("Duplicate lines removed from clipboard!")
```


## Create and Send a Scheduled Tweet

```typescript
// Name: Schedule Tweet
// Description: Schedules a tweet to be sent at a later time
// Author: johnlindquist

import "@johnlindquist/kit"
import TwitterApi from "twitter-api-v2"
import schedule from "node-schedule"

// Retrieve Twitter API credentials from environment variables
// You can create API keys and tokens here: https://developer.twitter.com/en/portal/dashboard
const TWITTER_API_KEY = await env("TWITTER_API_KEY") 
const TWITTER_API_SECRET = await env("TWITTER_API_SECRET")
const TWITTER_ACCESS_TOKEN = await env("TWITTER_ACCESS_TOKEN")
const TWITTER_ACCESS_SECRET = await env("TWITTER_ACCESS_SECRET")

// Create a new instance of the Twitter API client
const twitterClient = new TwitterApi({
  appKey: TWITTER_API_KEY,
  appSecret: TWITTER_API_SECRET, 
  accessToken: TWITTER_ACCESS_TOKEN, 
  accessSecret: TWITTER_ACCESS_SECRET,
})

// Prompt for the tweet content 
const tweetContent = await arg("Enter your tweet:")

// Prompt for the scheduled time (in cron format)
const scheduleTime = await arg({ 
  placeholder: "Enter schedule time (cron format):",
  hint: "Example: 0 9 * * * (every day at 9 AM)",
})

// Authenticate with the Twitter API
const client = await twitterClient.readWrite

// Schedule the tweet
schedule.scheduleJob(scheduleTime, async () => { 
  // Send the tweet
  await client.v2.tweet(tweetContent)

  // Display a notification when the tweet is sent 
  await notify("Scheduled tweet sent!")
})

// Display a confirmation message
await div(md(`## Tweet scheduled to be sent at: ${scheduleTime}`)) 
```

## Extract Text from Multiple Images

```typescript
// Name: Bulk Image Text Extractor
// Description: Extracts text from multiple images using Tesseract OCR
// Author: johnlindquist

import "@johnlindquist/kit"
import Tesseract from "tesseract.js" 

// Prompt the user to select or drop multiple image files 
let imageFilePaths = await getSelectedFile()

// If no files are selected, prompt the user to drop files
if (!imageFilePaths) {
  imageFilePaths = await drop({
    placeholder: "Drop image files here...",
    multiple: true, 
  }) 
  // Extract file paths from the dropped files 
  imageFilePaths = imageFilePaths.map(file => file.path)
} else { 
  // Split the selected file paths into an array
  imageFilePaths = imageFilePaths.split("\n")
} 

// Create a temporary directory to store the extracted text files
const outputDir = tmpPath("extracted-text") 
await ensureDir(outputDir)

// Display a progress bar while extracting text 
let progress = 0 
const progressBar = await div(md(`# Extracting text from images...

${progress}%`)) 

// Extract text from each image using Tesseract OCR
for (const imagePath of imageFilePaths) {
  // Perform OCR 
  const { data: { text } } = await Tesseract.recognize(imagePath) 

  // Create the output file path for the extracted text 
  const outputFilePath = path.join(outputDir, `${path.basename(imagePath, path.extname(imagePath))}.txt`) 

  // Write the extracted text to the output file 
  await writeFile(outputFilePath, text) 

  // Update the progress bar
  progress = Math.floor((imageFilePaths.indexOf(imagePath) / imageFilePaths.length) * 100)
  progressBar.setState({ 
    html: md(`# Extracting text from images...

    ${progress}%`),
  }) 
}

// Close the progress bar and display a notification
progressBar.close()
await notify("Text extraction complete!", `Extracted text saved to ${outputDir}`) 

// Reveal the output directory in Finder
await revealFile(outputDir) 
```

## Get User's Location and Display Nearby Restaurants

```typescript
// Name: Find Restaurants Near Me
// Description: Finds and displays restaurants near the user's current location using the Google Places API 
// Author: johnlindquist 

import "@johnlindquist/kit"

// Get your Google Maps API key from here: https://developers.google.com/maps/documentation/javascript/get-api-key
const GOOGLE_MAPS_API_KEY = await env("GOOGLE_MAPS_API_KEY") 

// Get the user's current location using the browser's geolocation API
const { coords } = await new Promise<GeolocationPosition>((resolve, reject) => {
  navigator.geolocation.getCurrentPosition(resolve, reject)
})

// Fetch nearby restaurants from the Google Places API
const response = await get( 
  `https://maps.googleapis.com/maps/api/place/nearbysearch/json?location=${coords.latitude},${coords.longitude}&radius=1500&type=restaurant&key=${GOOGLE_MAPS_API_KEY}` 
)

// Extract the restaurant data from the response
const restaurants = response.data.results 

// Create an array of choices from the fetched restaurants
const restaurantChoices = restaurants.map((restaurant) => ({
  name: restaurant.name,
  value: `https://www.google.com/maps/search/?api=1&query=${restaurant.geometry.location.lat},${restaurant.geometry.location.lng}&query_place_id=${
    restaurant.place_id
  }`,
  // Show the restaurant's rating and address as the description 
  description: `${restaurant.rating ? `Rating: ${restaurant.rating} stars` : "No rating"} - ${
    restaurant.vicinity
  }`,
})) 

// Prompt the user to select a restaurant
const selectedRestaurantUrl = await arg({
  placeholder: "Select a restaurant", 
  enter: "Open in Browser", 
}, restaurantChoices)

// Open the Google Maps link for the selected restaurant in the browser
await browse(selectedRestaurantUrl)
```

## Convert Text to Speech and Save to File with Custom Voice

```typescript
// Name: Text to Speech with Custom Voice
// Description: Converts text to speech with a custom voice from ElevenLabs and saves it to a file 
// Author: johnlindquist 

import "@johnlindquist/kit" 

// Get your ElevenLabs API key from here: https://elevenlabs.io/ 
const ELEVENLABS_API_KEY = await env("ELEVENLABS_API_KEY") 

// Prompt for the text to convert
const text = await arg("Enter text to convert to speech:")

// Prompt for the ElevenLabs voice ID
// You can find your voice ID in your ElevenLabs profile:
const voiceId = await env("ELEVENLABS_VOICE_ID")

// Prompt for the desired output format 
const outputFormat = await arg("Enter output audio format (e.g., mp3, wav):")

// Send a request to the ElevenLabs API 
const response = await post(
  `https://api.elevenlabs.io/v1/text-to-speech/${voiceId}`, 
  {
    text,
    voice_settings: {
      stability: 0.5, // Adjust voice stability (0-1) 
      similarity_boost: 0.5, // Adjust voice similarity boost (0-1)
    }, 
  }, 
  {
    headers: {
      "xi-api-key": ELEVENLABS_API_KEY, 
      "Content-Type": "application/json",
      Accept: `audio/${outputFormat}`, // Set the desired output format
    }, 
    // Specify the response type as a stream
    responseType: "stream",
  } 
) 

// Create a path for the output audio file in the Downloads directory
const outputFilePath = path.join(home("Downloads"), `speech-${Date.now()}.${outputFormat}`)

// Create a write stream for the output file 
const fileStream = createWriteStream(outputFilePath)

// Pipe the audio data from the response to the output file
response.data.pipe(fileStream)

// Display a notification when the download is complete
fileStream.on("finish", async () => { 
  await notify("Audio file created!", `Saved to ${outputFilePath}`)
})
```

##  Generate a Project README with User Input 

```typescript 
// Name: Interactive README Generator
// Description: Creates a README.md file with interactive prompts 
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the project title
const projectTitle = await arg("Enter project title:")

// Prompt for a short project description 
const projectDescription = await arg("Enter project description:") 

// Prompt for a list of project features (comma-separated)
const features = await arg("Enter project features (comma-separated):")
  .split(",") 
  .map((feature) => `- ${feature.trim()}`) // Format each feature as a list item
  .join("\n") 

// Create the README content
const readmeContent = `# ${projectTitle}

## Description

${projectDescription}

## Features

${features}

## Installation

\`\`\`bash
npm install 
\`\`\`

## Usage

\`\`\`bash 
npm start
\`\`\`
` 

// Write the README content to a README.md file in the current directory
await writeFile("README.md", readmeContent)

// Open the README.md file in the editor 
await edit("README.md") 
```

##  Run a Speed Test

```typescript
// Name: Internet Speed Test 
// Description: Runs an internet speed test using the 'fast.com' CLI
// Author: johnlindquist

import "@johnlindquist/kit" 

// Run the 'fast.com' CLI to perform a speed test
// This assumes you have 'fast.com' installed globally: https://www.npmjs.com/package/fast.com
await exec(`npx fast.com`, {
  shell: true,
  // Show the output of the speed test in the terminal
  stdio: "inherit", 
})
```

## Extract Images from a Website

```typescript
// Name: Website Image Extractor
// Description: Extracts images from a website using Puppeteer
// Author: johnlindquist 

import "@johnlindquist/kit" 
import puppeteer from "puppeteer" 

// Prompt for the website URL
const url = await arg("Enter website URL:")

// Create a temporary directory to store the extracted images
const outputDir = tmpPath("images") 
await ensureDir(outputDir)

// Launch a headless browser instance using Puppeteer
const browser = await puppeteer.launch({ headless: "new" }) 

try {
  // Create a new page 
  const page = await browser.newPage() 

  // Navigate to the provided URL 
  await page.goto(url, { waitUntil: "networkidle0" })

  // Get all image elements on the page
  const imageElements = await page.$$("img")

  // Display a progress bar while extracting images
  let imageCount = 0
  const progressBar = await div(md(`# Extracting images...

${imageCount} of ${imageElements.length}`)) 

  // Extract and save each image
  for (const imageElement of imageElements) {
    // Get the image source URL
    const imageUrl = await page.evaluate(el => el.src, imageElement)

    // Download the image to the temporary directory
    try {
      await download(imageUrl, outputDir) 
    } catch (error) {
      // Handle errors, such as invalid image URLs, gracefully
      console.error(`Error downloading image: ${error}`) 
    }

    // Update the progress bar 
    imageCount++
    progressBar.setState({
      html: md(`# Extracting images...

      ${imageCount} of ${imageElements.length}`),
    })
  } 

  // Close the progress bar 
  progressBar.close() 

  // Display a notification
  await notify("Images extracted!", `Saved to ${outputDir}`)

  // Reveal the extracted images in Finder 
  await revealFile(outputDir) 

} finally { 
  // Close the browser instance 
  await browser.close() 
}
```



## Send a Message to a Discord Channel with Rich Text Formatting 

```typescript
// Name: Send Rich Discord Message
// Description: Sends a message to a Discord channel with rich text formatting using Discord.js
// Author: johnlindquist

import "@johnlindquist/kit"
import { Client, IntentsBitField } from "discord.js"

// Get your Discord Bot Token from here: https://discord.com/developers/applications
const DISCORD_BOT_TOKEN = await env("DISCORD_BOT_TOKEN")

// Prompt for the Discord channel ID 
const channelId = await arg("Enter Discord channel ID:") 

// Prompt for the message content using the editor with Markdown support
let message = await editor({
  placeholder: "Enter message (Markdown supported):",
  language: "markdown", 
})

// Convert the Markdown to Discord's rich text format 
message = message
  .replace(/\*\*(.*?)\*\*/g, "**$1**") // Bold
  .replace(/\*(.*?)\*/g, "*$1*") // Italics
  .replace(/__(.*?)__/g, "__$1__") // Underline 
  .replace(/~~(.*?)~~/g, "~~$1~~") // Strikethrough
  .replace(/`(.*?)`/g, "`$1`") // Code

// Create a new Discord client instance 
const client = new Client({ intents: [IntentsBitField.Flags.Guilds] })

// Log in to Discord using the bot token
client.login(DISCORD_BOT_TOKEN)

// Send the message to the specified channel once the client is ready 
client.on("ready", async () => {
  // Find the channel by its ID
  const channel = client.channels.cache.get(channelId) 

  // Send the formatted message to the channel 
  if (channel?.isTextBased()) {
    await channel.send(message)
    console.log(`Message sent to channel ${channelId}`)
  } else { 
    console.error(`Channel ${channelId} not found or not a text channel.`) 
  } 

  // Disconnect from Discord
  client.destroy()
})
```

## Find and Replace Text Across Multiple Directories

```typescript
// Name: Multi-Directory Find and Replace 
// Description: Finds and replaces text in files across multiple directories
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user to select the root directory
const rootDirectoryPath = await path({
  onlyDirs: true, // Only allow selecting directories
}) 

// Prompt for the text to find
const searchText = await arg("Enter text to find:")

// Prompt for the replacement text 
const replacementText = await arg("Enter replacement text:") 

// Prompt for the file extensions to search (comma-separated) 
const extensions = await arg("Enter file extensions to search (comma-separated):") 
  .split(",") 
  .map(extension => extension.trim()) 
  .join(",") // Join the extensions with a comma for use in the glob pattern

// Find and replace text in all files with the specified extensions within the selected directory
await exec(`find '${rootDirectoryPath}' -type f -name "*.{${extensions}}" -exec sed -i '' 's/${searchText}/${replacementText}/g' {} +`, {
  shell: true, 
})

// Display a confirmation message
await div(md(`## Find and replace complete in ${rootDirectoryPath}!`))
```

## Create a Time-Lapse Video from Webcam

```typescript
// Name: Webcam Time-lapse
// Description: Creates a time-lapse video from webcam captures
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt for the duration of the time-lapse (in minutes)
const durationMinutes = parseFloat(await arg("Enter time-lapse duration (minutes):")) 

// Prompt for the interval between captures (in seconds)
const intervalSeconds = parseInt(await arg("Enter interval between captures (seconds):")) 

// Prompt for the output file path
const outputFilePath = await path({
  startPath: home("Downloads"), 
})

// Create a temporary directory for captured images 
const capturesDir = tmpPath("captures") 
await ensureDir(capturesDir) 

// Calculate the total number of captures 
const totalCaptures = Math.floor(durationMinutes * 60 / intervalSeconds) 

// Display a progress bar while capturing images
let captureCount = 0 
const progressBar = await div(md(`# Capturing webcam images...

${captureCount} of ${totalCaptures}`)) 

// Capture images from the webcam at the specified interval
let intervalId = setInterval(async () => {
  // Capture an image from the webcam 
  const capturePath = path.join(capturesDir, `capture-${captureCount}.jpg`)
  await webcam({
    // Set a custom file path for the captured image
    filePath: capturePath,
  }) 

  // Increment the capture count and update the progress bar 
  captureCount++
  progressBar.setState({ 
    html: md(`# Capturing webcam images...

    ${captureCount} of ${totalCaptures}`),
  })

  // Stop the timer when all captures are done 
  if (captureCount >= totalCaptures) {
    clearInterval(intervalId) 
    // Close the progress bar
    progressBar.close() 
  }
}, intervalSeconds * 1000)

// Wait for the captures to complete
await wait(durationMinutes * 60 * 1000)

// Generate the time-lapse video from the captured images using ffmpeg
await exec(`ffmpeg -y -framerate 30 -pattern_type glob -i '${capturesDir}/*.jpg' -c:v libx264 -pix_fmt yuv420p '${outputFilePath}'`, { shell: true }) 

// Display a notification
await notify("Time-lapse video created!", `Saved to ${outputFilePath}`) 

// Reveal the time-lapse video in Finder 
await revealFile(outputFilePath) 
```

##  Compress a Directory

```typescript
// Name: Compress Directory 
// Description: Compresses a directory into a ZIP archive
// Author: johnlindquist

import "@johnlindquist/kit" 
import archiver from "archiver" 

// Prompt the user to select a directory to compress
const directoryPath = await path({
  onlyDirs: true, // Only allow selecting directories
})

// Prompt for the output file path for the ZIP archive
const outputFilePath = await path({
  // Suggest a ZIP file name based on the directory name
  suggestion: `${path.basename(directoryPath)}.zip`, 
  startPath: home("Downloads"), 
})

// Create a write stream for the output file
const output = createWriteStream(outputFilePath)

// Create a new archiver instance for ZIP compression
const archive = archiver("zip", {
  zlib: { level: 9 }, // Set the compression level
}) 

// Listen for errors during archiving 
archive.on("error", (error) => { 
  throw error
})

// Finalize the archive when done
output.on("close", () => { 
  console.log(`Archive created at: ${outputFilePath}`)
})

// Pipe the archive data to the output stream 
archive.pipe(output)

// Add the selected directory to the archive
archive.directory(directoryPath, false)

// Finalize the archive
await archive.finalize()

// Display a notification
await notify("Directory compressed!", `Saved to ${outputFilePath}`)
```

## Convert Text to Speech with Amazon Polly

```typescript
// Name: Text to Speech (Amazon Polly)
// Description: Converts text to speech using Amazon Polly
// Author: johnlindquist

import "@johnlindquist/kit"
import { Polly } from "@aws-sdk/client-polly"

// Configure AWS credentials (you need to set up your AWS credentials) 
// More info: https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/setting-credentials-node.html
const polly = new Polly({
  region: await env("AWS_REGION", "us-east-1"), 
  credentials: {
    accessKeyId: await env("AWS_ACCESS_KEY_ID"),
    secretAccessKey: await env("AWS_SECRET_ACCESS_KEY"),
  }, 
}) 

// Prompt for the text to convert
const text = await arg("Enter text to convert to speech:")

// Prompt for the voice ID 
// You can find a list of available voices here: https://docs.aws.amazon.com/polly/latest/dg/voicelist.html
const voiceId = await arg("Enter Amazon Polly voice ID:")

// Send a synthesizeSpeech request to Amazon Polly 
const command = await polly.synthesizeSpeechCommand({
  Text: text, 
  OutputFormat: "mp3", 
  VoiceId: voiceId,
})

// Execute the command and get the audio stream
const { AudioStream } = await polly.send(command)

// Create the output file path in the Downloads directory
const outputFilePath = path.join(home("Downloads"), `speech-${Date.now()}.mp3`) 

// Create a write stream for the output file
const fileStream = createWriteStream(outputFilePath)

// Pipe the audio stream from Amazon Polly to the output file 
AudioStream.pipe(fileStream)

// Wait for the audio file to be written
await new Promise(resolve => fileStream.on("finish", resolve)) 

// Display a notification
await notify("Audio file created!", `Saved to ${outputFilePath}`)

// Reveal the audio file in Finder
await revealFile(outputFilePath) 
```

##  Generate Project Documentation with Customization

```typescript
// Name: Custom Documentation Generator
// Description: Generates documentation for a TypeScript project with customizable options
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the output directory for the documentation
const outputDir = await arg("Enter output directory:")

// Prompt for the documentation theme 
const theme = await arg("Select documentation theme:", ["default", "minimal", "sidebar", "navigator"])

// Prompt for additional TypeDoc options (e.g., --ignoreCompilerErrors, --exclude) 
const additionalOptions = await arg("Enter additional TypeDoc options (optional):")

// Generate documentation using TypeDoc, passing in the output directory, theme, and additional options 
await exec(`npx typedoc --out ${outputDir} --theme ${theme} ${additionalOptions} src`, {
  shell: true,
})

// Display a notification
await notify("Documentation generated!", `Saved to ${outputDir}`)
```

## Convert a Video File to a Different Format

```typescript
// Name: Video Format Converter
// Description: Converts a video file to a different format using ffmpeg
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt for the video file path 
const videoFilePath = await path({
  filters: [{ name: "Videos", extensions: ["mp4", "mov", "avi", "mkv", "webm"] }],
})

// Prompt for the desired output format 
const outputFormat = await arg("Enter output video format (e.g., mp4, avi, webm):") 

// Extract the directory and file name from the video file path
const { dir, name } = path.parse(videoFilePath) 

// Construct the output file path based on the directory, file name, and output format
const outputFilePath = path.join(dir, `${name}.${outputFormat}`) 

// Use ffmpeg to convert the video to the specified format
await exec(`ffmpeg -i '${videoFilePath}' '${outputFilePath}'`, { shell: true })

// Display a notification
await notify("Video converted!", `Saved to ${outputFilePath}`) 

// Reveal the converted video in Finder 
await revealFile(outputFilePath)
```

## Delete Commits from Git History

```typescript
// Name: Delete Git Commits
// Description: Deletes commits from Git history using an interactive rebase 
// Author: johnlindquist 

import "@johnlindquist/kit"

// Display a warning message about the risks of modifying Git history
await div(md(`
## Warning: Modifying Git history can be dangerous!

Make sure you understand the implications before proceeding. 
`)) 

// Prompt for the number of commits to display in the interactive rebase
const commitCount = parseInt(await arg("Enter number of commits to rebase:")) 

// Start an interactive rebase using git rebase
await term({
  command: `git rebase -i HEAD~${commitCount}`,
  // Set a custom height for the terminal window
  height: 400,
}) 
```



## Find and Replace Text in File

```typescript
// Name: Find and Replace in File
// Description: Finds and replaces text within a specific file 
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user to select a file
const filePath = await path()

// Prompt for the text to find
const searchText = await arg("Enter text to find:")

// Prompt for the replacement text
const replacementText = await arg("Enter replacement text:")

// Replace the text in the selected file using sed 
await exec(`sed -i '' 's/${searchText}/${replacementText}/g' "${filePath}"`, { shell: true })

// Display a notification
await notify("Text replaced!", `in ${filePath}`)
```

## Create and Share a Code Snippet with Carbon

```typescript
// Name: Share Code Snippet on Carbon
// Description: Creates a visually appealing code snippet using Carbon and copies the share link 
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt for the code snippet
const codeSnippet = await editor({
  placeholder: "Enter your code snippet:",
})

// Prompt for the programming language
const language = await arg("Enter programming language:")

// Construct the Carbon URL with the code snippet and language 
const carbonUrl = `https://carbon.now.sh/?code=${encodeURIComponent(codeSnippet)}&l=${language}`

// Open the generated Carbon image in the browser 
await browse(carbonUrl)

// Wait for the user to customize and export the image on Carbon 
await arg(
  {
    placeholder: "Press Enter when you've created your Carbon image...",
    // Hide the prompt to avoid obstruction 
    show: false,
  }
)

// Get the URL of the generated Carbon image from the clipboard (assuming the user copied the share link)
const sharedImageUrl = await paste()

// Display the shared image URL in a div
await div(md(`## Carbon Image URL: \n\n ${sharedImageUrl}`))

// Copy the URL back to the clipboard
await copy(sharedImageUrl)
```

## Get System Disk Space Details

```typescript
// Name: Get Disk Space Details
// Description: Shows detailed disk space information for all mounted drives
// Author: johnlindquist

import "@johnlindquist/kit"
import si from "systeminformation"

// Get disk layout information
const diskLayout = await si.diskLayout() 

// Create an array of promises to fetch disk usage for each partition
const diskUsagePromises = diskLayout.map(async (disk) => {
  const diskUsage = await si.fsSize({ fstype: disk.fstype }) 
  const usage = diskUsage.find(usage => usage.fs === disk.fs)
  return {
    ...disk, 
    ...usage,
  }
})

// Resolve all promises to get an array of disk usage objects 
const diskUsages = await Promise.all(diskUsagePromises)

// Create choices for each disk, including detailed information in the preview 
const diskChoices = diskUsages.map(disk => ({
  name: `${disk.name} (${disk.mount})`,
  value: disk,
  // Show detailed disk information in the preview, formatting sizes using filesize
  preview: md(`
## Disk: ${disk.name} 

* Mount Point: ${disk.mount}
* Type: ${disk.type}
* File System: ${disk.fstype} 
* Total Size: ${filesize(disk.size)}
* Used: ${filesize(disk.used)}
* Available: ${filesize(disk.available)}
* Use%: ${disk.use}
`),
}))

// Prompt the user to select a disk
const selectedDisk = await arg({
  placeholder: "Select a disk:",
  // Use a custom width and height for the prompt
  width: PROMPT.WIDTH.LG, 
  height: PROMPT.HEIGHT.LG, 
}, diskChoices)

// Display detailed information about the selected disk in a div
await div(
  md(`
## Disk Details: 

* Name: ${selectedDisk.name}
* Mount Point: ${selectedDisk.mount} 
* Type: ${selectedDisk.type} 
* File System: ${selectedDisk.fstype}
* Total Size: ${filesize(selectedDisk.size)}
* Used: ${filesize(selectedDisk.used)}
* Available: ${filesize(selectedDisk.available)}
* Use%: ${selectedDisk.use}
  `),
  // Use a custom width for the div
  "w-3/4"
)
```

## Convert Text to Speech with Microsoft Azure

```typescript
// Name: Text to Speech (Azure)
// Description: Converts text to speech using the Microsoft Azure Text-to-Speech API 
// Author: johnlindquist 

import "@johnlindquist/kit" 
import { SpeechSdk } from "microsoft-cognitiveservices-speech-sdk"

// Get your Azure Speech service subscription key and region from the Azure portal:
// https://docs.microsoft.com/en-us/azure/cognitive-services/speech-service/get-started
const AZURE_SPEECH_KEY = await env("AZURE_SPEECH_KEY")
const AZURE_SPEECH_REGION = await env("AZURE_SPEECH_REGION") 

// Prompt the user for the text to convert to speech
const text = await arg("Enter text to convert to speech:") 

// Prompt for the voice name
// You can find a list of available voices here: https://docs.microsoft.com/en-us/azure/cognitive-services/speech-service/language-support#text-to-speech 
const voiceName = await arg("Enter Azure Speech voice name (e.g., en-US-JennyNeural):") 

// Create a speech configuration object 
const speechConfig = speech.SpeechConfig.fromSubscription(
  AZURE_SPEECH_KEY, 
  AZURE_SPEECH_REGION
)

// Set the voice name 
speechConfig.speechSynthesisVoiceName = voiceName 

// Create an audio configuration object to play the audio directly 
const audioConfig = speech.AudioConfig.fromDefaultSpeakerOutput()

// Create a speech synthesizer
const synthesizer = new speech.SpeechSynthesizer(speechConfig, audioConfig)

// Synthesize the speech from the provided text 
synthesizer.speakTextAsync(
  text,
  result => {
    // Log the synthesis result 
    console.log(JSON.stringify(result)) 

    // Clean up the synthesizer 
    synthesizer.close() 
  }, 
  error => { 
    // Handle any errors during synthesis 
    console.error(error) 
    synthesizer.close()
  } 
)
```

## Clean Up System Downloads 

```typescript
// Name: Downloads Cleanup
// Description: Cleans up the Downloads directory based on file age
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt for the maximum age of files to keep (in days)
const maxAgeDays = parseInt(await arg("Enter maximum age of files to keep (days):")) 

// Get the current timestamp
const now = Date.now() 

// Get all files in the Downloads directory 
const files = await globby([`${home("Downloads")}/*`]) 

// Create a list of files to delete based on their modification time 
const filesToDelete: string[] = []
for (const file of files) { 
  const { mtimeMs } = await stat(file)

  // Calculate the age of the file in days
  const fileAgeDays = (now - mtimeMs) / (1000 * 60 * 60 * 24)

  // If the file is older than the maximum age, add it to the list of files to delete
  if (fileAgeDays > maxAgeDays) {
    filesToDelete.push(file) 
  }
}

if (filesToDelete.length > 0) {
  // Prompt for confirmation before deleting files
  let shouldDelete = await arg(
    {
      placeholder: `Found ${filesToDelete.length} files older than ${maxAgeDays} days. Delete them?`, 
      // Display the list of files to be deleted in the preview
      preview: md(filesToDelete.map(file => `- ${file}`).join("\n")), 
      height: PROMPT.HEIGHT.LG, 
    }, 
    ["Yes", "No"]
  )

  if (shouldDelete === "Yes") {
    // Delete the selected files 
    await trash(filesToDelete) 

    // Display a notification
    await notify("Old files deleted from Downloads!")
  } 
} else {
  // Display a message if no files are older than the specified age
  await div(md(`## No files older than ${maxAgeDays} days found in Downloads.`))
}
```

## Remove Unnecessary Files from a Directory

```typescript
// Name: Unnecessary File Cleanup
// Description: Removes unnecessary files (e.g., .DS_Store, thumbs.db) from a directory 
// Author: johnlindquist

import "@johnlindquist/kit"

// Define patterns for unnecessary files (adjust as needed)
const unnecessaryFilePatterns = [
  ".DS_Store", 
  "thumbs.db", 
  "desktop.ini", 
]

// Prompt the user to select a directory
const directoryPath = await path({ 
  onlyDirs: true,
})

// Find unnecessary files using globby
const filesToRemove = await globby(
  unnecessaryFilePatterns.map(pattern => `${directoryPath}/${pattern}`),
  {
    // Use dot option to include dotfiles 
    dot: true,
  }
) 

// If unnecessary files are found, prompt for confirmation to remove them 
if (filesToRemove.length > 0) {
  let shouldRemove = await arg(
    {
      placeholder: `Found ${filesToRemove.length} unnecessary files. Remove them?`,
      // Display the list of files in the preview
      preview: md(filesToRemove.map(file => `- ${file}`).join("\n")), 
      height: PROMPT.HEIGHT.LG, 
    },
    ["Yes", "No"]
  ) 

  if (shouldRemove === "Yes") { 
    // Remove the files 
    await trash(filesToRemove) 
    await notify("Unnecessary files removed!")
  } 
} else { 
  // Display a message if no unnecessary files are found
  await div(md(`## No unnecessary files found.`)) 
}
```

##  Generate a Project Roadmap

```typescript
// Name: Project Roadmap Generator
// Description: Generates a project roadmap using the Git history and Mermaid.js 
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user to select a project directory
const projectPath = await path({
  onlyDirs: true,
})

// Get the Git log, formatted for a Mermaid.js timeline diagram 
const { stdout: gitLog } = await exec(`git log --pretty=format:"%ad | %s" --date=short --no-merges`, {
  shell: true,
  cwd: projectPath,
}) 

// Create the Mermaid.js code for the timeline diagram 
const mermaidCode = `
\`\`\`mermaid
timeline 
  dateFormat YYYY-MM-DD
  title Project Roadmap 
${gitLog.split("\n").map(line => `  ${line.replace("|", ":")}`).join("\n")} 
\`\`\`
`

// Display the Mermaid.js code in the editor 
await editor(mermaidCode, {
  language: "markdown",
}) 
```

## Create and Share a Google Calendar Event with Video Conference

```typescript
// Name: Google Calendar Event with Meet
// Description: Creates a Google Calendar event with a Google Meet video conference 
// Author: johnlindquist

import "@johnlindquist/kit" 
import { google } from "googleapis"
import { JWT } from "google-auth-library" 

// Get credentials for Google Service Account through environment variables 
// You can create service account credentials here: https://console.cloud.google.com/apis/credentials
let SA_EMAIL = await env("GOOGLE_SA_EMAIL")
let SA_KEY = await env("GOOGLE_SA_CREDS") 

// Define the scopes and client 
let jwtClient = new JWT({
  email: SA_EMAIL,
  key: SA_KEY, 
  scopes: ["https://www.googleapis.com/auth/calendar"], 
}) 

let calendar = google.calendar("v3")

// Function to create a calendar event with a Google Meet conference
async function createEvent(auth, event) { 
  // Create the event using the Google Calendar API
  const response = await calendar.events.insert(
    {
      auth,
      calendarId: "primary",
      resource: event,
      conferenceDataVersion: 1, // Required for creating a Meet conference
    },
  ) 

  // Return the event's Hangouts Meet link 
  return response.data.hangoutLink
} 

// Prompt for event details 
let eventSummary = await arg("Enter event summary:")
let eventStartTime = await arg("Enter event start time (YYYY-MM-DDTHH:mm:ssZ):") 
let eventEndTime = await arg("Enter event end time (YYYY-MM-DDTHH:mm:ssZ):")

// Create the event object, including a conferenceData object to request a Meet link 
let event = { 
  summary: eventSummary,
  start: { dateTime: eventStartTime, timeZone: "UTC" },
  end: { dateTime: eventEndTime, timeZone: "UTC" },
  conferenceData: {
    createRequest: {
      requestId: Math.random().toString(), 
      conferenceSolutionKey: { type: "hangoutsMeet" }, 
    }, 
  },
} 

// Create the event and get the Meet link
const meetLink = await createEvent(jwtClient, event)

// Display the Meet link in a div
await div(md(`## Join Google Meet:\n\n${meetLink}`)) 

// Copy the Meet link to the clipboard
await copy(meetLink) 
```



## Convert Speech to Text and Create a Meeting Summary

```typescript
// Name: Meeting Summarizer 
// Description: Transcribes and summarizes meeting recordings using OpenAI's Whisper API 
// Author: johnlindquist 

import "@johnlindquist/kit"
import OpenAI from "openai"

// Get your OpenAI API key from here: https://beta.openai.com/account/api-keys
const OPENAI_API_KEY = await env("OPENAI_API_KEY")

// Create a new OpenAI instance
const openai = new OpenAI({
  apiKey: OPENAI_API_KEY, 
}) 

// Prompt the user to select an audio file 
const audioFilePath = await path({
  filters: [{ name: "Audio", extensions: ["mp3", "wav", "m4a", "ogg"] }], 
})

// Transcribe the audio using the Whisper API 
const transcriptionResponse = await openai.audio.transcriptions.create({
  file: createReadStream(audioFilePath), // Use createReadStream to stream the audio file
  model: "whisper-1", 
})

// Extract the transcribed text 
const transcribedText = transcriptionResponse.text

// Summarize the meeting transcript using the OpenAI API
const summaryResponse = await openai.chat.completions.create({
  model: "gpt-3.5-turbo", 
  messages: [
    {
      role: "user",
      content: `Please provide a concise summary of the following meeting transcript: \n\n${transcribedText}`,
    }, 
  ],
})

// Extract the summary from the response 
const summary = summaryResponse.choices[0].message.content

// Prompt for the output file path
const outputFilePath = await path({ 
  startPath: home("Documents"),
  suggestion: `meeting-summary-${formatDate(new Date(), "yyyy-MM-dd_HH-mm")}.md`, // Suggest a file name with the date and time
})

// Write the summary to a file 
await writeFile(outputFilePath, `# Meeting Summary\n\n${summary}`) 

// Open the summary file in the editor
await edit(outputFilePath)
```

## Analyze Website SEO

```typescript
// Name: SEO Analyzer
// Description: Analyzes the SEO of a website using the SEO Analyzer API
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the website URL 
const url = await arg("Enter website URL:")

// Fetch SEO analysis data from the SEO Analyzer API (replace with the actual API endpoint)
const response = await get(`https://api.seoanalyzer.pro/v2/analyze?key=${await env("SEO_ANALYZER_API_KEY")}&url=${url}`)
// Get your API key here: https://seoanalyzer.pro/

// Extract relevant SEO data 
const { data: { onpage, offpage } } = response

// Create a list of issues to display 
const issues = [ 
  ...onpage.issues.map(issue => ({ type: "On-Page", ...issue })), 
  ...offpage.issues.map(issue => ({ type: "Off-Page", ...issue })),
]

// Display the SEO analysis in a div, grouping issues by type
let html = `
  <h1>SEO Analysis for ${url}:</h1>
  <h2>On-Page Issues:</h2>
  <ul>
    ${issues
      .filter(issue => issue.type === "On-Page")
      .map(issue => `<li>${issue.title} - Priority: ${issue.priority}</li>`)
      .join("")}
  </ul>

  <h2>Off-Page Issues:</h2>
  <ul>
    ${issues
      .filter(issue => issue.type === "Off-Page") 
      .map(issue => `<li>${issue.title} - Priority: ${issue.priority}</li>`) 
      .join("")} 
  </ul>
` 
await div(html)
```

##  Generate a Random User Profile

```typescript
// Name: Generate User Profile 
// Description: Generates a random user profile using the RandomUser API 
// Author: johnlindquist 

import "@johnlindquist/kit"

// Fetch a random user profile from the RandomUser API 
const response = await get("https://randomuser.me/api/")

// Extract the user data from the response
const { results: [user] } = response.data 

// Display the user profile information in a div
await div(
  md(`
## Random User Profile: 

* Name: ${user.name.first} ${user.name.last} 
* Email: ${user.email}
* Location: ${user.location.city}, ${user.location.state}, ${user.location.country} 
* Phone: ${user.phone}
* Picture: ![Profile Picture](${user.picture.large})
  `)
)
```

## Find and Remove Duplicate Files with Hash Comparison

```typescript
// Name: Duplicate File Remover (Hash)
// Description: Finds and removes duplicate files in a directory using SHA-256 hash comparison
// Author: johnlindquist

import "@johnlindquist/kit"
import { createHash } from "crypto"

// Prompt the user to select a directory
const directoryPath = await path({
  onlyDirs: true,
})

// Function to calculate the SHA-256 hash of a file
async function calculateFileHash(filePath: string): Promise<string> {
  const fileBuffer = await readFile(filePath) 
  const hashSum = createHash("sha256")
  hashSum.update(fileBuffer) 
  return hashSum.digest("hex") 
}

// Get all files in the directory
const filePaths = await globby([`${directoryPath}/**/*`], { onlyFiles: true }) 

// Create a map to store file hashes and their corresponding file paths
const fileHashMap = new Map<string, string[]>() 

// Calculate hashes for each file and store them in the map
for (const filePath of filePaths) {
  const fileHash = await calculateFileHash(filePath)
  if (fileHashMap.has(fileHash)) {
    fileHashMap.get(fileHash).push(filePath)
  } else {
    fileHashMap.set(fileHash, [filePath])
  } 
} 

// Find entries with more than one file path (indicating duplicates)
const duplicateFiles = Array.from(fileHashMap.entries()).filter(([, paths]) => paths.length > 1)

if (duplicateFiles.length > 0) { 
  // Display duplicate files and prompt for confirmation to remove them 
  let shouldRemove = await arg(
    {
      placeholder: `Found ${duplicateFiles.length} duplicate files. Remove them?`,
      // Use a custom height for the prompt 
      height: PROMPT.HEIGHT.LG, 
    },
    ["Yes", "No"]
  ) 

  if (shouldRemove === "Yes") {
    // Remove duplicate files 
    for (const [, paths] of duplicateFiles) { 
      // Keep the first file and remove the rest 
      for (let i = 1; i < paths.length; i++) {
        await trash(paths[i])
      }
    }
    // Display a notification
    await notify("Duplicate files removed!") 
  } 
} else { 
  // Display a message if no duplicates are found
  await div(md(`## No duplicate files found.`))
}
```

## Generate Code Snippet with Tabstops and Placeholders

```typescript
// Name: Generate Code Snippet with Placeholders 
// Description: Generates a code snippet with tabstops and placeholders using the editor
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user to select a programming language
const language = await arg("Select language:", [ 
  "JavaScript",
  "TypeScript",
  "Python",
  "HTML", 
  "CSS", 
])

// Create an editor with a predefined code snippet template, including tabstops and placeholders 
await editor({
  language: language.toLowerCase(), 
  value: `
// Function to ${1:perform an action}
function ${2:functionName}(${3:parameters}) {
  ${0:// Your code here} 
}
`,
})
```

##  Get Trending Repositories on GitLab

```typescript
// Name: GitLab Trending Repositories
// Description: Displays a list of trending repositories on GitLab
// Author: johnlindquist

import "@johnlindquist/kit"

// Fetch trending projects from the GitLab API 
// You don't need an API key for this
const response = await get(`https://gitlab.com/api/v4/projects?trending=true&order_by=stars_count&sort=desc`) 

// Extract repository data from the response
const repositories = response.data.map((repo) => ({
  name: repo.name_with_namespace,
  description: repo.description,
  url: repo.web_url,
  stars: repo.star_count, 
}))

// Prompt the user to select a repository 
const selectedRepo = await arg( 
  {
    placeholder: "Select a repository:", 
    enter: "Open in Browser",
  }, 
  // Display repository information as choices
  repositories.map(repo => ({
    name: repo.name, 
    value: repo.url, 
    description: `${repo.description} (${repo.stars} stars)`,
  }))
)

// Open the selected repository in the browser
await browse(selectedRepo)
```

## Get Current Location Information

```typescript
// Name: Get Location Details 
// Description: Retrieves and displays detailed information about the user's current location 
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the user's current location using the browser's geolocation API 
const { coords } = await new Promise<GeolocationPosition>((resolve, reject) => { 
  navigator.geolocation.getCurrentPosition(resolve, reject)
}) 

// Fetch location details from the OpenCage Geocoding API
const response = await get(
  `https://api.opencagedata.com/geocode/v1/json?q=${coords.latitude}+${coords.longitude}&key=${await env(
    "OPENCAGE_API_KEY"
  )}` 
)
// Get your OpenCage API key here: https://opencagedata.com/

// Extract the location components from the response 
const {
  results: [
    {
      components: {
        city,
        state, 
        country,
        postcode,
        road, 
        house_number,
      }, 
      formatted,
    },
  ],
} = response.data

// Display the location information in a div
await div(
  md(`## Your Location:

* Address: ${house_number} ${road}, ${city}, ${state}, ${postcode}, ${country}
* Coordinates: ${coords.latitude}, ${coords.longitude} 
* Formatted Address: ${formatted}
  `)
) 
```



## Send Bulk Personalized Emails 

```typescript
// Name: Personalized Bulk Email Sender
// Description: Sends personalized bulk emails from a CSV file using Nodemailer and Handlebars
// Author: johnlindquist

import "@johnlindquist/kit"
import nodemailer from "nodemailer"
import { parse } from "papaparse"

// Get email credentials from environment variables
// You can create an app password here: https://support.google.com/accounts/answer/185833?hl=en
const emailUser = await env("EMAIL_USER")
const emailPassword = await env("EMAIL_PASSWORD")

// Create a Nodemailer transporter 
const transporter = nodemailer.createTransport({
  service: "gmail", 
  auth: {
    user: emailUser,
    pass: emailPassword,
  }, 
}) 

// Prompt the user to select a CSV file containing email data 
const csvFilePath = await path({
  filters: [{ name: "CSV Files", extensions: ["csv"] }],
}) 

// Read the CSV file content 
const csvData = await readFile(csvFilePath, "utf-8")

// Parse the CSV data using papaparse
const { data: csvJson } = parse(csvData, { header: true })

// Prompt the user to select an HTML email template 
const templateFile = await path({
  filters: [{ name: "HTML Templates", extensions: ["html"] }],
})

// Read the template content
const templateContent = await readFile(templateFile, "utf-8") 

// Compile the template using Handlebars 
const template = compile(templateContent)

// Send personalized emails to each recipient from the CSV data 
for (const row of csvJson) {
  // Prompt for the email subject, allowing for personalization using Handlebars syntax
  const subject = await arg("Enter email subject:", `Personalized Subject for {{name}}`) 

  // Render the HTML email content using the template and data from the current CSV row
  const htmlContent = template(row) 

  // Define email options
  const mailOptions = {
    from: emailUser,
    to: row.email, // Use the recipient's email from the CSV
    subject: compile(subject)(row), // Compile the subject template with the row data for personalization
    html: htmlContent, 
  } 

  // Send the email
  await transporter.sendMail(mailOptions)

  // Display a notification 
  await notify(`Email sent to ${row.email}`) 
}

// Display a confirmation message
await div(md(`## Bulk emails sent successfully!`)) 
```

## Create a Screen Recording with Webcam Overlay

```typescript
// Name: Screen Recorder with Webcam
// Description: Records a screen recording with a webcam overlay
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the screen to record
const screens = await getScreens() 
const screenId = parseInt(await arg("Select screen to record:", screens.map(s => s.id.toString())))

// Prompt for the webcam to use 
const webcams = await getMediaDevices()
const webcamId = (
  await arg(
    "Select webcam:",
    webcams
      .filter(device => device.kind === "videoinput") 
      .map(device => ({
        name: device.label, 
        value: device.deviceId, 
      }))
  )
).deviceId 

// Prompt for the webcam position
const webcamPosition = await arg("Select webcam position:", ["top-left", "top-right", "bottom-left", "bottom-right"])

// Start the screen recording with webcam overlay, using the selected screen, webcam, and position
let filePath = await screenRecording.start({
  screenId,
  webcamId,
  webcamPosition, 
})

// Prompt the user to stop recording
await div(
  md(`
## Recording... 

Press <kbd>Escape</kbd> to stop recording.
`), 
  "flex flex-col items-center gap-2 justify-center text-center"
) 

// Stop the screen recording when the user presses the escape key
onKeydown(async (event) => { 
  if (event.key === "Escape") {
    // Stop recording
    await screenRecording.stop()
  } 
}) 

// Reveal the recorded video in Finder 
await revealFile(filePath)
```

## Convert JSON to CSV

```typescript
// Name: JSON to CSV Converter
// Description: Converts JSON data to CSV format
// Author: johnlindquist

import "@johnlindquist/kit"
import { stringify } from "csv-stringify/sync"

// Prompt the user to select a JSON file
const filePath = await path({
  filters: [{ name: "JSON Files", extensions: ["json"] }],
})

// Read the JSON data from the file
const jsonData = await readJson(filePath)

// Prompt for the output file path
const outputFilePath = await path({
  startPath: home("Downloads"),
  suggestion: `${path.basename(filePath, ".json")}.csv`,
})

// Convert JSON to CSV using csv-stringify/sync
const csvData = stringify(jsonData, { header: true }) 

// Write the CSV data to the output file
await writeFile(outputFilePath, csvData) 

// Display a notification
await notify("JSON converted to CSV!", `Saved to ${outputFilePath}`)

// Reveal the CSV file in Finder
await revealFile(outputFilePath)
```

## Check Website for Broken Images 

```typescript 
// Name: Broken Image Checker
// Description: Checks for broken images on a website using Puppeteer
// Author: johnlindquist

import "@johnlindquist/kit" 
import puppeteer from "puppeteer"

// Prompt for the website URL 
const url = await arg("Enter website URL:") 

// Launch a headless browser instance using Puppeteer 
const browser = await puppeteer.launch({ headless: "new" }) 

try {
  // Create a new page 
  const page = await browser.newPage() 

  // Navigate to the website 
  await page.goto(url, { waitUntil: "networkidle0" })

  // Get all image elements on the page
  const imageElements = await page.$$("img") 

  // Check for broken images 
  const brokenImages = []
  for (const imageElement of imageElements) { 
    // Check if the image loaded successfully 
    const isBroken = await page.evaluate((img) => { 
      return !img.complete || img.naturalWidth === 0
    }, imageElement) 

    if (isBroken) {
      // Get the image source URL
      const imageUrl = await page.evaluate(el => el.src, imageElement)
      // Add the broken image URL to the list 
      brokenImages.push(imageUrl)
    }
  }

  if (brokenImages.length > 0) {
    // Display the list of broken images in a div
    await div(md(`## Broken Images: 

    ${brokenImages.map(image => `- ${image}`).join("\n")} 
    `))
  } else {
    // Display a message if no broken images are found
    await div(md(`## No broken images found! ðŸŽ‰`)) 
  }
} finally {
  // Close the browser instance
  await browser.close()
}
```

## Create a Project from a GitHub Template Repository

```typescript
// Name: Create Project from Template
// Description: Creates a new project from a GitHub template repository
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt for the GitHub template repository URL
const templateRepoUrl = await arg("Enter GitHub template repository URL:")

// Prompt for the new project name
const projectName = await arg("Enter new project name:")

// Clone the template repository using degit 
await degit(templateRepoUrl).clone(projectName) 

// Display a confirmation message
await div(md(`## Project created from template: ${templateRepoUrl}`))

// Open the project directory in VS Code
await exec(`code ${projectName}`)
```

##  Get Recent Files

```typescript
// Name: Recent Files
// Description: Displays a list of recently modified files in a directory
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user to select a directory
const directoryPath = await path({ 
  onlyDirs: true, 
})

// Get all files in the directory
const files = await globby([`${directoryPath}/**/*`]) 

// Get the modification times for each file 
const fileModificationTimes = await Promise.all(
  files.map(async (file) => {
    const { mtimeMs } = await stat(file)
    return { path: file, mtimeMs }
  }) 
)

// Sort files by modification time in descending order (most recent first)
fileModificationTimes.sort((a, b) => b.mtimeMs - a.mtimeMs)

// Create choices for each file, including modification time in the description 
const fileChoices = fileModificationTimes.map(file => ({
  name: path.basename(file.path),
  value: file.path, 
  description: `Last modified: ${new Date(file.mtimeMs).toLocaleString()}`,
}))

// Prompt the user to select a file to open
const selectedFile = await arg(
  { 
    placeholder: "Select a recent file:", 
    enter: "Open",
  }, 
  fileChoices
)

// Open the selected file in the default application 
await open(selectedFile)
```

## Generate a Project Timeline Visualization

```typescript
// Name: Generate Project Timeline
// Description: Generates a timeline visualization of a project's Git history using Mermaid.js
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt the user to select a project directory
const projectPath = await path({
  onlyDirs: true,
})

// Prompt for the Git log date format 
const dateFormat = await arg(
  "Select date format for timeline:",
  [
    "YYYY-MM-DD", // Default date format
    "DD/MM/YYYY", 
    "MM/DD/YYYY",
  ]
)

// Get the Git log, formatted for a Mermaid.js timeline diagram using the selected date format
const { stdout: gitLog } = await exec(`git log --pretty=format:"%ad | %s" --date=${dateFormat} --no-merges`, {
  shell: true, 
  cwd: projectPath, 
})

// Create the Mermaid.js code for the timeline diagram
const mermaidCode = `
\`\`\`mermaid
timeline
  dateFormat ${dateFormat}
  title Project Timeline
${gitLog.split("\n").map(line => `  ${line.replace("|", ":")}`).join("\n")} 
\`\`\`
`

// Display the Mermaid.js code in the editor 
await editor(mermaidCode, {
  language: "markdown", 
})
```


## Convert Text to Handwriting and Save to Image

```typescript
// Name: Text to Handwriting Image
// Description: Converts text to a handwritten image using the Handwriting.io API
// Author: johnlindquist 

import "@johnlindquist/kit"

// Get your API key from here: https://www.handwriting.io/pricing
const HANDWRITING_API_KEY = await env("HANDWRITING_API_KEY") 

// Prompt for the text to convert 
const text = await arg("Enter text to convert:") 

// Prompt for the handwriting style
const handwritingStyle = await arg("Select handwriting style:", [
  "BALLPOINT",
  "CURSIVE",
  "MARKER",
])

// Prompt for the output file path 
const outputFilePath = await path({
  startPath: home("Downloads"), 
  // Suggest a filename based on the input text 
  suggestion: `${text.replace(/\s/g, "_").slice(0, 20)}.png`,
}) 

// Send a request to the Handwriting.io API
const response = await post(
  "https://api.handwriting.io/render", 
  {
    text,
    handwriting_id: handwritingStyle, 
    handwriting_size: "auto", 
    width: "auto", 
    height: "auto",
    color: "000000",
  }, 
  { headers: { "api-key": HANDWRITING_API_KEY } } 
)

// Extract the image URL from the response 
const { image_url } = response.data 

// Download the image from the URL
const imageBuffer = await download(imageUrl)

// Save the downloaded image to the specified file path 
await writeFile(outputFilePath, imageBuffer) 

// Display a notification 
await notify("Handwritten image generated!", `Saved to ${outputFilePath}`)

// Reveal the image file in Finder
await revealFile(outputFilePath)
```

## Create and Share a GitHub Repository

```typescript
// Name: Create and Share GitHub Repository
// Description: Creates a new GitHub repository and shares the link
// Author: johnlindquist

import "@johnlindquist/kit" 
import { Octokit } from "@octokit/rest" 

// Get GitHub authentication token from environment variables 
// You can get a token from here: https://github.com/settings/tokens
const githubToken = await env("GITHUB_TOKEN")

// Create a new Octokit instance
const octokit = new Octokit({ 
  auth: githubToken, 
}) 

// Prompt for the repository name
const repoName = await arg("Enter repository name:") 

// Prompt for the repository description 
const repoDescription = await arg("Enter repository description:")

// Create the repository on GitHub
const { data: newRepo } = await octokit.repos.createForAuthenticatedUser({ 
  name: repoName,
  description: repoDescription,
  // Prompt for the repository's visibility 
  private: (await arg("Make repository private?", ["Yes", "No"])) === "Yes",
}) 

// Copy the repository URL to the clipboard 
await copy(newRepo.html_url) 

// Display a notification
await notify("GitHub repository created!", `URL copied to clipboard: ${newRepo.html_url}`)
```

##  Convert Text from Clipboard to Speech and Save

```typescript
// Name: Clipboard to Speech
// Description: Converts text from the clipboard to speech and saves it to an audio file 
// Author: johnlindquist 

import "@johnlindquist/kit"
import OpenAI from "openai"

// Get your OpenAI API key from here: https://platform.openai.com/account/api-keys 
const OPENAI_API_KEY = await env("OPENAI_API_KEY")

// Create a new OpenAI instance 
const openai = new OpenAI({
  apiKey: OPENAI_API_KEY,
})

// Get the clipboard text
const text = await paste() 

// Prompt for the output file path
const outputFilePath = await path({ 
  startPath: home("Downloads"), 
  // Suggest a filename based on the clipboard text 
  suggestion: `${text.replace(/\s/g, "_").slice(0, 20)}.mp3`, 
}) 

// Generate speech audio using the OpenAI API 
const response = await openai.audio.speech.create({
  model: "tts-1", 
  voice: "alloy", 
  input: text, 
}) 

// Create a write stream for the output file
const writeStream = createWriteStream(outputFilePath) 

// Pipe the audio data to the file
response.data.pipe(writeStream)

// Wait for the file to be written
await new Promise((resolve) => writeStream.on("finish", resolve))

// Display a notification
await notify("Audio file created!", `Saved to ${outputFilePath}`)

// Reveal the saved audio file in Finder
await revealFile(outputFilePath)
```

## Create and Push a New Git Branch with Initial Commit

```typescript
// Name: Create and Push Git Branch
// Description: Creates a new Git branch, switches to it, makes an initial commit, and pushes it to the remote repository
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the new branch name
const branchName = await arg("Enter new branch name:") 

// Create and switch to the new branch 
await $`git checkout -b ${branchName}`

// Prompt for the initial commit message
const commitMessage = await arg("Enter initial commit message:") 

// Stage all changes and create the commit
await $`git add . && git commit -m "${commitMessage}"`

// Prompt for confirmation to push the new branch to the remote repository
const shouldPush = await arg(`Push new branch "${branchName}" to remote?`, ["Yes", "No"])

// Push the branch if confirmed
if (shouldPush === "Yes") {
  await $`git push origin ${branchName}`
  await div(md(`## Branch "${branchName}" created and pushed to remote!`)) 
} else {
  await div(md(`## Branch "${branchName}" created locally!`)) 
} 
```

## Find and Open a File by Content

```typescript
// Name: Find File by Content
// Description: Searches for a file containing specific text and opens it in the editor
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user to enter the text to search for
const searchText = await arg("Enter text to search for in files:") 

// Search for files containing the specified text using ripgrep
let { stdout: matchingFiles } = await exec(`rg '${searchText}' -l`, {
  shell: true, 
}) 

// Split the output into an array of file paths
const filePaths = matchingFiles.split("\n").filter(file => file.length > 0)

// If multiple files are found, prompt the user to select one
if (filePaths.length > 1) {
  // Select a file from the list of matching files
  const selectedFilePath = await arg("Select a file to open:", filePaths)
  // Open the selected file in the editor 
  await edit(selectedFilePath) 
} else if (filePaths.length === 1) { 
  // If only one file is found, open it directly in the editor
  await edit(filePaths[0])
} else {
  // Display a message if no files are found
  await div(md(`## No files found containing "${searchText}"`)) 
}
```

##  Create and Share a Public GitHub Gist

```typescript
// Name: Share Text as Gist
// Description: Creates a public GitHub Gist from selected text
// Author: johnlindquist

import "@johnlindquist/kit" 

// Get the selected text 
const selectedText = await getSelectedText()

// Prompt for a description for the Gist 
const description = await arg("Enter Gist description:")

// Create a public Gist using the GitHub API
let { html_url: gistUrl } = await createGist(selectedText, { 
  description,
  fileName: "gist.txt", 
  isPublic: true, 
})

// Display the Gist URL in a div
await div(md(`## Gist created at: ${gistUrl}`)) 

// Copy the Gist URL to the clipboard
await copy(gistUrl)

// Open the Gist in the browser
await browse(gistUrl)
```

## Check if a Website Uses a Specific Technology

```typescript
// Name: Website Technology Checker 
// Description: Checks if a website uses a specific technology using Wappalyzer
// Author: johnlindquist

import "@johnlindquist/kit"
import wappalyzer from "wappalyzer"

// Prompt for the website URL
const url = await arg("Enter website URL:")

// Prompt for the technology to check for
const technology = await arg("Enter technology to check for (e.g., WordPress, React, Google Analytics):") 

// Create a new Wappalyzer instance 
const wappalyzerInstance = new wappalyzer({
  // Configure Wappalyzer to analyze the specified URL and return only the detected technologies
  url,
  apps: [],
  categories: [], 
  implies: [],
  headers: {},
  userAgent: "ScriptKit", 
  maxWait: 5000, 
  debug: false, 
}) 

// Analyze the website and get the detected technologies
const { technologies } = await wappalyzerInstance.analyze() 

// Check if the specified technology is present in the detected technologies
const isTechnologyUsed = technologies.some(tech => tech.name.toLowerCase() === technology.toLowerCase())

// Display the result 
if (isTechnologyUsed) { 
  await div(md(`## The website uses ${technology}.`)) 
} else {
  await div(md(`## The website does not use ${technology}.`))
}
```


## Get and Display System Information in a Widget

```typescript
// Name: System Information Widget
// Description: Displays system information in a widget
// Author: johnlindquist

import "@johnlindquist/kit"
import si from "systeminformation";

// Create a widget to display the system information
const systemInfoWidget = await widget(
  `
<div class="p-4">
  <h2 class="text-xl font-bold">System Information</h2>
  <div class="flex flex-col gap-2">
    <div>
      <span class="font-bold">OS:</span> {{osName}} {{osVersion}}
    </div>
    <div>
      <span class="font-bold">CPU:</span> {{cpuModel}} ({{cpuCores}} cores)
    </div>
    <div>
      <span class="font-bold">Memory:</span> {{memoryTotal}}
    </div>
  </div>
</div>
`,
  {
    width: 300, // Set a custom width for the widget
  }
);

// Get system information using systeminformation
const osInfo = await si.osInfo();
const cpuInfo = await si.cpu();
const memInfo = await si.mem();

// Update the widget state with system information
systemInfoWidget.setState({
  osName: osInfo.distro,
  osVersion: osInfo.release,
  cpuModel: cpuInfo.manufacturer + " " + cpuInfo.brand,
  cpuCores: cpuInfo.cores,
  memoryTotal: filesize(memInfo.total),
});

// Keep the script running to keep the widget active
hide();
```

## Convert Text to Speech and Upload to Dropbox

```typescript
// Name: Text to Speech & Upload to Dropbox
// Description: Converts text to speech and uploads it to Dropbox
// Author: johnlindquist

import "@johnlindquist/kit"
import OpenAI from "openai"
import { Dropbox } from "dropbox"

// Get your OpenAI API key from here: https://platform.openai.com/account/api-keys
const OPENAI_API_KEY = await env("OPENAI_API_KEY")

// Create a new OpenAI instance
const openai = new OpenAI({
  apiKey: OPENAI_API_KEY, 
})

// Prompt the user to enter the text
const text = await arg("Enter text to convert to speech:")

// Get your Dropbox API token from here: https://www.dropbox.com/developers/apps
const DROPBOX_ACCESS_TOKEN = await env("DROPBOX_ACCESS_TOKEN")

// Create a new Dropbox client
const dbx = new Dropbox({ accessToken: DROPBOX_ACCESS_TOKEN })

// Generate speech audio using the OpenAI API
const response = await openai.audio.speech.create({
  model: "tts-1",
  voice: "alloy", 
  input: text, 
}) 

// Save the audio data to a temporary file
const tempFilePath = tmpPath("speech.mp3") 
await writeFile(tempFilePath, Buffer.from(await response.arrayBuffer()))

// Prompt for the destination path in Dropbox 
const destinationPath = await arg("Enter destination path in Dropbox:")

// Upload the temporary audio file to Dropbox
await dbx.filesUpload({ path: destinationPath, contents: await readFile(tempFilePath) })

// Remove the temporary audio file
await trash(tempFilePath)

// Display a notification 
await notify("Audio file uploaded to Dropbox!", `Path: ${destinationPath}`)
```

##  Create a Shortcut to Open a Specific Website

```typescript
// Name: Create Website Shortcut 
// Description: Creates a shortcut to open a specific website
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the website URL
const url = await arg("Enter website URL:")

// Prompt for the shortcut key combination 
const shortcut = await hotkey({
  placeholder: "Press the desired shortcut key combination:",
})

// Register the shortcut to open the website
registerShortcut(shortcut.shortcut, async () => {
  await browse(url)
}) 

// Display a notification 
await notify("Shortcut created!", `Press ${shortcut.shortcut} to open ${url}`) 
```

## Extract Text from a PDF and Translate It

```typescript
// Name: Translate PDF
// Description: Extracts text from a PDF and translates it to a selected language
// Author: johnlindquist

import "@johnlindquist/kit" 
import { parse } from "pdf-parse"
import translate from "@vitalets/google-translate-api"

// Prompt for the PDF file path
const filePath = await path({
  filters: [{ name: "PDF Files", extensions: ["pdf"] }],
})

// Extract text from the PDF using pdf-parse
const pdfData = await readFile(filePath)
const { textContent } = await parse(pdfData)

// Prompt for the target language 
const targetLanguage = await arg("Enter target language code (e.g., 'es' for Spanish):")

// Translate the extracted text using google-translate-api 
const { text: translatedText } = await translate(textContent, { to: targetLanguage })

// Display the translated text in the editor
await editor(translatedText, {
  language: "text",
})
```

##  Create a GIF from Screen Recording

```typescript
// Name: GIF from Screen Recording
// Description: Creates a GIF from a screen recording using ffmpeg 
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the video file path
const videoFilePath = await path({
  filters: [{ name: "Videos", extensions: ["mp4", "mov", "avi"] }],
})

// Prompt for the start time (in seconds) 
const startTime = parseFloat(await arg("Enter start time (seconds):")) 

// Prompt for the duration (in seconds)
const duration = parseFloat(await arg("Enter duration (seconds):")) 

// Prompt for the output file path
const outputFilePath = await path({
  startPath: home("Downloads"),
  // Suggest a GIF filename based on the original video name 
  suggestion: `${path.parse(videoFilePath).name}.gif`,
})

// Create the GIF using ffmpeg, specifying the start time, duration, and other options
await exec(
  `ffmpeg -y -ss ${startTime} -t ${duration} -i "${videoFilePath}" -vf "fps=10,scale=480:-1:flags=lanczos,split[s0][s1];[s0]palettegen[p];[s1][p]paletteuse" -loop 0 "${outputFilePath}"`, 
  { shell: true }
)

// Display a notification 
await notify("GIF created!", `Saved to ${outputFilePath}`)

// Reveal the generated GIF in Finder
await revealFile(outputFilePath)
```

## Create a Custom Keyboard Shortcut for a Script

```typescript
// Name: Create Script Shortcut 
// Description: Creates a keyboard shortcut for a selected script 
// Author: johnlindquist 

import "@johnlindquist/kit" 

// Prompt the user to select a script
const script = await selectScript() 

// Prompt for the desired shortcut key combination
const shortcut = await hotkey({ 
  placeholder: "Press the desired shortcut key combination:",
}) 

// Register the shortcut to run the selected script
registerShortcut(shortcut.shortcut, async () => {
  await run(script.filePath) 
})

// Display a notification
await notify("Shortcut created!", `Press ${shortcut.shortcut} to run "${script.name}"`)
```

## Generate Project Documentation with a Custom Theme

```typescript
// Name: Documenter with Custom Theme
// Description: Generates documentation for a TypeScript project with a custom TypeDoc theme 
// Author: johnlindquist 

import "@johnlindquist/kit"

// Prompt for the output directory for the documentation
const outputDir = await arg("Enter output directory for documentation:") 

// Prompt for the path to the custom TypeDoc theme directory
const themePath = await path({
  // Only allow selecting directories
  onlyDirs: true, 
  // Start in the current directory
  startPath: ".", 
  // Provide a hint for selecting the theme directory 
  hint: "Select the directory containing your custom TypeDoc theme.",
}) 

// Generate documentation using TypeDoc with the custom theme 
await exec(`npx typedoc --out ${outputDir} --theme ${themePath} src`, {
  shell: true, 
}) 

// Display a notification 
await notify("Documentation generated!", `Saved to ${outputDir}`) 
```

## Get and Display System Information

```typescript
// Name: System Information Viewer 
// Description: Displays system information using the 'systeminformation' library
// Author: johnlindquist

import "@johnlindquist/kit"
import si from "systeminformation"

// Create a widget to display system information 
const systemInfoWidget = await widget(
  `
<div class="p-4"> 
  <h2 class="text-xl font-bold">System Information</h2> 
  <div class="flex flex-col gap-2"> 
    <div>
      <span class="font-bold">Model:</span> {{systemModel}}
    </div>
    <div>
      <span class="font-bold">CPU:</span> {{cpuModel}}
    </div>
    <div>
      <span class="font-bold">Memory:</span> {{memoryTotal}} 
    </div>
    <div>
      <span class="font-bold">Uptime:</span> {{uptime}} 
    </div>
  </div>
</div>
`, 
  {
    // Set the width of the widget 
    width: 300, 
  } 
)

// Get system information using systeminformation
const systemData = await si.system() 
const cpuData = await si.cpu()
const memData = await si.mem() 
const timeData = await si.time()

// Update the widget state with the retrieved system information 
systemInfoWidget.setState({
  systemModel: systemData.model, 
  cpuModel: cpuData.manufacturer + " " + cpuData.brand,
  memoryTotal: filesize(memData.total), 
  uptime: timeData.uptime, 
})
```




## Download YouTube Video Transcript

```typescript
// Name: Download YouTube Transcript
// Description: Downloads the transcript for a YouTube video using the youtube-transcript library
// Author: johnlindquist

import "@johnlindquist/kit"
import { fetchTranscript } from "youtube-transcript"

// Prompt the user for the YouTube video URL
const youtubeUrl = await arg("Enter YouTube video URL:")

// Fetch the transcript using the youtube-transcript library
const transcript = await fetchTranscript(youtubeUrl)

// Format the transcript for display in the editor
const formattedTranscript = transcript.map(entry => `${entry.text}`).join("\n")

// Display the transcript in the editor
await editor(formattedTranscript, {
  language: "text", 
})
```

## Create a New File with a Template

```typescript 
// Name: New File from Template
// Description: Creates a new file from a selected template
// Author: johnlindquist 

import "@johnlindquist/kit"

// Prompt the user to select a template file
const templateFilePath = await path({
  // Start in the user's "templates" directory within their kenv 
  startPath: kenvPath("templates"), 
})

// Read the template content 
const templateContent = await readFile(templateFilePath, "utf-8")

// Prompt the user to select the destination directory for the new file
const destinationPath = await path({
  onlyDirs: true, // Only allow selecting directories
})

// Prompt for the new file name 
const newFileName = await arg("Enter new file name:") 

// Create the new file path
const newFilePath = path.join(destinationPath, newFileName) 

// Write the template content to the new file 
await writeFile(newFilePath, templateContent)

// Open the new file in VS Code 
await exec(`code ${newFilePath}`)
```

## Convert Speech to Text and Summarize with Custom Prompt

```typescript
// Name: Custom Speech Summarizer
// Description: Transcribes and summarizes speech with a custom prompt using the OpenAI API 
// Author: johnlindquist

import "@johnlindquist/kit"
import OpenAI from "openai"

// Get your OpenAI API key here: https://beta.openai.com/account/api-keys
const OPENAI_API_KEY = await env("OPENAI_API_KEY")

// Create a new OpenAI instance
const openai = new OpenAI({
  apiKey: OPENAI_API_KEY,
})

// Prompt the user to start recording 
await div(md(`# Click "Start Recording" to begin speaking.`), "flex flex-col items-center justify-center text-center gap-2") 
const audioFilePath = await mic.start()

// Stop recording when the user presses the escape key
onKeydown(async (event) => {
  if (event.key === "Escape") {
    await mic.stop()
  }
})

// Read the recorded audio file
const audioBuffer = await readFile(audioFilePath)

// Convert speech to text using the OpenAI API
const transcriptionResponse = await openai.audio.transcriptions.create({
  file: await toFile(audioBuffer, "audio.webm"),
  model: "whisper-1", 
})

// Extract the transcribed text
const transcribedText = transcriptionResponse.text

// Prompt the user for a custom summary prompt
const summaryPrompt = await arg("Enter a prompt for summarizing the speech:")

// Summarize the transcribed text using the OpenAI API with the custom prompt 
const summaryResponse = await openai.chat.completions.create({
  model: "gpt-3.5-turbo",
  messages: [{ role: "user", content: `${summaryPrompt}\n\n${transcribedText}` }],
}) 

// Extract the summary from the response 
const summary = summaryResponse.choices[0].message.content

// Display the summary in the editor 
await editor(summary, {
  language: "text",
})
```

##  Convert a Directory to a Git Repository

```typescript
// Name: Initialize Git Repository 
// Description: Initializes a directory as a Git repository 
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user to select a directory 
const directoryPath = await path({ 
  onlyDirs: true, 
}) 

// Initialize the directory as a Git repository
await git.init(directoryPath) 

// Display a notification
await notify("Git repository initialized!", `Path: ${directoryPath}`)
```

##  Resize Image and Upload to Cloudinary

```typescript
// Name: Resize and Upload to Cloudinary 
// Description: Resizes an image and uploads it to Cloudinary
// Author: johnlindquist 

import "@johnlindquist/kit" 
import { v2 as cloudinary } from "cloudinary"
import sharp from "sharp" 

// Get your Cloudinary API credentials from here: https://cloudinary.com/console/ 
const CLOUDINARY_CLOUD_NAME = await env("CLOUDINARY_CLOUD_NAME")
const CLOUDINARY_API_KEY = await env("CLOUDINARY_API_KEY") 
const CLOUDINARY_API_SECRET = await env("CLOUDINARY_API_SECRET") 

// Configure Cloudinary 
cloudinary.config({
  cloud_name: CLOUDINARY_CLOUD_NAME,
  api_key: CLOUDINARY_API_KEY, 
  api_secret: CLOUDINARY_API_SECRET,
})

// Prompt the user to select an image file
const imagePath = await path({
  filters: [{ name: "Images", extensions: ["jpg", "jpeg", "png", "gif"] }], 
})

// Prompt for the desired width of the resized image
const width = parseInt(await arg("Enter desired width (px):"))

// Resize the image using sharp
const resizedImageBuffer = await sharp(imagePath).resize({ width }).toBuffer()

// Upload the resized image to Cloudinary 
const uploadResponse = await cloudinary.uploader.upload(resizedImageBuffer, { 
  // Use a folder in Cloudinary to organize uploaded images
  folder: "resized_images",
  // Overwrite existing files with the same name
  overwrite: true,
  // Use a public ID based on the original file name 
  public_id: path.parse(imagePath).name, 
}) 

// Extract the secure URL of the uploaded image 
const imageUrl = uploadResponse.secure_url

// Display the image URL in a div
await div(md(`## Image uploaded to Cloudinary:

[${imageUrl}](${imageUrl})
`)) 

// Copy the image URL to the clipboard
await copy(imageUrl) 
```

## Clean Up Unused Git Tags

```typescript
// Name: Git Tag Cleanup
// Description: Removes unused Git tags 
// Author: johnlindquist 

import "@johnlindquist/kit"

// Get a list of local Git tags 
const { stdout: localTags } = await exec(`git tag`, { shell: true }) 

// Split the tags into an array 
const tags = localTags.split("\n").filter(tag => tag.length > 0) 

// Prompt the user to select tags to delete 
const tagsToDelete = await select({
  placeholder: "Select tags to delete (use cmd/ctrl for multiple):",
  multiple: true, // Allow selecting multiple tags 
}, tags) 

// Delete the selected tags
for (const tag of tagsToDelete) { 
  await $`git tag -d ${tag}`
}

// Display a confirmation message
await div(md(`## Deleted tags: ${tagsToDelete.join(", ")}`)) 
```

## Extract Text from a PDF with Language Selection

```typescript
// Name: Multilingual PDF Text Extractor 
// Description: Extracts text from a PDF with language selection using Tesseract OCR 
// Author: johnlindquist 

import "@johnlindquist/kit"
import Tesseract from "tesseract.js"

// Prompt the user to select a PDF file
const pdfFilePath = await path({
  filters: [{ name: "PDF Files", extensions: ["pdf"] }],
})

// Convert the PDF to images using pdftoppm (assuming it's installed)
await exec(`pdftoppm -png "${pdfFilePath}" output`, { shell: true }) 

// Get a list of the generated image files 
const imageFiles = await globby(["output-*.png"]) 

// Prompt the user to select the language of the text in the PDF
const language = await arg("Enter the language of the PDF (e.g., eng, spa):") 

// Display a progress bar while performing OCR
let progress = 0
const progressBar = await div(md(`# Extracting text from images... 

${progress}% 
`))

// Extract text from each image using Tesseract OCR with the selected language 
let extractedText = ""
for (const imagePath of imageFiles) { 
  const { data: { text } } = await Tesseract.recognize(imagePath, language)
  extractedText += text + "\n" 
  // Update the progress bar 
  progress = Math.floor((imageFiles.indexOf(imagePath) / imageFiles.length) * 100) 
  progressBar.setState({
    html: md(`# Extracting text from images... 

    ${progress}%
    `), 
  })
} 

// Close the progress bar 
progressBar.close()

// Display the extracted text in the editor 
await editor(extractedText, {
  language: "text", 
})
```



## Create a Time-lapse Video with Custom Speed

```typescript
// Name: Time-lapse with Speed Control
// Description: Creates a time-lapse video from a sequence of images with adjustable speed
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the input directory containing the image sequence 
const inputDirectory = await path({
  onlyDirs: true, // Only allow selecting directories
})

// Prompt for the output file path
const outputFilePath = await path({
  startPath: home("Downloads"),
})

// Prompt for the desired frames per second (FPS) for the output video 
const fps = parseInt(await arg("Enter desired frames per second (FPS):"))

// Prompt for the desired playback speed (1.0 is normal speed, 2.0 is double speed, 0.5 is half speed, etc.) 
const speed = parseFloat(await arg("Enter playback speed (e.g., 2.0 for double speed):"))

// Calculate the input framerate based on the desired FPS and playback speed
const inputFramerate = fps * speed

// Generate the time-lapse video using ffmpeg, setting the input and output framerates
await exec(`ffmpeg -y -framerate ${inputFramerate} -pattern_type glob -i '${inputDirectory}/*.{jpg,jpeg,png}' -c:v libx264 -r ${fps} -pix_fmt yuv420p '${outputFilePath}'`, { shell: true })

// Display a notification
await notify("Time-lapse video created!", `Saved to ${outputFilePath}`)

// Reveal the time-lapse video in Finder
await revealFile(outputFilePath)
```

## Create a New Shortcut for an Existing Script

```typescript 
// Name: Change Script Shortcut 
// Description: Creates a new shortcut for an existing script
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user to select a script from the available scripts
const script = await selectScript() 

// Prompt for the new shortcut key combination
const shortcut = await hotkey({
  placeholder: "Press the desired shortcut key combination:", 
}) 

// Update the script file with the new shortcut metadata 
let scriptContent = await readFile(script.filePath, "utf-8") 
scriptContent = `// Shortcut: ${shortcut.shortcut}\n${scriptContent}` 
await writeFile(script.filePath, scriptContent)

// Display a notification
await notify("Shortcut updated!", `Script "${script.name}" will now run with ${shortcut.shortcut}`)

// Refresh the list of scripts in the app
await refreshScripts() 
```

## Convert a Video File to a Different Format

```typescript
// Name: Video Format Converter
// Description: Converts a video file to a different format using ffmpeg
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt for the input video file path
const inputFilePath = await path({
  filters: [{ name: "Videos", extensions: ["mp4", "mov", "avi", "mkv", "webm"] }], 
})

// Extract the directory and file name from the input path 
const { dir, name } = path.parse(inputFilePath)

// Prompt for the desired output format
const outputFormat = await arg("Enter desired output format (e.g., mp4, avi, webm):") 

// Construct the output file path
const outputFilePath = path.join(dir, `${name}.${outputFormat}`)

// Convert the video to the specified format using ffmpeg
await exec(`ffmpeg -i '${inputFilePath}' '${outputFilePath}'`, { shell: true })

// Display a notification 
await notify("Video converted!", `Saved to ${outputFilePath}`) 

// Reveal the converted video in Finder 
await revealFile(outputFilePath)
```

## Get and Display System Battery Information

```typescript
// Name: Battery Info
// Description: Shows detailed battery information
// Author: johnlindquist

import "@johnlindquist/kit"
import si from "systeminformation" 

// Get battery information using the systeminformation library
const battery = await si.battery()

// Display battery information in a div, formatting values where appropriate
await div(
  md(`
## Battery Information: 

* Manufacturer: ${battery.manufacturer}
* Model: ${battery.model}
* Cycle Count: ${battery.cycleCount} 
* Design Capacity: ${filesize(battery.designedCapacity)} 
* Current Capacity: ${filesize(battery.currentCapacity)} 
* Health: ${battery.health}
* Status: ${battery.isCharging ? "Charging" : "Discharging"}
* Percentage: ${battery.percent}% 
* Time Remaining: ${battery.timeRemaining ? formatDuration(battery.timeRemaining) : "N/A"}
  `) 
)
```

##  Extract Images from a PDF to a Specific Directory

```typescript
// Name: Extract PDF Images to Directory
// Description: Extracts images from a PDF file to a chosen directory
// Author: johnlindquist 

import "@johnlindquist/kit" 
import { PDFImage } from "pdf-image"

// Prompt the user to select a PDF file 
const pdfFilePath = await path({
  filters: [{ name: "PDF Files", extensions: ["pdf"] }], 
})

// Prompt for the output directory 
const outputDir = await path({
  onlyDirs: true, 
})

// Create a new PDFImage instance
const pdfImage = new PDFImage(pdfFilePath)

// Extract images from the PDF to the specified directory, using a custom filename prefix 
await pdfImage.extract({
  outputDirectory: outputDir, 
  convertExtension: "png", // Convert images to PNG format
  prefix: "extracted-", // Add a prefix to the output image file names
})

// Display a notification
await notify("Images extracted from PDF!", `Saved to ${outputDir}`)
```

##  Generate Code Snippet with GitHub Copilot and Share as a Gist

```typescript
// Name: Copilot Snippet to Gist
// Description: Generates a code snippet using GitHub Copilot and shares it as a Gist 
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the programming language
const language = await arg("Enter programming language:") 

// Prompt for a description of the desired code snippet
const description = await arg("Enter code snippet description:")

// Generate a code snippet using GitHub Copilot, triggering Copilot suggestions 
let codeSnippet = await editor({
  // Set the language mode for syntax highlighting
  language, 
  // Paste the description into the editor as a comment 
  value: `// ${description}`,
  // Move the cursor to the end of the description
  scrollTo: "bottom", 
  // Add a shortcut to accept the first Copilot suggestion 
  shortcuts: [
    {
      name: "Accept Suggestion",
      key: "tab", 
      onPress: async () => {
        // Trigger a tab key press to accept the suggestion
        await keyboard.type(Key.Tab)
      },
    }, 
  ],
})

// Prompt for confirmation to create a Gist
const createGistConfirmation = await arg("Create a Gist for this code snippet?", ["Yes", "No"])

if (createGistConfirmation === "Yes") {
  // Create a public Gist on GitHub 
  let { html_url: gistUrl } = await createGist(codeSnippet, {
    description,
    fileName: `snippet.${language}`, 
    isPublic: true,
  })

  // Open the created Gist in the browser
  await browse(gistUrl)
}
```

##  Monitor System CPU and Memory Usage in a Widget

```typescript
// Name: System Resource Monitor 
// Description: Monitors CPU and memory usage in a widget 
// Author: johnlindquist 

import "@johnlindquist/kit"
import si from "systeminformation"
import Chart from "chart.js/auto" // Make sure to install Chart.js

// Create arrays to store CPU and memory usage data
const cpuUsageData: number[] = []
const memoryUsageData: number[] = []

// Create a widget to display CPU and memory usage charts 
const monitorWidget = await widget( 
  `
<div class="p-4">
  <h2 class="text-xl font-bold">System Resource Monitor</h2>
  <div class="flex flex-col gap-4">
    <div>
      <canvas id="cpu-chart" width="300" height="150"></canvas>
    </div>
    <div>
      <canvas id="memory-chart" width="300" height="150"></canvas> 
    </div>
  </div> 
</div>
`, 
  {
    width: 350, // Set a custom width for the widget
    height: 400, // Set a custom height for the widget 
  }
)

// Get the canvas elements from the widget 
const cpuChartCanvas = monitorWidget.querySelector("#cpu-chart") 
const memoryChartCanvas = monitorWidget.querySelector("#memory-chart")

// Create Chart.js instances for the CPU and memory charts
const cpuChart = new Chart(cpuChartCanvas, {
  type: "line",
  data: {
    labels: [], // Initially empty labels, will be updated dynamically
    datasets: [
      {
        label: "CPU Usage", 
        data: cpuUsageData, 
        borderColor: "rgb(75, 192, 192)",
        tension: 0.1, 
        fill: true,
      }, 
    ], 
  },
  options: {
    scales: { 
      y: {
        // Set the y-axis scale for CPU usage (0-100%)
        min: 0,
        max: 100,
      },
    }, 
  }, 
})

const memoryChart = new Chart(memoryChartCanvas, { 
  type: "line",
  data: { 
    labels: [], // Initially empty labels, will be updated dynamically
    datasets: [ 
      {
        label: "Memory Usage", 
        data: memoryUsageData,
        borderColor: "rgb(255, 99, 132)",
        tension: 0.1, 
        fill: true, 
      },
    ], 
  }, 
  options: {
    scales: {
      y: {
        // Set the y-axis scale for memory usage (in MB) 
        min: 0, 
        max: (await si.mem()).total / (1024 * 1024),
      }, 
    },
  },
})

// Update CPU and memory usage data every second 
setInterval(async () => {
  // Get current CPU and memory usage
  const { currentLoad } = await si.currentLoad() 
  const { used: memoryUsed } = await si.mem()

  // Add the current CPU and memory usage to the data arrays 
  cpuUsageData.push(currentLoad) 
  memoryUsageData.push(memoryUsed / (1024 * 1024)) // Convert memory usage to MB

  // Limit the data arrays to the last 60 data points (1 minute)
  if (cpuUsageData.length > 60) {
    cpuUsageData.shift()
  }
  if (memoryUsageData.length > 60) {
    memoryUsageData.shift()
  }

  // Update the chart labels
  cpuChart.data.labels = Array.from({ length: 60 }, (_, i) => `${60 - i}s`).reverse() 
  memoryChart.data.labels = Array.from({ length: 60 }, (_, i) => `${60 - i}s`).reverse()

  // Update the charts
  cpuChart.update() 
  memoryChart.update() 
}, 1000) 

// Keep the script running to keep the widget active
hide()
```




## Send a WhatsApp Message with a Button

```typescript
// Name: Send WhatsApp Message with Button
// Description: Sends a WhatsApp message with an interactive button using the Twilio API
// Author: johnlindquist

import "@johnlindquist/kit"

// Get your Account SID and Auth Token from here: https://www.twilio.com/console 
const accountSid = await env("TWILIO_ACCOUNT_SID")
const authToken = await env("TWILIO_AUTH_TOKEN") 

// Initialize the Twilio client
const twilio = require("twilio")(accountSid, authToken)

// Prompt for the recipient's phone number (with country code)
const to = await arg("Enter recipient's phone number (with country code):")

// Prompt for the message body
const body = await arg("Enter message body:")

// Prompt for the button text 
const buttonText = await arg("Enter button text:") 

// Prompt for the URL the button should link to
const buttonUrl = await arg("Enter button URL:")

// Send the WhatsApp message with the interactive button
twilio.messages 
  .create({
    body,
    from: `whatsapp:${await env("TWILIO_WHATSAPP_NUMBER")}`, // Your Twilio WhatsApp number
    to: `whatsapp:${to}`,
    // Define the button parameters 
    buttons: [
      {
        type: "web_url",
        url: buttonUrl,
        title: buttonText, 
      }, 
    ], 
  })
  .then((message) => console.log(message.sid));

// Display a confirmation message
await div(md(`## WhatsApp message with button sent!`))
```

## Convert Text to Speech and Play with Different Voices

```typescript
// Name: Text to Speech with Voice Selection
// Description: Converts text to speech and allows choosing from different voices using the OpenAI API 
// Author: johnlindquist

import "@johnlindquist/kit"
import OpenAI from "openai"

// Get your OpenAI API key from here: https://platform.openai.com/account/api-keys
const OPENAI_API_KEY = await env("OPENAI_API_KEY") 

// Create a new OpenAI instance 
const openai = new OpenAI({ 
  apiKey: OPENAI_API_KEY, 
}) 

// Prompt the user to enter text 
const text = await arg("Enter text to convert to speech:")

// Display a list of available voices and allow the user to select one 
const voice = await arg("Select a voice:", [ 
  "alloy",
  "echo",
  "fable", 
  "onyx",
  "nova",
  "shimmer",
])

// Create speech audio using the OpenAI API with the selected voice
const response = await openai.audio.speech.create({ 
  model: "tts-1", 
  voice, // Use the selected voice
  input: text, 
})

// Play the audio
await playAudioFile(response.data)
```

##  Create a Time-Lapse from Screenshots with Custom FPS and Duration

```typescript 
// Name: Customizable Time-lapse from Screenshots 
// Description: Creates a time-lapse video from screenshots with custom FPS and duration 
// Author: johnlindquist 

import "@johnlindquist/kit"

// Prompt for the duration of the time-lapse recording (in minutes)
const durationMinutes = parseFloat(await arg("Enter time-lapse duration (minutes):")) 

// Prompt for the interval between captures (in seconds) 
const intervalSeconds = parseInt(await arg("Enter interval between captures (seconds):")) 

// Prompt for the desired frames per second (FPS) for the output video 
const fps = parseInt(await arg("Enter desired frames per second (FPS):")) 

// Prompt for the output file path
const outputFilePath = await path({ 
  startPath: home("Downloads"),
}) 

// Create a temporary directory to store screenshots 
const screenshotsDir = tmpPath("screenshots")
await ensureDir(screenshotsDir) 

// Calculate the total number of screenshots 
const totalScreenshots = Math.floor(durationMinutes * 60 / intervalSeconds) 

// Display a progress bar while capturing screenshots 
let screenshotCount = 0
const progressBar = await div(md(`# Capturing screenshots...

${screenshotCount} of ${totalScreenshots}`)) 

// Capture screenshots at the specified interval
let intervalId = setInterval(async () => {
  // Capture a screenshot
  const screenshotPath = path.join(
    screenshotsDir,
    `screenshot-${screenshotCount}.png`
  ) 
  await captureScreen({ 
    formats: ["png"],
    filePath: screenshotPath,
  })

  // Increment screenshot count and update progress bar
  screenshotCount++ 
  progressBar.setState({
    html: md(`# Capturing screenshots...

    ${screenshotCount} of ${totalScreenshots}`),
  }) 

  // Stop the timer when all screenshots are captured 
  if (screenshotCount >= totalScreenshots) {
    clearInterval(intervalId)
    // Close the progress bar
    progressBar.close() 
  }
}, intervalSeconds * 1000) 

// Wait for all screenshots to be captured 
await wait(durationMinutes * 60 * 1000) 

// Generate the time-lapse video from the captured images using ffmpeg with the specified FPS
await exec(`ffmpeg -y -framerate ${fps} -pattern_type glob -i '${screenshotsDir}/*.png' -c:v libx264 -pix_fmt yuv420p '${outputFilePath}'`, { shell: true })

// Display a notification 
await notify("Time-lapse video created!", `Saved to ${outputFilePath}`)

// Reveal the time-lapse video in Finder 
await revealFile(outputFilePath) 
```

## Get and Display System CPU Load

```typescript
// Name: CPU Load Monitor
// Description: Displays the current CPU load in a widget
// Author: johnlindquist

import "@johnlindquist/kit" 
import si from "systeminformation" 

// Create a widget to display CPU load 
const cpuLoadWidget = await widget(
  `
<div class="p-4"> 
  <h2 class="text-xl font-bold">CPU Load:</h2> 
  <p class="text-2xl">{{cpuLoad}}%</p> 
</div>
`,
  {
    width: 200, // Set a custom width for the widget 
  }
)

// Update CPU load every second 
setInterval(async () => {
  // Get the current CPU load 
  const { currentLoad } = await si.currentLoad()

  // Update the widget's state with the CPU load
  cpuLoadWidget.setState({
    cpuLoad: currentLoad.toFixed(2), // Display the CPU load with two decimal places 
  })
}, 1000)
```

## Convert an Image to Base64

```typescript
// Name: Image to Base64 Converter
// Description: Converts an image to Base64 and copies it to the clipboard 
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user to select an image file
const imagePath = await path({
  filters: [{ name: "Images", extensions: ["jpg", "jpeg", "png", "gif"] }],
})

// Read the image file as a buffer
const imageBuffer = await readFile(imagePath) 

// Convert the image buffer to a Base64 string 
const base64String = imageBuffer.toString("base64")

// Copy the Base64 string to the clipboard
await copy(base64String) 

// Display a notification
await notify("Image converted to Base64!", "Copied to clipboard")
```

##  Create a GitHub Repository from a Template

```typescript
// Name: Create Repo from Template
// Description: Creates a new GitHub repository from a template repository
// Author: johnlindquist 

import "@johnlindquist/kit"
import { Octokit } from "@octokit/rest"

// Get GitHub authentication token from environment variables
// You can get a token from here: https://github.com/settings/tokens
const githubToken = await env("GITHUB_TOKEN") 

// Create a new Octokit instance 
const octokit = new Octokit({
  auth: githubToken,
}) 

// Prompt for the owner of the template repository
const templateOwner = await arg("Enter template repository owner:")

// Prompt for the name of the template repository
const templateRepo = await arg("Enter template repository name:") 

// Prompt for the new repository name
const newRepoName = await arg("Enter new repository name:")

// Create the new repository from the template
await octokit.repos.createUsingTemplate({
  template_owner: templateOwner,
  template_repo: templateRepo, 
  name: newRepoName, 
  private: (await arg("Make repository private?", ["Yes", "No"])) === "Yes",
})

// Display a confirmation message 
await div(md(`## Repository created from template: ${templateOwner}/${templateRepo}`)) 
```

## Send a Direct Message on Twitter

```typescript
// Name: Send Twitter Direct Message 
// Description: Sends a direct message to a Twitter user
// Author: johnlindquist 

import "@johnlindquist/kit" 
import TwitterApi from "twitter-api-v2"

// Retrieve Twitter API credentials from environment variables
// You can create API keys and tokens here: https://developer.twitter.com/en/portal/dashboard
const TWITTER_API_KEY = await env("TWITTER_API_KEY") 
const TWITTER_API_SECRET = await env("TWITTER_API_SECRET") 
const TWITTER_ACCESS_TOKEN = await env("TWITTER_ACCESS_TOKEN")
const TWITTER_ACCESS_SECRET = await env("TWITTER_ACCESS_SECRET") 

// Create a new instance of the Twitter API client
const twitterClient = new TwitterApi({
  appKey: TWITTER_API_KEY,
  appSecret: TWITTER_API_SECRET,
  accessToken: TWITTER_ACCESS_TOKEN,
  accessSecret: TWITTER_ACCESS_SECRET, 
})

// Prompt for the recipient's Twitter username
const recipientUsername = await arg("Enter recipient's Twitter username:") 

// Prompt for the message content 
const message = await arg("Enter message:") 

// Authenticate with the Twitter API
const client = await twitterClient.readWrite 

// Find the recipient user's ID
const { data: user } = await client.v2.userByUsername(recipientUsername)

// Send the direct message to the recipient 
await client.v2.sendDm(user.id, message)

// Display a confirmation message
await div(md(`## Direct message sent to @${recipientUsername}!`))
```

## Check for Outdated Global npm Packages and Update

```typescript
// Name: Global Package Updater
// Description: Checks for and updates outdated globally installed npm packages 
// Author: johnlindquist 

import "@johnlindquist/kit"

// Run 'npm outdated -g --json' to get a list of outdated global packages in JSON format 
let { stdout: outdatedPackagesJson } = await exec("npm outdated -g --json", {
  shell: true,
})

// Parse the JSON output
const outdatedPackages = JSON.parse(outdatedPackagesJson) 

if (Object.keys(outdatedPackages).length > 0) {
  // Prompt for confirmation before updating packages
  let shouldUpdate = await arg({
      placeholder: `Found ${Object.keys(outdatedPackages).length} outdated global packages. Update them?`,
      height: PROMPT.HEIGHT.LG, 
    },
    ["Yes", "No"] 
  )

  // Update outdated packages
  if (shouldUpdate === "Yes") {
    for (const packageName in outdatedPackages) {
      // Display a progress message for each package 
      await div(md(`# Updating ${packageName}...`))

      // Update the package using `npm install -g`
      await exec(`npm install -g ${packageName}`, { shell: true }) 
    }
    // Display a notification when all updates are finished
    await notify("Global packages updated!") 
  }
} else {
  // Display a notification if all global packages are up to date
  await notify("All global npm packages are up to date!")
} 
```

## Create and Schedule a Zoom Meeting with Recurrence

```typescript 
// Name: Schedule Recurring Zoom Meeting 
// Description: Creates and schedules a recurring Zoom meeting using the Zoom API 
// Author: johnlindquist 

import "@johnlindquist/kit"
import zoomus from "zoomus"
import generator from "generate-password" 

// Get Zoom API credentials from environment variables
// You can create API keys and tokens here: https://marketplace.zoom.us/develop/create 
const ZOOM_API_KEY = await env("ZOOM_API_KEY") 
const ZOOM_API_SECRET = await env("ZOOM_API_SECRET")

// Initialize the Zoom client
const zoom = zoomus({ 
  apiKey: ZOOM_API_KEY,
  apiSecret: ZOOM_API_SECRET, 
}) 

// Prompt for the meeting topic 
const topic = await arg("Enter meeting topic:") 

// Prompt for the meeting start time (in UTC) 
const startTime = await arg(
  {
    placeholder: "Enter meeting start time (YYYY-MM-DDTHH:mm:ssZ):",
    hint: "Example: 2024-03-20T10:00:00Z", 
  }
)

// Prompt for the meeting duration in minutes
const duration = parseInt(await arg("Enter meeting duration (minutes):"))

// Prompt for the recurrence type (daily, weekly, monthly) 
const recurrenceType = await arg("Select recurrence type:", ["daily", "weekly", "monthly"])

// Prompt for the number of occurrences (e.g., for a weekly meeting happening 4 times, enter 4) 
const occurrences = parseInt(await arg("Enter number of occurrences:")) 

// Create the Zoom meeting with recurrence options
const { data: meeting } = await new Promise((resolve, reject) => {
  zoom.meeting.create(
    {
      topic, 
      type: 8, // Recurring meeting with fixed time 
      start_time: startTime, 
      duration,
      timezone: "UTC",
      password: generator.generate({ length: 10, numbers: true }), // Generate a random password
      recurrence: { 
        type: recurrenceType === "daily" ? 1 : recurrenceType === "weekly" ? 2 : 3, // Map recurrence type to API values 
        repeat_interval: 1, // Repeat every 1 day/week/month 
        end_times: occurrences, // Set the number of occurrences 
      },
    }, 
    (error, meeting) => {
      if (error) { 
        reject(error) 
      } else {
        resolve(meeting) 
      } 
    } 
  )
})

// Display the meeting join URL 
await div(md(`## Join Zoom Meeting:\n\n${meeting.join_url}`))

// Copy the join URL to the clipboard 
await copy(meeting.join_url) 
```
## Send a Text Message with a Scheduled Reminder

```typescript
// Name: Scheduled Text Reminder 
// Description: Sends a text message with a scheduled reminder using the Twilio API
// Author: johnlindquist

import "@johnlindquist/kit"
import schedule from "node-schedule" 

// Get your Account SID and Auth Token from here: https://www.twilio.com/console 
const accountSid = await env("TWILIO_ACCOUNT_SID")
const authToken = await env("TWILIO_AUTH_TOKEN")

// Initialize the Twilio client 
const twilio = require("twilio")(accountSid, authToken)

// Prompt for the recipient's phone number 
const to = await arg("Enter recipient's phone number (with country code):") 

// Prompt for the message to send 
const message = await arg("Enter message:")

// Prompt for the reminder time (in cron format)
const reminderTime = await arg(
  {
    placeholder: "Enter reminder time (cron format):",
    hint: "Example: 0 9 * * * (every day at 9 AM)", 
  }
)

// Send the initial text message 
twilio.messages 
  .create({ 
    body: message,
    from: await env("TWILIO_PHONE_NUMBER"), // Your Twilio phone number
    to,
  })
  .then((message) => console.log(message.sid))

// Schedule the reminder
schedule.scheduleJob(reminderTime, async () => {
  // Send the reminder message
  twilio.messages 
    .create({
      body: `Reminder: ${message}`,
      from: await env("TWILIO_PHONE_NUMBER"),
      to, 
    }) 
    .then((message) => console.log(message.sid)) 
  // Display a notification when the reminder is sent
  await notify("Reminder sent!", `to ${to}`) 
})

// Display a confirmation message 
await div(md(`## Message sent with reminder scheduled for: ${reminderTime}`))
```

## Check for Uncommitted Changes in a Git Repository

```typescript
// Name: Git Status Checker
// Description: Checks for uncommitted changes in the current Git repository
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the Git status using `git status --porcelain`
let { stdout: gitStatus } = await exec(`git status --porcelain`, {
  shell: true,
})

// Check if there are any uncommitted changes
if (gitStatus.trim().length > 0) { 
  // Display a warning message with the Git status
  await div(
    md(`
    ## Warning: Uncommitted Changes

    \`\`\` 
    ${gitStatus} 
    \`\`\` 
    `),
    "text-warn" // Add a warning color class to the div
  )
} else {
  // Display a message indicating no uncommitted changes 
  await div(md(`## No uncommitted changes.`))
}
```

##  Generate a PDF from a Web Page with Custom Options

```typescript
// Name: Advanced PDF Generator
// Description: Generates a PDF from a webpage with custom options using Puppeteer 
// Author: johnlindquist

import "@johnlindquist/kit"
import puppeteer from "puppeteer" 

// Prompt for the website URL
const url = await arg("Enter website URL:")

// Prompt for the output file path
const outputFilePath = await path({ 
  startPath: home("Downloads"),
  // Suggest a filename based on the website URL 
  suggestion: `${url.replace(/[^a-zA-Z0-9]/g, "_").slice(0, 20)}.pdf`,
}) 

// Prompt for the paper format (e.g., Letter, A4) 
const paperFormat = await arg("Select paper format:", [
  "Letter", 
  "A4",
  "Legal",
]) 

// Prompt for the page orientation (portrait or landscape)
const orientation = await arg("Select page orientation:", ["portrait", "landscape"]) 

// Launch a headless browser instance using Puppeteer
const browser = await puppeteer.launch({ headless: "new" })

try { 
  // Create a new page 
  const page = await browser.newPage() 

  // Navigate to the provided URL 
  await page.goto(url, { waitUntil: "networkidle0" }) 

  // Generate the PDF with custom options 
  await page.pdf({
    path: outputFilePath, 
    format: paperFormat, // Set the paper format
    landscape: orientation === "landscape", // Set the orientation
    // Set margins to 0 
    margin: { top: 0, right: 0, bottom: 0, left: 0 },
    // Optionally, wait for a specific element to be visible before generating the PDF
    // waitForSelector: "#my-element", 
    // Optionally, specify a timeout for the PDF generation
    timeout: 10000, 
  })

  // Display a notification 
  await notify("PDF generated!", `Saved to ${outputFilePath}`)

  // Reveal the PDF file in Finder 
  await revealFile(outputFilePath) 

} finally {
  // Close the browser instance
  await browser.close() 
}
```

## Generate a New npm Package

```typescript
// Name: Create npm Package
// Description: Creates a new npm package using the npm init command
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the package name
const packageName = await arg("Enter package name:")

// Create the package directory
await mkdir(packageName)

// Change to the package directory 
cd(packageName)

// Initialize the package using npm init, accepting defaults 
await exec(`npm init -y`, { shell: true })

// Prompt for the package entry point
const entryPoint = await arg("Enter package entry point (e.g., index.js):")

// Update the package.json with the entry point and start script 
await $`npm set-script start 'node ${entryPoint}'`

// Display a confirmation message 
await div(md(`## Package initialized at: ${process.cwd()}`))

// Open the package directory in VS Code
await exec(`code .`)
```

## Get Information About a GitHub User

```typescript 
// Name: GitHub User Info 
// Description: Displays information about a GitHub user 
// Author: johnlindquist 

import "@johnlindquist/kit" 

// Prompt for the GitHub username
const username = await arg("Enter GitHub username:")

// Fetch user information from the GitHub API
const response = await get(`https://api.github.com/users/${username}`) 

// Extract user data from the response 
const { login, name, bio, avatar_url, html_url, public_repos, followers, following } = response.data

// Display the user information in a div with an avatar image
await div(
  md(`## GitHub User: @${login}

* Name: ${name}
* Bio: ${bio}
* Repositories: ${public_repos}
* Followers: ${followers}
* Following: ${following} 

![Avatar](${avatar_url}) 
  `),
  "flex flex-col items-center" // Center the content in the div
) 
```

## Resize Images with Custom Dimensions and Quality

```typescript
// Name: Image Resizer with Quality
// Description: Resizes an image to custom dimensions with a specified quality
// Author: johnlindquist

import "@johnlindquist/kit" 
import sharp from "sharp" 

// Prompt for the image path 
const imagePath = await path({ 
  filters: [{ name: "Images", extensions: ["jpg", "jpeg", "png", "gif"] }], 
})

// Prompt for the desired width and height of the resized image 
const width = parseInt(await arg("Enter desired width (px):")) 
const height = parseInt(await arg("Enter desired height (px):"))

// Prompt for the desired output quality (0-100)
const quality = parseInt(await arg("Enter desired quality (0-100):")) 

// Resize and compress the image using sharp 
await sharp(imagePath)
  .resize(width, height) 
  .jpeg({ quality }) // Assuming JPEG output, adjust as needed 
  .toFile(imagePath)

// Display a notification 
await notify("Image resized!", `${imagePath}`)
```

##  Find and Open a File by Name

```typescript
// Name: Open File by Name
// Description: Searches for a file by name and opens it in the editor
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user for the file name to search for
const fileName = await arg("Enter file name:")

// Find the file using the `find` command 
const filePath = await find(fileName)

// Open the found file in the editor 
await edit(filePath)
```

##  Generate API Documentation with a Custom Configuration File

```typescript
// Name: Generate API Docs with Config 
// Description: Generates API documentation for a Node.js project using Swagger with a custom configuration file
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt the user to select the Swagger configuration file 
const configFilePath = await path({
  // Start in the current directory
  startPath: ".", 
  // Filter for JavaScript and JSON configuration files
  filters: [{ name: "Configuration Files", extensions: ["js", "json"] }], 
  // Provide a hint
  hint: "Select your Swagger configuration file (e.g., swagger.config.js).",
}) 

// Generate API documentation using Swagger JSDoc with the specified configuration file 
await exec(`npx swagger-jsdoc -d '${configFilePath}' -o ./docs`, {
  shell: true,
})

// Display a confirmation message 
await div(md(`## API documentation generated in the 'docs' directory!`))
```



## Generate a Secure Password and Save It to Bitwarden

```typescript
// Name: Generate and Save Password to Bitwarden
// Description: Generates a secure password and saves it to Bitwarden
// Author: johnlindquist

import "@johnlindquist/kit"
import generator from "generate-password";
//Install the Bitwarden CLI: https://bitwarden.com/help/cli/
// You can get your session key by running: `bw login --apikey` in the terminal

// Generate a secure password
const password = generator.generate({
  length: 20,
  numbers: true,
  symbols: true, 
  uppercase: true, 
  lowercase: true,
});

// Prompt for the website or service the password is for 
const website = await arg("Enter website or service:");

// Prompt for the username associated with the password
const username = await arg("Enter username:");

// Construct the command to add the password to Bitwarden
const command = `bw create login --name "${website}" --username "${username}" --password "${password}"`

// Execute the command to add the password to Bitwarden
await exec(command, { shell: true });

// Display a confirmation message
await div(md(`## Password generated and saved to Bitwarden!`));
```

##  Optimize PNG Images

```typescript
// Name: Optimize PNG Images
// Description: Optimizes PNG images in a directory using 'pngquant'
// Author: johnlindquist 

import "@johnlindquist/kit"

// Prompt for the directory containing images
const directoryPath = await path({
  onlyDirs: true, 
})

// Get all PNG files in the directory
const imageFiles = await globby([`${directoryPath}/*.png`]) 

// Optimize each PNG image using pngquant (assuming it's installed)
// More info: https://pngquant.org/
for (const imagePath of imageFiles) {
  // Display a progress message
  await div(md(`# Optimizing ${path.basename(imagePath)}...`))
  // Run pngquant with options for speed and quality
  await exec(`pngquant --speed 1 --quality=65-80 '${imagePath}' -o '${imagePath.replace(/\.png$/, "-optimized.png")}'`, { shell: true })
  await mv(imagePath.replace(/\.png$/, "-optimized.png"), imagePath)
}

// Display a notification 
await notify("PNG images optimized!", `in ${directoryPath}`)
```

## Convert Video to GIF with Custom Start and End Times

```typescript
// Name: Trimmed Video to GIF
// Description: Creates a GIF from a video with specific start and end times 
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the video file path
const videoFilePath = await path({ 
  filters: [{ name: "Videos", extensions: ["mp4", "mov", "avi", "mkv"] }], 
})

// Prompt for the start time (in seconds) 
const startTime = parseFloat(await arg("Enter start time (seconds):"))

// Prompt for the end time (in seconds)
const endTime = parseFloat(await arg("Enter end time (seconds):")) 

// Calculate the duration 
const duration = endTime - startTime

// Extract the directory and file name from the video file path 
const { dir, name } = path.parse(videoFilePath) 

// Create the output file path for the GIF 
const outputFilePath = path.join(dir, `${name}-trimmed.gif`)

// Convert the video to an animated GIF using ffmpeg, 
// specifying the start time, duration, and other options 
await exec(
  `ffmpeg -y -ss ${startTime} -t ${duration} -i "${videoFilePath}" -vf "fps=10,scale=480:-1:flags=lanczos,split[s0][s1];[s0]palettegen[p];[s1][p]paletteuse" -loop 0 "${outputFilePath}"`, 
  { shell: true } 
)

// Display a notification
await notify("Video converted to GIF!", `Saved to ${outputFilePath}`)

// Reveal the GIF in Finder
await revealFile(outputFilePath) 
```

## Clean Up Unused Files and Directories

```typescript
// Name: Deep Clean Project 
// Description: Removes unnecessary files and empty directories in a project
// Author: johnlindquist 

import "@johnlindquist/kit"

// Prompt for the project directory
const directoryPath = await path({ 
  onlyDirs: true, 
})

// Prompt for confirmation before cleaning up
const shouldClean = await arg("Clean up unnecessary files and directories?", ["Yes", "No"]) 

if (shouldClean === "Yes") { 
  // Find unnecessary files using common glob patterns (adjust as needed)
  const unnecessaryFiles = await globby([
    `${directoryPath}/**/*.DS_Store`, 
    `${directoryPath}/**/thumbs.db`, 
    `${directoryPath}/**/desktop.ini`,
    `${directoryPath}/node_modules`, 
    `${directoryPath}/dist`,
  ], {
    dot: true, // Include dotfiles in the search
  })

  // Remove unnecessary files
  await trash(unnecessaryFiles) 

  // Find and remove empty directories
  await exec(`find '${directoryPath}' -type d -empty -delete`, { shell: true })

  // Display a notification 
  await notify("Project cleaned up!")
}
```

## Download a File and Display Its Content in the Editor 

```typescript
// Name: Download and View File
// Description: Downloads a file from a URL and displays its contents in the editor
// Author: johnlindquist 

import "@johnlindquist/kit"

// Prompt for the file URL
const fileUrl = await arg("Enter file URL:")

// Prompt the user for the desired file extension
const fileExtension = await arg("Enter the desired file extension:")

// Create a temporary file path with the specified extension
const tempFilePath = tmpPath(`downloaded_file.${fileExtension}`)

// Download the file to the temporary location
await download(fileUrl, tempFilePath) 

// Read the content of the downloaded file 
const fileContent = await readFile(tempFilePath, "utf-8")

// Determine the language for syntax highlighting based on the file extension
const language = fileExtension === "js" ? "javascript" : fileExtension

// Display the file content in the editor with syntax highlighting
await editor(fileContent, { language, file: tempFilePath })
```

## Create a ZIP Archive of Selected Files

```typescript
// Name: Create ZIP Archive
// Description: Creates a ZIP archive of selected files 
// Author: johnlindquist

import "@johnlindquist/kit"
import archiver from "archiver" 

// Prompt the user to select files
const selectedFilePaths = await selectFile({
  multiple: true, // Allow selecting multiple files
})

// Prompt for the output file path
const outputFilePath = await path({
  startPath: home("Downloads"),
  suggestion: "archive.zip", // Suggest a default file name
})

// Create a write stream for the output file 
const output = createWriteStream(outputFilePath) 

// Create a new archiver instance for ZIP compression
const archive = archiver("zip", { 
  zlib: { level: 9 }, // Set compression level 
}) 

// Listen for errors during archiving 
archive.on("error", (error) => {
  throw error 
})

// Finalize the archive when done 
output.on("close", () => {
  console.log(`Archive created at: ${outputFilePath}`) 
}) 

// Pipe the archive data to the output stream 
archive.pipe(output)

// Add the selected files to the archive
for (const filePath of selectedFilePaths) {
  // Get the file name from the path 
  const fileName = path.basename(filePath) 

  // Add the file to the archive, preserving its original directory structure 
  archive.file(filePath, { name: fileName }) 
}

// Finalize the archive
await archive.finalize()

// Display a notification 
await notify("ZIP archive created!", `Saved to ${outputFilePath}`) 

// Reveal the archive file in Finder
await revealFile(outputFilePath)
```

##  Batch Convert Images to Grayscale

```typescript
// Name: Bulk Grayscale Converter
// Description: Converts all images in a directory to grayscale using sharp
// Author: johnlindquist

import "@johnlindquist/kit"
import sharp from "sharp"

// Prompt the user to select a directory 
const directoryPath = await path({
  onlyDirs: true, 
})

// Get all image files in the directory
const imageFiles = await globby([`${directoryPath}/*.{jpg,jpeg,png,gif,webp}`])

// Convert each image to grayscale using sharp
for (const imagePath of imageFiles) {
  await sharp(imagePath)
    .grayscale() 
    .toFile(imagePath)
}

// Display a notification 
await notify("Images converted to grayscale!", `in ${directoryPath}`) 
```




## Generate and Preview a Color Palette from an Image

```typescript
// Name: Image Color Palette with Preview
// Description: Generate a color palette from an image, and preview the colors
// Author: johnlindquist

import "@johnlindquist/kit"
import { Vibrant } from "node-vibrant" 

// Prompt the user to select an image
const imagePath = await path({
  filters: [{ name: "Images", extensions: ["jpg", "jpeg", "png", "gif", "webp"] }], 
})

// Extract the dominant color palette from the image using Vibrant
const palette = await Vibrant.from(imagePath).getPalette()

// Prepare data for the color palette preview
const swatches = Object.entries(palette).map(([name, swatch]) => { 
  // Generate a preview div with the color as the background
  const preview = `<div style="background-color: ${swatch.getHex()}; width: 100%; height: 100%;"></div>`

  return {
    name: name, // Use the color name as the choice name
    value: swatch.getHex(), // Use the hexadecimal color code as the value 
    preview, // Set the preview HTML
  } 
}) 

// Prompt the user to select a color from the generated palette, providing previews for each color
const selectedColor = await arg({
  placeholder: "Select a color from the palette:",
  previewHeight: 80, // Adjust the preview height as needed
}, swatches)

// Copy the selected color to the clipboard
await copy(selectedColor)

// Display a notification
await notify("Color copied:", selectedColor)
```

##  Find and Open a Specific Line in a File

```typescript
// Name: Go to Line in File 
// Description: Opens a file in the editor and jumps to a specific line number
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the file path
const filePath = await path() 

// Prompt for the line number
const lineNumber = parseInt(await arg("Enter line number:"), 10)

// Open the file in the editor and jump to the specified line number 
await edit(filePath, "", lineNumber, 1)
```

## Convert Text to Speech and Share as Audio File

```typescript
// Name: Share Text as Speech
// Description: Converts text to speech using the OpenAI API and shares it as a downloadable link
// Author: johnlindquist

import "@johnlindquist/kit"
import OpenAI from "openai"

// Get your OpenAI API key from here: https://platform.openai.com/account/api-keys
const OPENAI_API_KEY = await env("OPENAI_API_KEY") 

// Create a new OpenAI instance
const openai = new OpenAI({
  apiKey: OPENAI_API_KEY,
})

// Prompt the user to enter text
const text = await arg("Enter text to convert to speech:")

// Generate speech audio using the OpenAI API 
const response = await openai.audio.speech.create({
  model: "tts-1",
  voice: "alloy", 
  input: text,
})

// Save the audio data to a temporary file
const tempFilePath = tmpPath("speech.mp3")
await writeFile(tempFilePath, Buffer.from(await response.arrayBuffer()))

// Upload the temporary file to a file sharing service (e.g., transfer.sh) 
// You can use other services like tmp.link, file.io, etc. 
const { stdout: shareUrl } = await exec(`curl --upload-file '${tempFilePath}' https://transfer.sh/`, { shell: true })

// Remove the temporary file
await trash(tempFilePath) 

// Display the share URL in a div
await div(md(`## Download audio file:\n\n${shareUrl}`)) 

// Copy the share URL to the clipboard
await copy(shareUrl) 
```

##  Get and Display System Network Interfaces

```typescript
// Name: Network Interface Viewer
// Description: Displays a list of network interfaces and their information 
// Author: johnlindquist 

import "@johnlindquist/kit"
import si from "systeminformation"

// Get network interfaces using the systeminformation library 
const networkInterfaces = await si.networkInterfaces() 

// Create choices for each network interface
const interfaceChoices = networkInterfaces.map(iface => ({
  name: iface.ifaceName, 
  value: iface,
  // Display basic interface information in the description
  description: `Type: ${iface.type}, MAC Address: ${iface.mac}`, 
  // Display detailed interface information in the preview
  preview: md(`
  ## Interface: ${iface.ifaceName}
  
  * Type: ${iface.type}
  * MAC Address: ${iface.mac}
  * IPv4 Address: ${iface.ip4}
  * IPv6 Address: ${iface.ip6}
  * Status: ${iface.operstate} 
  `),
})) 

// Prompt the user to select a network interface 
const selectedInterface = await arg({
  placeholder: "Select a network interface:",
  width: PROMPT.WIDTH.LG, // Use a custom width for the prompt
  height: PROMPT.HEIGHT.LG, // Use a custom height for the prompt
}, interfaceChoices)

// Display detailed information about the selected interface in a div
await div(
  md(`
## Interface Details:

* Name: ${selectedInterface.ifaceName} 
* Type: ${selectedInterface.type}
* MAC Address: ${selectedInterface.mac}
* IPv4 Address: ${selectedInterface.ip4} 
* IPv6 Address: ${selectedInterface.ip6} 
* Status: ${selectedInterface.operstate}
  `) 
) 
```

## Generate a Node.js Project

```typescript
// Name: Generate Node.js Project
// Description: Generates a new Node.js project using npm init
// Author: johnlindquist 

import "@johnlindquist/kit"

// Prompt for the project name
const projectName = await arg("Enter project name:")

// Create the project directory
await mkdir(projectName) 

// Change to the project directory
cd(projectName) 

// Initialize the project using npm init, accepting defaults
await exec(`npm init -y`, { shell: true }) 

// Prompt for the main script file name 
const mainScript = await arg("Enter main script file name (e.g., index.js):") 

// Create the main script file 
await writeFile(mainScript, `console.log("Hello from ${projectName}!")`) 

// Update the package.json with the main script and start script 
await $`npm set main ${mainScript}`
await $`npm set-script start 'node ${mainScript}'` 

// Display a confirmation message
await div(md(`## Node.js project created at: ${process.cwd()}`))

// Open the project directory in VS Code 
await exec(`code .`)
```

## Convert Text to Speech and Play in a Loop

```typescript
// Name: Looping Text to Speech
// Description: Converts text to speech and plays it in a loop using the OpenAI API 
// Author: johnlindquist

import "@johnlindquist/kit"
import OpenAI from "openai"

// Get your OpenAI API key from here: https://platform.openai.com/account/api-keys
const OPENAI_API_KEY = await env("OPENAI_API_KEY")

// Create a new OpenAI instance
const openai = new OpenAI({ 
  apiKey: OPENAI_API_KEY,
}) 

// Prompt for the text to convert 
const text = await arg("Enter text to convert to speech:") 

// Generate speech audio using the OpenAI API
const response = await openai.audio.speech.create({
  model: "tts-1",
  voice: "alloy",
  input: text, 
})

// Create a function to play the audio in a loop
const playAudioLoop = async () => {
  // Play the audio from the response stream 
  await playAudioFile(response.data) 
  // Recursively call the function to create a loop
  await playAudioLoop()
}

// Start the audio loop
await playAudioLoop()
```

##  Get Upcoming Events from Google Calendar

```typescript
// Name: Upcoming Events
// Description: Displays upcoming events from Google Calendar
// Author: johnlindquist

import "@johnlindquist/kit"
import { google } from "googleapis"
import { JWT } from "google-auth-library"

// Get credentials for Google Service Account through environment variables 
// You can create service account credentials here: https://console.cloud.google.com/apis/credentials
let SA_EMAIL = await env("GOOGLE_SA_EMAIL") 
let SA_KEY = await env("GOOGLE_SA_CREDS")

// Define the scopes and client
let jwtClient = new JWT({
  email: SA_EMAIL,
  key: SA_KEY, 
  scopes: ["https://www.googleapis.com/auth/calendar.readonly"], 
})

let calendar = google.calendar("v3") 

// Function to list upcoming events from the calendar
async function listUpcomingEvents(auth) {
  // Get the current time 
  const now = new Date()

  // Fetch upcoming events from the primary calendar
  const response = await calendar.events.list({
    auth,
    calendarId: "primary",
    timeMin: now.toISOString(), // Only retrieve events starting from now 
    maxResults: 10, // Limit the number of events retrieved
    singleEvents: true,
    orderBy: "startTime",
  }) 

  // Return the events
  return response.data.items 
} 

// Get the upcoming events
const events = await listUpcomingEvents(jwtClient)

// Display the events in a div, formatting the start time 
await div( 
  md(`## Upcoming Events: 

${events.map(event => `- ${event.summary} - ${new Date(event.start.dateTime).toLocaleString()}`).join("\n")}
  `)
)
```


## Analyze Image with Google Vision API

```typescript
// Name: Image Analyzer
// Description: Analyzes an image using the Google Cloud Vision API
// Author: johnlindquist

import "@johnlindquist/kit"
import vision from "@google-cloud/vision"

// Get your Google Cloud service account key file path from environment variables
// You can create a service account and download the key file here: https://cloud.google.com/vision/docs/setup#creating_a_service_account
const GOOGLE_APPLICATION_CREDENTIALS = await env("GOOGLE_APPLICATION_CREDENTIALS")

// Create a new image annotator client
const client = new vision.ImageAnnotatorClient() 

// Prompt the user to select an image
const imagePath = await path({ 
  filters: [{ name: "Images", extensions: ["jpg", "jpeg", "png", "gif"] }], 
})

// Perform label detection on the image using the Vision API 
const [result] = await client.labelDetection(imagePath) 
const labels = result.labelAnnotations;

// Display the detected labels in a div 
await div(
  md(`## Image Labels:

${labels.map(label => `- ${label.description} (Score: ${label.score})`).join("\n")}
  `)
)
```

##  Extract Text from a Screenshot

```typescript
// Name: Screenshot Text Extractor 
// Description: Extracts text from a screenshot using Tesseract OCR 
// Author: johnlindquist 

import "@johnlindquist/kit"
import Tesseract from "tesseract.js" 

// Prompt the user to capture a screenshot
await div(md(`# Capture a screenshot...`))
// Capture a screenshot and save it to a temporary file
const screenshotPath = await captureScreen({ formats: ["png"] }) 

// Perform OCR on the screenshot using Tesseract 
const { data: { text } } = await Tesseract.recognize(screenshotPath) 

// Display the extracted text in the editor 
await editor(text, {
  language: "text", 
})
```

## Create a New Trello Card with a Due Date

```typescript
// Name: Trello Card with Due Date
// Description: Creates a new Trello card with a due date
// Author: johnlindquist

import "@johnlindquist/kit"

// Get Trello API credentials and list ID from environment variables
// You can get your API key and token here: https://trello.com/app-key 
const TRELLO_API_KEY = await env("TRELLO_API_KEY")
const TRELLO_API_TOKEN = await env("TRELLO_API_TOKEN")
// You can get the list ID from the Trello list URL
const TRELLO_LIST_ID = await env("TRELLO_LIST_ID") 

// Prompt for the card name
const cardName = await arg("Enter card name:")

// Prompt for the card description 
const cardDescription = await arg("Enter card description:") 

// Prompt for the due date in YYYY-MM-DD format
const dueDate = await arg("Enter due date (YYYY-MM-DD):")

// Create the Trello card with the due date using the API
await post(
  `https://api.trello.com/1/cards?idList=${TRELLO_LIST_ID}&name=${encodeURIComponent(
    cardName
  )}&desc=${encodeURIComponent(
    cardDescription
  )}&due=${dueDate}&key=${TRELLO_API_KEY}&token=${TRELLO_API_TOKEN}`
)

// Display a confirmation message 
await div(md(`## Trello card created with due date: ${dueDate}`))
```

## Check for GitHub Repository Issues with Labels

```typescript
// Name: GitHub Issue Finder with Labels
// Description: Finds issues in a GitHub repository with specific labels
// Author: johnlindquist

import "@johnlindquist/kit"
import { Octokit } from "@octokit/rest"

// Prompt for the GitHub repository name (owner/repo)
const repo = await arg("Enter repository name (owner/repo):") 

// Split the input into owner and repository name 
const [owner, repoName] = repo.split("/") 

// Prompt for labels, separated by commas 
const labelInput = await arg("Enter labels (comma-separated):")

// Split the labels into an array
const labels = labelInput.split(",").map(label => label.trim())

// Create a new Octokit instance
const octokit = new Octokit()

// Fetch issues for the specified repository with the selected labels
const { data: issues } = await octokit.issues.listForRepo({
  owner, 
  repo: repoName,
  labels,
  state: "open", // Retrieve only open issues
}) 

// Display the list of issues in a div
await div(
  md(`
## Issues for ${repo} with labels ${labels.join(", ")}:

${issues.map(issue => `- [${issue.title}](${issue.html_url})`).join("\n")} 
`)
)
```

## Convert Audio File to Different Format

```typescript
// Name: Audio Format Converter 
// Description: Converts an audio file to a different format using ffmpeg 
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user to select an audio file 
const audioFilePath = await path({
  filters: [{ name: "Audio Files", extensions: ["mp3", "wav", "m4a", "ogg", "flac"] }], 
})

// Prompt for the desired output format 
const outputFormat = await arg( 
  { 
    placeholder: "Enter output format (e.g., mp3, wav, flac):", 
    // Provide suggestions for common audio formats
    suggest: input => {
      return ["mp3", "wav", "flac", "ogg"].filter(format => format.startsWith(input))
    },
  }
)

// Extract the directory and file name from the input audio file path
const { dir, name } = path.parse(audioFilePath)

// Create the output file path
const outputFilePath = path.join(dir, `${name}.${outputFormat}`)

// Convert the audio file to the specified format using ffmpeg
await exec(`ffmpeg -i "${audioFilePath}" "${outputFilePath}"`, { shell: true })

// Display a notification 
await notify("Audio file converted!", `Saved to ${outputFilePath}`)

// Reveal the converted audio file in Finder
await revealFile(outputFilePath)
```

## Generate a Changelog from Git History

```typescript
// Name: Generate Changelog from Git History
// Description: Generates a changelog based on Git commit messages 
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt for the number of commits to include in the changelog 
const commitCount = parseInt(await arg("Enter the number of commits to include:"))

// Get the Git log for the specified number of commits
const { stdout: gitLog } = await exec(`git log --pretty=format:"%ad - %s [%an]" --date=short -n ${commitCount}`, { 
  shell: true,
})

// Generate the changelog content from the Git log
const changelogContent = `# Changelog\n\n${gitLog.split("\n").map(line => `- ${line}`).join("\n")}` 

// Display the changelog content in the editor 
await editor(changelogContent, {
  language: "markdown", 
})
```

##  Check if a Website is Using a Specific JavaScript Library

```typescript
// Name: Check for JavaScript Library
// Description: Checks if a website is using a specific JavaScript library using Puppeteer 
// Author: johnlindquist

import "@johnlindquist/kit"
import puppeteer from "puppeteer"

// Prompt for the website URL
const url = await arg("Enter website URL:")

// Prompt for the name of the JavaScript library to check
const libraryName = await arg("Enter JavaScript library name:") 

// Launch a headless browser instance using Puppeteer
const browser = await puppeteer.launch({ headless: "new" }) 

try {
  // Create a new page 
  const page = await browser.newPage() 

  // Navigate to the website 
  await page.goto(url, { waitUntil: "networkidle0" }) 

  // Check if the library is loaded on the page using Puppeteer's evaluate method
  const isLibraryUsed = await page.evaluate((libraryName) => {
    return typeof window[libraryName] !== "undefined" 
  }, libraryName)

  // Display the result 
  if (isLibraryUsed) {
    await div(md(`## The website uses ${libraryName}.`))
  } else {
    await div(md(`## The website does not use ${libraryName}.`))
  } 
} finally {
  // Close the browser instance 
  await browser.close() 
}
```




## Extract Text from Multiple PDFs

```typescript
// Name: Bulk PDF Text Extractor 
// Description: Extracts text from multiple PDF files using pdf-parse 
// Author: johnlindquist

import "@johnlindquist/kit"
import { parse } from "pdf-parse"

// Prompt the user to select or drop multiple PDF files 
let selectedFilePaths = await getSelectedFile()
if (!selectedFilePaths) {
  selectedFilePaths = await drop({
    placeholder: "Drop PDF files here...",
    multiple: true,
  })
  // Extract file paths from the dropped files 
  selectedFilePaths = selectedFilePaths.map(file => file.path) 
} else {
  // Split the selected file paths into an array
  selectedFilePaths = selectedFilePaths.split("\n") 
}

// Create a temporary directory to store the extracted text files
const outputDir = tmpPath("extracted-text")
await ensureDir(outputDir)

// Display a progress bar during text extraction
let progress = 0 
const progressBar = await div(md(`# Extracting text from PDFs...

${progress}%`)) 

// Extract text from each PDF file
for (const filePath of selectedFilePaths) {
  // Extract text from the PDF file using pdf-parse 
  const pdfData = await readFile(filePath)
  const { textContent } = await parse(pdfData)

  // Create the output file path
  const outputFilePath = path.join(outputDir, `${path.basename(filePath, ".pdf")}.txt`)

  // Write the extracted text to the file
  await writeFile(outputFilePath, textContent) 

  // Update the progress bar
  progress = Math.floor((selectedFilePaths.indexOf(filePath) / selectedFilePaths.length) * 100)
  progressBar.setState({
    html: md(`# Extracting text from PDFs...

    ${progress}%`),
  })
} 

// Close the progress bar and display a notification 
progressBar.close()
await notify("Text extracted!", `Saved to ${outputDir}`)

// Reveal the output directory in Finder
await revealFile(outputDir) 
```

## Create and Run a Python Script

```python
# Name: Run Python Script
# Description: Creates and runs a Python script
# Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the script name 
const scriptName = await arg("Enter Python script name (e.g., my_script.py):") 

// Create the script file with basic content
await writeFile(scriptName, `print("Hello from Python!")`)

// Run the Python script using the `python` command 
await exec(`python ${scriptName}`, { shell: true })
```

##  Get Commit History for a GitHub Repository

```typescript
// Name: GitHub Repo Commit History
// Description: Displays the commit history for a GitHub repository 
// Author: johnlindquist 

import "@johnlindquist/kit"
import { Octokit } from "@octokit/rest" 

// Prompt for the GitHub repository (owner/name) 
const repo = await arg("Enter repository name (owner/repo):")

// Split the input into owner and repository name
const [owner, repoName] = repo.split("/")

// Create a new Octokit instance 
const octokit = new Octokit()

// Fetch the commit history for the specified repository 
const commits = await octokit.paginate(octokit.repos.listCommits, {
  owner,
  repo: repoName, 
  per_page: 100, // Retrieve up to 100 commits per page
})

// Display the commit history in a div
await div(
  md(`## Commit History for ${repo}:

${commits.map(commit => `- ${commit.commit.message} - ${commit.commit.author.name} (${commit.commit.author.date})`).join("\n")}
  `)
)
```

##  Convert Images to a Different Format and Resize

```typescript
// Name: Image Converter and Resizer
// Description: Converts and resizes images in a directory 
// Author: johnlindquist 

import "@johnlindquist/kit" 
import sharp from "sharp"

// Prompt for the image directory 
const directoryPath = await path({
  onlyDirs: true, 
})

// Prompt for the desired output format 
const outputFormat = await arg("Enter desired output format (e.g., png, webp):")

// Prompt for the desired width 
const width = parseInt(await arg("Enter desired width (px):"))

// Get all image files in the directory
const imageFiles = await globby([`${directoryPath}/*.{jpg,jpeg,png,gif,webp}`]) 

// Display a progress bar
let progress = 0 
const progressBar = await div(md(`# Converting and resizing images...

${progress}%`))

// Convert and resize images
for (const imagePath of imageFiles) {
  // Convert and resize the image using sharp 
  await sharp(imagePath)
    .resize({ width })
    .toFormat(outputFormat)
    .toFile(imagePath.replace(/\.(jpg|jpeg|png|gif|webp)$/, `-${width}.${outputFormat}`)) 

  // Update the progress bar
  progress = Math.floor((imageFiles.indexOf(imagePath) / imageFiles.length) * 100) 
  progressBar.setState({
    html: md(`# Converting and resizing images... 

    ${progress}%`), 
  })
} 

// Close the progress bar and display a notification
progressBar.close()
await notify("Images converted and resized!", `in ${directoryPath}`) 
```

## Create a Shortcut to Run a Terminal Command

```typescript
// Name: Create Terminal Shortcut 
// Description: Creates a shortcut to run a terminal command
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt for the terminal command to execute
const command = await arg("Enter the terminal command to execute:")

// Prompt for the shortcut key combination 
const shortcut = await hotkey({
  placeholder: "Press the desired shortcut key combination:", 
}) 

// Register the shortcut to execute the terminal command
registerShortcut(shortcut.shortcut, async () => {
  // Execute the command in the terminal
  await exec(command, { shell: true })
})

// Display a notification
await notify("Shortcut created!", `Press ${shortcut.shortcut} to run: ${command}`) 
```

##  Get Random Advice

```typescript 
// Name: Get Advice 
// Description: Displays a random piece of advice from the Advice Slip API
// Author: johnlindquist

import "@johnlindquist/kit" 

// Fetch a random piece of advice from the Advice Slip API
const response = await get("https://api.adviceslip.com/advice")

// Extract the advice 
const { slip } = response.data

// Display the advice in a div 
await div(md(`## Advice:\n\n${slip.advice}`)) 
```

##  Send a File to a Slack Channel

```typescript
// Name: Send File to Slack 
// Description: Sends a file to a Slack channel
// Author: johnlindquist 

import "@johnlindquist/kit" 
import { WebClient } from "@slack/web-api" 

// Get your Slack API token from here: https://api.slack.com/apps 
const slackToken = await env("SLACK_API_TOKEN")

// Create a new instance of the Slack WebClient
const slackClient = new WebClient(slackToken) 

// Prompt the user for the Slack channel
const channel = await arg("Enter Slack channel:") 

// Prompt the user to select a file to send
const filePath = await path()

// Upload the file to Slack 
await slackClient.files.upload({ 
  // Specify the file path
  file: fs.createReadStream(filePath), 
  // Set the file name
  filename: path.basename(filePath), 
  // Specify the Slack channel
  channels: channel,
}) 

// Display a confirmation message
await div(md(`## File sent to Slack channel: ${channel}`)) 
```


## Generate TypeScript types from GraphQL Schema

```typescript
// Name: Generate Types from GraphQL Schema 
// Description: Generates TypeScript types from a GraphQL schema using the 'graphql-code-generator' library
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the path to the GraphQL schema file 
const schemaFilePath = await path({
  filters: [{ name: "GraphQL Schema", extensions: ["graphql", "gql", "schema.json"] }],
})

// Prompt for the output directory for the generated types
const outputDir = await arg("Enter output directory for generated types:")

// Generate TypeScript types from the GraphQL schema using graphql-code-generator 
// This assumes you have graphql-code-generator installed: https://www.npmjs.com/package/@graphql-codegen/cli 
await exec(`npx graphql-codegen --schema  '${schemaFilePath}' --generates  '${outputDir}/':  typescript`, {
  shell: true,
})

// Display a notification
await notify("TypeScript types generated!", `Saved to ${outputDir}`)

// Open the output directory in VS Code
await exec(`code ${outputDir}`)
```

## Create a New GitHub Issue

```typescript
// Name: Create GitHub Issue
// Description: Creates a new issue on GitHub with interactive prompts 
// Author: johnlindquist

import "@johnlindquist/kit"
import { Octokit } from "@octokit/rest"

// Get GitHub authentication token from environment variables
// You can get a token from here: https://github.com/settings/tokens
const githubToken = await env("GITHUB_TOKEN")

// Prompt for the repository name (owner/repo)
const repo = await arg("Enter repository name (owner/repo):")

// Split the input into owner and repository name
const [owner, repoName] = repo.split("/")

// Create a new Octokit instance
const octokit = new Octokit({
  auth: githubToken, 
})

// Prompt for the issue title
const title = await arg("Enter issue title:") 

// Prompt for the issue body using the editor
const body = await editor({ 
  placeholder: "Enter issue body (Markdown supported):",
  language: "markdown",
})

// Create the new issue on GitHub 
const { data: newIssue } = await octokit.issues.create({
  owner,
  repo: repoName, 
  title, 
  body, 
}) 

// Display a confirmation message with a link to the new issue 
await div(md(`## Issue created: [${newIssue.html_url}](${newIssue.html_url})`))

// Open the new issue in the browser
await browse(newIssue.html_url)
```

##  Convert Images to ASCII Art

```typescript
// Name: Batch ASCII Art Generator
// Description: Converts all images in a directory to ASCII art
// Author: johnlindquist

import "@johnlindquist/kit"
import { imageToAscii } from "image-to-ascii"

// Prompt for the directory containing images
const directoryPath = await path({
  onlyDirs: true,
})

// Get all image files in the selected directory 
const imageFiles = await globby([`${directoryPath}/*.{jpg,jpeg,png,gif,webp}`])

// Create an output directory for the ASCII art files
const outputDir = path.join(directoryPath, "ascii-art") 
await ensureDir(outputDir) 

// Convert each image to ASCII art 
for (const imagePath of imageFiles) {
  // Generate ASCII art with a maximum width of 80 characters
  const asciiArt = await imageToAscii(imagePath, {
    width: 80, 
  })

  // Create the output file path for the ASCII art
  const outputFilePath = path.join(
    outputDir,
    `${path.basename(imagePath, path.extname(imagePath))}.txt`
  )

  // Write the ASCII art to the file 
  await writeFile(outputFilePath, asciiArt)
}

// Display a notification
await notify("ASCII art generated!", `Saved to ${outputDir}`)
```

##  Check for Available Updates to Kit.app

```typescript
// Name: Check for Kit Updates
// Description: Checks for the latest version of Kit.app and prompts to download if an update is available 
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the latest release information for Kit.app from the GitHub API 
const releaseInfo = await get("https://api.github.com/repos/johnlindquist/kit/releases/latest")
  .then(res => res.data)
  .catch(err => ({ tag_name: "unknown" })) 

// Get the current version of the app 
const currentVersion = (await getAppState())?.version || "unknown";

// Compare versions, only prompting for updates if a newer version is available 
if (releaseInfo.tag_name !== currentVersion) {
  // Prompt the user to download the update 
  let shouldDownload = await arg(
    {
      placeholder: `A new version of Kit is available: ${releaseInfo.tag_name}\nDownload and install?`,
      hint: `Current version is: ${currentVersion}`,
    }, 
    ["Yes", "No"] 
  )
  if (shouldDownload === "Yes") {
    // Open the latest release URL in the browser
    await browse(releaseInfo.html_url)
  } 
} else {
  // Display a message if the app is up to date 
  await div(md(`## You're using the latest version of Kit.app! ðŸŽ‰`))
}
```

##  Clean Up Unused Docker Resources

```typescript
// Name: Docker Cleanup
// Description: Removes unused Docker images, containers, networks, and volumes
// Author: johnlindquist 

import "@johnlindquist/kit" 

// Prompt for confirmation before cleaning up Docker resources
const shouldClean = await arg("Clean up unused Docker images, containers, networks, and volumes?", ["Yes", "No"])

if (shouldClean === "Yes") {
  // Remove unused images, containers, networks, and volumes using Docker commands
  await $`docker image prune -a`
  await $`docker container prune`
  await $`docker network prune` 
  await $`docker volume prune`

  // Display a notification
  await notify("Unused Docker resources removed!") 
}
```

## Extract Text from a Handwritten Image

```typescript
// Name: Handwriting to Text Converter 
// Description: Extracts text from a handwritten image using the Google Cloud Vision API 
// Author: johnlindquist

import "@johnlindquist/kit"
import vision from "@google-cloud/vision" 

// Get your Google Cloud service account key file path from environment variables 
// You can create a service account and download the key file here: https://cloud.google.com/vision/docs/setup#creating_a_service_account 
const GOOGLE_APPLICATION_CREDENTIALS = await env("GOOGLE_APPLICATION_CREDENTIALS") 

// Create a new image annotator client 
const client = new vision.ImageAnnotatorClient()

// Prompt the user to select an image
const imagePath = await path({
  filters: [{ name: "Images", extensions: ["jpg", "jpeg", "png", "gif"] }], 
}) 

// Perform document text detection on the image using the Vision API
const [result] = await client.documentTextDetection(imagePath) 
const fullTextAnnotation = result.fullTextAnnotation 

// Display the extracted text in the editor
await editor(fullTextAnnotation.text, { language: "text" }) 
```

## Send a Scheduled Email with a File Attachment

```typescript
// Name: Scheduled Email with Attachment
// Description: Sends a scheduled email with a file attachment using Nodemailer
// Author: johnlindquist

import "@johnlindquist/kit" 
import nodemailer from "nodemailer"
import schedule from "node-schedule" 

// Get email credentials from environment variables 
// You can create an app password here: https://support.google.com/accounts/answer/185833?hl=en
const emailUser = await env("EMAIL_USER")
const emailPassword = await env("EMAIL_PASSWORD") 

// Create a Nodemailer transporter
const transporter = nodemailer.createTransport({
  service: "gmail", 
  auth: {
    user: emailUser,
    pass: emailPassword, 
  }, 
}) 

// Prompt for recipient email address
const to = await arg("Enter recipient email address:")

// Prompt for the email subject
const subject = await arg("Enter email subject:")

// Prompt for the email body
const body = await textarea({
  placeholder: "Enter email body:", 
})

// Prompt for the file path of the attachment
const attachmentPath = await path() 

// Prompt for the scheduled time (in cron format) 
const scheduleTime = await arg(
  {
    placeholder: "Enter schedule time (cron format):",
    hint: "Example: 0 9 * * * (every day at 9 AM)", 
  }
) 

// Schedule the email to be sent at the specified time
schedule.scheduleJob(scheduleTime, async () => {
  // Define email options with the attachment 
  const mailOptions = {
    from: emailUser,
    to, 
    subject,
    html: body, 
    attachments: [
      // Use the file path as the attachment 
      {
        path: attachmentPath,
      }, 
    ],
  } 

  // Send the email
  await transporter.sendMail(mailOptions)

  // Display a notification when the email is sent
  await notify("Scheduled email sent with attachment!", `to ${to}`) 
})

// Display a confirmation message 
await div(md(`## Email scheduled to be sent at: ${scheduleTime}`))
```


## Create a Custom Terminal Command with Interactive Prompts

```typescript
// Name: Interactive Command Creator
// Description: Creates a custom terminal command with interactive prompts
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the command name 
const commandName = await arg("Enter command name:") 

// Prompt for the command description
const commandDescription = await arg("Enter command description:") 

// Prompt for the command to execute, allowing for multiple lines
const commandToExecute = await editor({ 
  placeholder: "Enter the command to execute (including any arguments):",
  language: "bash", 
})

// Create the shell script content
const scriptContent = `#!/bin/bash

# ${commandDescription}

${commandToExecute}
`

// Create the shell script file path
const scriptPath = kenvPath("bin", commandName)

// Write the script content to the file
await writeFile(scriptPath, scriptContent)

// Make the script executable
await chmod("+x", scriptPath) 

// Display a confirmation message
await div(md(`## Custom terminal command "${commandName}" created!`)) 

// Open the script file in the editor for further customization
await edit(scriptPath) 
```

## Create a New Google Docs Document with Boilerplate Content

```typescript
// Name: New Google Doc from Template
// Description: Creates a new Google Doc with boilerplate content 
// Author: johnlindquist 

import "@johnlindquist/kit"
import { google } from "googleapis"
import { JWT } from "google-auth-library" 

// Get credentials for Google Service Account through environment variables
// You can create service account credentials here: https://console.cloud.google.com/apis/credentials
let SA_EMAIL = await env("GOOGLE_SA_EMAIL")
let SA_KEY = await env("GOOGLE_SA_CREDS")

// Define the scopes and client
let jwtClient = new JWT({ 
  email: SA_EMAIL,
  key: SA_KEY,
  scopes: ["https://www.googleapis.com/auth/documents"], 
})

let docs = google.docs("v1")

// Function to create a new Google Doc
async function createDocument(auth, title, content) {
  try {
    // Create the document with initial content
    const response = await docs.documents.create({
      auth,
      requestBody: {
        title, 
        content, 
      },
    })

    // Return the document ID and URL
    return response.data
  } catch (error) { 
    // Handle errors during document creation
    console.error(`Error creating document: ${error}`)
    await div(md(`## Error creating document: ${error}`))
  }
}

// Prompt for the document title
const documentTitle = await arg("Enter document title:")

// Prompt the user to select a template file 
const templateFilePath = await path()

// Read the contents of the template file
const templateContent = await readFile(templateFilePath, "utf-8")

// Create the Google Doc with the template content
const { documentId, url: documentUrl } = await createDocument(
  jwtClient, 
  documentTitle, 
  templateContent
) 

// Display a confirmation message
await div(md(`## Google Doc created from template!`))

// Open the document in the browser
await browse(documentUrl) 
```

## Extract Text from Images and Combine into a Single File

```typescript
// Name: Bulk Image Text Extractor to File
// Description: Extracts text from multiple images and combines the text into a single file 
// Author: johnlindquist

import "@johnlindquist/kit"
import Tesseract from "tesseract.js"

// Prompt for the output file path for the combined text 
const outputFilePath = await path({
  startPath: home("Downloads"),
  suggestion: `extracted-text-${formatDate(new Date(), "yyyy-MM-dd_HH-mm")}.txt`
})

// Prompt the user to select or drop multiple image files
let selectedFilePaths = await getSelectedFile()
// If no files are selected, prompt the user to drop files 
if (!selectedFilePaths) {
  selectedFilePaths = await drop({
    placeholder: "Drop image files here...", 
    multiple: true, 
  })
  // Extract file paths from the dropped files
  selectedFilePaths = selectedFilePaths.map(file => file.path) 
} else {
  // Split the selected file paths into an array
  selectedFilePaths = selectedFilePaths.split("\n")
}

// Display a progress bar while extracting text
let progress = 0
const progressBar = await div(md(`# Extracting text from images...

${progress}%`)) 

// Extract text from each image and append it to the output file 
for (const imagePath of selectedFilePaths) {
  // Perform OCR on the image using Tesseract
  const { data: { text } } = await Tesseract.recognize(imagePath)

  // Append the extracted text to the output file 
  await appendFile(outputFilePath, `\n--- ${imagePath} ---\n${text}`)

  // Update the progress bar
  progress = Math.floor((selectedFilePaths.indexOf(imagePath) / selectedFilePaths.length) * 100)
  progressBar.setState({
    html: md(`# Extracting text from images...

    ${progress}%`),
  })
} 

// Close the progress bar
progressBar.close()

// Display a notification 
await notify("Text extraction complete!", `Saved to ${outputFilePath}`)

// Reveal the output file in Finder
await revealFile(outputFilePath)
```

##  Get and Display System CPU Information

```typescript
// Name: CPU Info Viewer 
// Description: Displays detailed information about the CPU 
// Author: johnlindquist

import "@johnlindquist/kit" 
import si from "systeminformation" 

// Get CPU information using systeminformation
const cpu = await si.cpu() 

// Display the CPU information in a div
await div(
  md(`
## CPU Information:

* Manufacturer: ${cpu.manufacturer}
* Brand: ${cpu.brand} 
* Model: ${cpu.model}
* Speed: ${cpu.speed} GHz 
* Cores: ${cpu.cores} 
* Physical Cores: ${cpu.physicalCores} 
* Cache: 
    - L1: ${filesize(cpu.cache.l1d)} (data), ${filesize(cpu.cache.l1i)} (instruction)
    - L2: ${filesize(cpu.cache.l2)} 
    - L3: ${filesize(cpu.cache.l3)} 
  `)
)
```

## Check for Outdated npm Packages and Offer to Update

```typescript
// Name: npm Package Updater
// Description: Checks for outdated npm packages and offers to update them
// Author: johnlindquist

import "@johnlindquist/kit"

// Run npm outdated to list outdated packages
let { stdout: outdatedPackages } = await exec(`npm outdated --long`, {
  cwd: ".", 
  shell: true,
})

// If there are outdated packages, prompt for confirmation to update 
if (outdatedPackages.trim().length > 0) {
  let shouldUpdate = await arg(
    { 
      placeholder: "Outdated packages found. Update to latest versions?",
      // Show the list of outdated packages in the preview
      preview: md(outdatedPackages),
      // Set a custom height for the prompt
      height: PROMPT.HEIGHT.LG,
    },
    ["Yes", "No"] 
  )

  if (shouldUpdate === "Yes") { 
    // Update all packages to their latest versions
    await exec(`npm update`, { shell: true, cwd: "." }) 
    // Display a notification
    await notify("Packages updated!", "All packages updated to their latest versions.")
  }
} else {
  // Display a message if no packages are outdated 
  await div(md(`## All npm packages are up to date! ðŸŽ‰`))
}
```

##  Rename Files with Custom Patterns

```typescript
// Name: Batch File Renamer with Pattern
// Description: Renames multiple files in a directory using a custom pattern
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user to select a directory
const directoryPath = await path({
  onlyDirs: true, 
})

// Prompt for the search pattern (using regular expressions)
const searchPattern = await arg({ 
  placeholder: "Enter search pattern (regex):",
  // Provide an example in the hint 
  hint: "Example: (.*)\\.txt",
}) 

// Prompt for the replacement pattern (using capture groups from the search pattern)
const replacementPattern = await arg({ 
  placeholder: "Enter replacement pattern (use $1, $2, etc. for capture groups):",
  // Provide an example in the hint
  hint: "Example: $1.md",
}) 

// Rename files using the 'rename' command with regular expressions 
await exec(`rename 's/${searchPattern}/${replacementPattern}/g' *`, {
  shell: true, 
  cwd: directoryPath,
})

// Display a confirmation message
await div(md(`## Files renamed in ${directoryPath}!`))
```

## Generate and Preview an HTML Email Template

```typescript
// Name: HTML Email Template Generator
// Description: Generates and previews an HTML email template using Handlebars
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt the user to select a template file 
const templateFilePath = await path({
  // Start in the user's "templates" directory within their kenv
  startPath: kenvPath("templates"),
  // Filter for HTML files
  filters: [{ name: "HTML Templates", extensions: ["html"] }], 
})

// Read the template content
const templateContent = await readFile(templateFilePath, "utf-8")

// Compile the template using Handlebars
const template = compile(templateContent)

// Prompt for data to use in the template 
const templateData = await arg({
  placeholder: "Enter template data (JSON format):",
  // Adjust input height for multiline JSON
  inputHeight: 100,
})

// Parse the template data as JSON
const data = JSON.parse(templateData) 

// Render the HTML content using the template and data 
const htmlContent = template(data)

// Display the generated HTML content in a div for preview
await div(htmlContent) 
```




## Check and Update npm Dependencies

```typescript
// Name: Update Project Dependencies 
// Description: Checks for outdated npm dependencies and updates them interactively
// Author: johnlindquist

import "@johnlindquist/kit"

// Run `npm outdated` to get a list of outdated packages
const { stdout: outdatedPackages } = await exec(`npm outdated --long`, { shell: true, cwd: "." })

// If no outdated packages, display a message and exit
if (!outdatedPackages) {
  await div(md(`## All npm packages are up to date! ðŸŽ‰`))
  exit()
}

// Parse the output of npm outdated
const outdatedPackagesArray = outdatedPackages
  .split("\n")
  .map((line) => line.trim()) 
  .filter((line) => line.length > 0) 
  .map((line) => {
    // Extract package name, current version, wanted version, and latest version
    const [packageName, currentVersion, wantedVersion, latestVersion] = line.split(/\s+/) 
    return { packageName, currentVersion, wantedVersion, latestVersion }
  })

// Create an array of choices from the parsed outdated packages 
const updateChoices = outdatedPackagesArray.map(({ packageName, currentVersion, wantedVersion, latestVersion }) => ({
  name: `${packageName}: ${currentVersion} -> ${wantedVersion} (latest: ${latestVersion})`,
  value: packageName,
})) 

// Prompt the user to select packages to update
const packagesToUpdate = await select({
  placeholder: "Select packages to update:",
  multiple: true,
  width: PROMPT.WIDTH.LG, 
}, updateChoices)

// Update selected packages using 'npm install'
for (const packageName of packagesToUpdate) {
  await div(md(`# Updating ${packageName}...`))
  await $`npm install ${packageName}@latest`
}

// Display a notification
await notify("Packages updated!", "Selected packages have been updated.") 
```

##  Compress a PDF File with a Password

```typescript
// Name: Password-Protected PDF Compressor
// Description: Compresses a PDF and adds password protection using Ghostscript
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt for the PDF file path
const pdfFilePath = await path({
  filters: [{ name: "PDF Files", extensions: ["pdf"] }],
}) 

// Prompt for the password to protect the PDF
const password = await arg({
  placeholder: "Enter password:",
  secret: true, // Hide the password input
})

// Create a temporary file path for the compressed PDF
const compressedPdfPath = tmpPath(`compressed-${path.basename(pdfFilePath)}`) 

// Compress and password-protect the PDF using Ghostscript
// More info: https://www.ghostscript.com/doc/current/Use.htm#Password_security
await exec(`gs -sDEVICE=pdfwrite -dCompatibilityLevel=1.4 -dPDFSETTINGS=/ebook -dNOPAUSE -dQUIET -dBATCH -sOutputFile='${compressedPdfPath}' -sOwnerPassword=${password} '${pdfFilePath}'`, {
  shell: true, 
}) 

// Replace the original PDF with the compressed and password-protected PDF
await mv(compressedPdfPath, pdfFilePath) 

// Display a notification
await notify("PDF compressed and password-protected!", `${pdfFilePath}`)
```

## Extract Text from an Image Using OCR and Translate It

```typescript
// Name: OCR and Translate Image
// Description: Extracts text from an image using Tesseract OCR and translates it 
// Author: johnlindquist

import "@johnlindquist/kit" 
import Tesseract from "tesseract.js"
import translate from "@vitalets/google-translate-api" 

// Prompt for the image file path 
const imagePath = await path({
  filters: [{ name: "Images", extensions: ["jpg", "jpeg", "png", "gif"] }], 
})

// Prompt for the language of the text in the image 
const sourceLanguage = await arg("Enter the language of the text in the image (e.g., eng, spa):")

// Prompt for the target language 
const targetLanguage = await arg("Enter the target language code (e.g., 'es' for Spanish):")

// Perform OCR using Tesseract with the specified language 
const { data: { text } } = await Tesseract.recognize(imagePath, sourceLanguage) 

// Translate the extracted text using google-translate-api 
const { text: translatedText } = await translate(text, { to: targetLanguage }) 

// Display the translated text in the editor 
await editor(translatedText, {
  language: "text", 
})
```

## Create a New Git Branch and Switch to It

```typescript 
// Name: New Git Branch
// Description: Creates a new Git branch and switches to it
// Author: johnlindquist 

import "@johnlindquist/kit"

// Prompt for the branch name
const branchName = await arg("Enter new branch name:")

// Create and switch to the new branch
await $`git checkout -b ${branchName}` 

// Display a notification
await notify("Switched to branch:", `${branchName}`)
```

## Find and Replace in Selected Text

```typescript
// Name: Find and Replace in Selection
// Description: Finds and replaces text within the current selection
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the selected text
const selectedText = await getSelectedText()

// Prompt for the search string 
const searchText = await arg("Enter text to find:") 

// Prompt for the replacement string
const replacementText = await arg("Enter replacement text:")

// Replace the text within the selection
const newText = selectedText.replaceAll(searchText, replacementText) 

// Set the selected text to the modified text
await setSelectedText(newText) 
```

## Get and Display System Network Stats

```typescript
// Name: Network Stats Viewer
// Description: Displays network statistics using a widget 
// Author: johnlindquist

import "@johnlindquist/kit"
import si from "systeminformation"

// Create a widget to display the network stats
const networkWidget = await widget( 
  `
<div class="p-4"> 
  <h2 class="text-xl font-bold">Network Stats</h2>
  <div class="flex flex-col gap-2">
    <div>
      <span class="font-bold">Total Uploaded:</span> {{totalUpload}}
    </div> 
    <div>
      <span class="font-bold">Total Downloaded:</span> {{totalDownload}}
    </div> 
  </div> 
</div>
`,
  {
    width: 250, // Set a custom width for the widget
  }
)

// Update the network stats every second
setInterval(async () => { 
  // Get the current network stats
  const networkStats = await si.networkStats() 

  // Get the stats for the default network interface 
  const defaultInterface = networkStats.find(iface => iface.default) 

  // Update the widget state with the total upload and download data 
  networkWidget.setState({ 
    totalUpload: filesize(defaultInterface.tx_bytes), 
    totalDownload: filesize(defaultInterface.rx_bytes),
  }) 
}, 1000)
```

## Generate a Python Project with Virtual Environment

```typescript
// Name: Create Python Project
// Description: Generates a new Python project with a virtual environment
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the project name
const projectName = await arg("Enter project name:")

// Prompt for the Python version to use
const pythonVersion = await arg("Enter Python version (e.g., 3.9):") 

// Create the project directory
await mkdir(projectName) 

// Change to the project directory 
cd(projectName) 

// Create a virtual environment using `python3 -m venv` 
await exec(`python3 -m venv .venv`, { shell: true })

// Activate the virtual environment 
await exec(`source .venv/bin/activate`, { shell: true }) 

// Install required packages 
await $`pip install requests` 

// Create a "main.py" file with a sample script
await writeFile(
  "main.py",
  `
import requests 

response = requests.get("https://www.example.com")
print(response.status_code)
` 
)

// Display a notification
await notify(`Python project created!`, `Using Python ${pythonVersion} in virtual environment.`)

// Open the project directory in VS Code
await exec(`code .`)
```


## Resize and Compress Images in Bulk with Preview

```typescript
// Name: Bulk Image Resizer and Compressor
// Description: Resizes and compresses images in a directory with preview and options 
// Author: johnlindquist

import "@johnlindquist/kit" 
import sharp from "sharp"

// Prompt the user to select a directory
const directoryPath = await path({ 
  onlyDirs: true,
}) 

// Prompt for the new image width
const width = parseInt(await arg("Enter new width (px):")) 

// Prompt for the desired output quality (0-100)
const quality = parseInt(await arg("Enter desired quality (0-100):")) 

// Get all image files in the directory
const imageFiles = await globby([`${directoryPath}/*.{jpg,jpeg,png,gif,webp}`])

// Function to generate a preview of the resized and compressed image 
const generatePreview = async (imagePath: string) => {
  // Create a temporary file path for the preview image
  const previewImagePath = tmpPath(`preview-${path.basename(imagePath)}`)

  // Resize and compress the image using sharp 
  await sharp(imagePath)
    .resize({ width })
    .jpeg({ quality }) // Assuming JPEG output for preview, adjust as needed 
    .toFile(previewImagePath)

  // Return the temporary preview image path 
  return previewImagePath
}

// Display the preview for the first image in the directory
let previewImagePath = await generatePreview(imageFiles[0])
setPreview(md(`![Preview Image](${previewImagePath})`)) 

// Prompt the user to select which images to process
const selectedImagePaths = await select({
  placeholder: "Select images to resize and compress (use cmd/ctrl for multiple):",
  multiple: true,
  width: PROMPT.WIDTH.LG,
  // Use the image file paths as choices, providing a dynamic preview for each image
  choices: imageFiles.map(imagePath => ({
    name: path.basename(imagePath),
    value: imagePath,
    // Generate a preview when the choice is focused
    preview: async () => {
      previewImagePath = await generatePreview(imagePath)
      return md(`![Preview Image](${previewImagePath})`)
    },
  })), 
})

// Resize and compress the selected images 
for (const imagePath of selectedImagePaths) {
  await div(md(`# Processing ${path.basename(imagePath)}...`))

  await sharp(imagePath)
    .resize({ width })
    .jpeg({ quality }) // Assuming JPEG output, adjust as needed
    .toFile(imagePath) 
}

// Display a notification
await notify("Images resized and compressed!", `Processed ${selectedImagePaths.length} images.`) 
```

## Check for TypeScript Type Errors

```typescript
// Name: TypeScript Type Error Checker
// Description: Checks for type errors in a TypeScript project using the TypeScript compiler 
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the project directory
const projectPath = await path({
  onlyDirs: true, 
}) 

// Run the TypeScript compiler in 'noEmit' mode to check for type errors
let { stdout: typeErrors } = await exec(`npx tsc --noEmit --pretty`, {
  shell: true, 
  cwd: projectPath,
})

// If type errors are found, display them in the editor
if (typeErrors.trim().length > 0) {
  await editor(typeErrors, {
    language: "typescript", 
  }) 
} else { 
  // Display a message if no type errors are found 
  await div(md(`## No type errors found! ðŸŽ‰`))
}
```

## Create and Send an Outlook Email

```typescript
// Name: Send Outlook Email
// Description: Sends an email using the Microsoft Graph API 
// Author: johnlindquist

import "@johnlindquist/kit"

// Get your Microsoft Graph API token from here: 
// https://docs.microsoft.com/en-us/graph/auth-v2-user 
const MICROSOFT_GRAPH_TOKEN = await env("MICROSOFT_GRAPH_TOKEN")

// Prompt for the recipient's email address
const to = await arg("Enter recipient's email address:") 

// Prompt for the email subject
const subject = await arg("Enter email subject:") 

// Prompt for the email body 
const body = await textarea({
  placeholder: "Enter email body:",
})

// Send the email using the Microsoft Graph API
await post( 
  `https://graph.microsoft.com/v1.0/me/sendMail`, 
  {
    message: {
      subject,
      body: {
        contentType: "Text",
        content: body,
      }, 
      toRecipients: [
        {
          emailAddress: {
            address: to, 
          }, 
        },
      ],
    },
    saveToSentItems: "true", 
  }, 
  {
    headers: {
      Authorization: `Bearer ${MICROSOFT_GRAPH_TOKEN}`, 
    },
  }
) 

// Display a confirmation message
await div(md(`## Email sent successfully!`))
```

## Create a Custom Keyboard Shortcut to Open an Application

```typescript
// Name: Open App Shortcut
// Description: Creates a keyboard shortcut to open an application
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt the user to select an application 
const appPath = await path({
  // Filter for applications (macOS only) 
  filters: isMac
    ? [{ name: "Applications", extensions: ["app"] }] 
    : [], 
}) 

// Prompt for the shortcut key combination 
const shortcut = await hotkey({
  placeholder: "Press the desired shortcut key combination:",
})

// Register the shortcut to open the application
registerShortcut(shortcut.shortcut, async () => {
  await open(appPath)
})

// Display a notification 
await notify("Shortcut created!", `Press ${shortcut.shortcut} to open ${path.basename(appPath)}`)
```

## Download a File from Dropbox

```typescript 
// Name: Download from Dropbox
// Description: Downloads a file from Dropbox
// Author: johnlindquist

import "@johnlindquist/kit"
import { Dropbox } from "dropbox"

// Get your Dropbox API token from here: https://www.dropbox.com/developers/apps
const DROPBOX_ACCESS_TOKEN = await env("DROPBOX_ACCESS_TOKEN") 

// Create a new Dropbox client 
const dbx = new Dropbox({ accessToken: DROPBOX_ACCESS_TOKEN })

// Prompt for the path to the file in Dropbox
const dropboxFilePath = await arg("Enter file path in Dropbox:")

// Prompt for the local directory to download to 
const downloadDir = await path({ 
  onlyDirs: true,
}) 

// Download the file from Dropbox
const response = await dbx.filesDownload({ path: dropboxFilePath })

// Save the file to the selected directory 
await writeFile(path.join(downloadDir, response.result.name), response.result.fileBinary, "binary") 

// Display a notification
await notify("File downloaded from Dropbox!", `Saved to ${downloadDir}`) 
```

## Get System Network Stats and Display in a Widget

```typescript
// Name: Live Network Monitor Widget
// Description: Displays live network stats in a widget 
// Author: johnlindquist 

import "@johnlindquist/kit"
import si from "systeminformation"

// Create a widget to display the network stats
const networkWidget = await widget(
  `
  <div class="p-4">
    <h2 class="text-xl font-bold">Network Stats</h2> 
    <div class="flex flex-col gap-2">
      <div>
        <span class="font-bold">Download:</span> {{downloadSpeed}}/s
      </div> 
      <div>
        <span class="font-bold">Upload:</span> {{uploadSpeed}}/s
      </div> 
    </div> 
  </div>
  `,
  {
    width: 200, // Set a custom width for the widget 
  }
)

// Update network stats every second 
setInterval(async () => {
  // Get current network stats
  const networkStats = await si.networkStats()

  // Find the default network interface
  const defaultInterface = networkStats.find(iface => iface.default)

  // Update the widget state with the download and upload speeds, using filesize to format them
  networkWidget.setState({ 
    downloadSpeed: filesize(defaultInterface.rx_sec),
    uploadSpeed: filesize(defaultInterface.tx_sec), 
  })
}, 1000)
```

##  Create a Python Virtual Environment

```typescript
// Name: Create Python Virtual Environment 
// Description: Creates a new Python virtual environment
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt for the virtual environment directory name 
const envName = await arg("Enter virtual environment directory name:")

// Create the virtual environment using `python3 -m venv` 
await exec(`python3 -m venv ${envName}`, { shell: true })

// Display a confirmation message
await div(md(`## Python virtual environment created!`))

// Open the virtual environment directory in VS Code 
await exec(`code ${envName}`)
```





## Add Task to Todoist

```typescript
// Name: Add Todoist Task 
// Description: Adds a new task to Todoist
// Author: johnlindquist

import "@johnlindquist/kit"

// Get your Todoist API token from: https://todoist.com/prefs/integrations
const TODOIST_API_TOKEN = await env("TODOIST_API_TOKEN")

// Prompt for the task content
const taskContent = await arg("Enter task content:")

// Prompt for the project name
const project = await arg("Enter project (optional):")

// Prompt for the due date (optional)
const dueDate = await arg("Enter due date (optional, YYYY-MM-DD):")

// Construct the request body for the Todoist API
const requestBody = {
  content: taskContent,
  project_id: project ? (await get(`https://api.todoist.com/rest/v2/projects?search=${project}`, {
    headers: { Authorization: `Bearer ${TODOIST_API_TOKEN}` }
  })).data[0].id : undefined,
  due_date: dueDate || undefined,
}

// Add the task to Todoist using the API
await post(
  "https://api.todoist.com/rest/v2/tasks", 
  requestBody,
  {
    headers: {
      Authorization: `Bearer ${TODOIST_API_TOKEN}`,
    },
  }
)

// Display a confirmation message 
await div(md(`## Task added to Todoist!`))
```

## Check for Updated npm Packages and Display Details

```typescript
// Name: npm Package Update Checker with Details
// Description: Checks for outdated npm packages and shows details of available updates
// Author: johnlindquist

import "@johnlindquist/kit"

// Run npm outdated with the `--json` flag to get detailed information about outdated packages 
let { stdout: outdatedPackagesJson } = await exec(`npm outdated --json`, { shell: true, cwd: "." })

// Parse the JSON output 
const outdatedPackages = JSON.parse(outdatedPackagesJson)

// Create choices with detailed information about each outdated package
let choices = Object.entries(outdatedPackages).map(([packageName, packageInfo]) => {
  const { current, wanted, latest } = packageInfo 

  // Create a preview showing the current, wanted, and latest versions
  const preview = md(`## Update Available for ${packageName}

  * Current: ${current}
  * Wanted: ${wanted}
  * Latest: ${latest}
  `) 

  return {
    name: `${packageName}: ${current} -> ${wanted} (latest: ${latest})`,
    value: packageName, 
    preview,
  } 
})

if (choices.length > 0) {
  // Prompt the user to select a package to update 
  let selectedPackage = await arg(
    {
      placeholder: `Found ${choices.length} outdated packages. Select one to update:`, 
      // Set a custom height for the prompt
      height: PROMPT.HEIGHT.LG, 
    },
    choices 
  )

  // Update the selected package to the latest version 
  await div(md(`# Updating ${selectedPackage}...`))
  await $`npm install ${selectedPackage}@latest` 
  await notify("Package Updated", `${selectedPackage} has been updated to the latest version.`) 
} else {
  // Display a message if all packages are up to date
  await div(md(`## All npm packages are up to date! ðŸŽ‰`)) 
}
```

## Convert Speech to Text and Send to Email

```typescript
// Name: Transcribe and Email Speech
// Description: Records speech, transcribes it, and sends the transcript via email 
// Author: johnlindquist

import "@johnlindquist/kit"
import OpenAI from "openai" 
import nodemailer from "nodemailer" 

// Get your OpenAI API key from here: https://platform.openai.com/account/api-keys
const OPENAI_API_KEY = await env("OPENAI_API_KEY") 

// Get your email credentials from environment variables
// You can create an app password here: https://support.google.com/accounts/answer/185833?hl=en
const emailUser = await env("EMAIL_USER")
const emailPassword = await env("EMAIL_PASSWORD")

// Create a new OpenAI instance 
const openai = new OpenAI({
  apiKey: OPENAI_API_KEY,
})

// Create a Nodemailer transporter
const transporter = nodemailer.createTransport({ 
  service: "gmail", 
  auth: {
    user: emailUser,
    pass: emailPassword,
  }, 
}) 

// Prompt the user to start recording 
await div(md(`# Click "Start Recording" to begin speaking. `), "flex flex-col items-center justify-center text-center gap-2")
const audioFilePath = await mic.start()

// Stop recording when the user presses the Escape key 
onKeydown(async (event) => { 
  if (event.key === "Escape") {
    await mic.stop() 
  }
}) 

// Read the recorded audio file 
const audioBuffer = await readFile(audioFilePath)

// Convert speech to text using the OpenAI API
const transcriptionResponse = await openai.audio.transcriptions.create({
  file: await toFile(audioBuffer, "audio.webm"), 
  model: "whisper-1",
}) 

// Extract the transcribed text 
const transcribedText = transcriptionResponse.text.trim() 

// Prompt for the recipient's email address 
const to = await arg("Enter recipient email address:") 

// Send the transcribed text via email
await transporter.sendMail({
  from: emailUser,
  to,
  subject: "Speech Transcription", 
  text: transcribedText, 
})

// Display a confirmation message
await div(md(`## Speech transcribed and sent to ${to}!`))
```

##  Compress a Directory to a Password-Protected ZIP Archive

```typescript
// Name: Password-Protected ZIP Creator
// Description: Compresses a directory into a password-protected ZIP archive 
// Author: johnlindquist 

import "@johnlindquist/kit" 
import archiver from "archiver"

// Prompt for the directory to compress
const directoryPath = await path({
  onlyDirs: true,
})

// Prompt for the output file path for the ZIP archive
const outputFilePath = await path({
  suggestion: `${path.basename(directoryPath)}.zip`, 
  startPath: home("Downloads"),
}) 

// Prompt for the password to protect the ZIP archive
const password = await arg({
  placeholder: "Enter password for ZIP archive:",
  secret: true, 
}) 

// Create a write stream for the output file 
const output = createWriteStream(outputFilePath) 

// Create a new archiver instance 
const archive = archiver("zip", {
  zlib: { level: 9 }, 
})

// Listen for errors during archiving
archive.on("error", (error) => {
  throw error 
})

// Display a notification when archiving is complete 
output.on("close", () => {
  notify("Directory compressed!", `Saved to ${outputFilePath}`)
})

// Pipe the archive data to the output stream
archive.pipe(output)

// Add the selected directory to the archive
archive.directory(directoryPath, false) 

// Set the password for the archive 
archive.setPassword(password)

// Finalize the archive 
await archive.finalize()

// Reveal the archive file in Finder
await revealFile(outputFilePath)
```

##  Get Trending News Headlines from a Specific Source

```typescript
// Name: News Headline Fetcher 
// Description: Displays trending news headlines from a selected news source
// Author: johnlindquist

import "@johnlindquist/kit" 
import { JSDOM } from "jsdom"

// Prompt for the news source URL 
const newsSourceUrl = await arg("Enter news source URL:")

// Fetch the HTML content from the news source
const response = await get(newsSourceUrl) 

// Parse the HTML content using JSDOM
const dom = new JSDOM(response.data) 

// Extract headlines and links from the parsed HTML (adjust selectors as needed)
const headlines = Array.from(dom.window.document.querySelectorAll(".headline a")).map((a) => ({
  title: a.textContent.trim(),
  url: a.href,
}))

// Prompt the user to select a headline
const selectedHeadline = await arg({
  placeholder: "Select a headline to open:", 
  enter: "Open in Browser",
  // Set a custom height for the prompt 
  height: PROMPT.HEIGHT.LG, 
}, headlines)

// Open the selected headline in the browser 
await browse(selectedHeadline) 
```

##  Create and Share a Public GitHub Gist from a File

```typescript
// Name: Share File as Gist 
// Description: Creates a public Gist from a selected file
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user to select a file 
const filePath = await path() 

// Read the contents of the file 
const fileContent = await readFile(filePath, "utf-8")

// Prompt for a description for the Gist
const description = await arg("Enter Gist description:")

// Create a public Gist using the GitHub API 
const { html_url: gistUrl } = await createGist(fileContent, { 
  description,
  fileName: path.basename(filePath), // Use the original filename
  isPublic: true, 
}) 

// Display the Gist URL in a div
await div(md(`## Gist created at: ${gistUrl}`))

// Copy the Gist URL to the clipboard
await copy(gistUrl)

// Open the Gist in the browser 
await browse(gistUrl)
```

## Check for npm Package Vulnerabilities with Details

```typescript
// Name: Detailed npm Audit
// Description: Checks for vulnerabilities in npm packages and displays detailed information 
// Author: johnlindquist

import "@johnlindquist/kit" 

// Run `npm audit` to check for vulnerabilities in the current project
let { stdout: auditResult } = await exec(`npm audit --json`, { shell: true, cwd: "." })

// Parse the JSON output 
const vulnerabilities = JSON.parse(auditResult).vulnerabilities 

// Create choices for each vulnerability, including detailed information in the preview
let choices = Object.entries(vulnerabilities).map(([vulnerabilityId, vulnerabilityInfo]) => { 
  // Extract relevant information from the vulnerability object 
  const { name, severity, via, effects, range, nodes, fixAvailable } = vulnerabilityInfo

  // Create a detailed preview of the vulnerability
  const preview = md(`## Vulnerability: ${name}

* Severity: ${severity}
* Path: ${via.map(v => v.name).join(" > ")}
* Affected Packages: ${effects.join(", ")} 
* Range: ${range}
* Nodes: ${nodes.join(", ")}
* Fix Available: ${fixAvailable ? "Yes" : "No"} 
`) 

  return {
    name: vulnerabilityId,
    value: vulnerabilityId, 
    preview, 
  } 
})

// Prompt the user to select a vulnerability to view details
let selectedVulnerability = await arg(
  {
    placeholder: "Select a vulnerability to view details:",
    // Set a custom height for the prompt
    height: PROMPT.HEIGHT.LG, 
  },
  choices 
)

// Display the detailed information for the selected vulnerability in a div
let selectedVulnerabilityInfo = vulnerabilities[selectedVulnerability] 
let { name, severity, via, effects, range, nodes, fixAvailable } = selectedVulnerabilityInfo

await div(md(`## Vulnerability Details: 

* ID: ${selectedVulnerability}
* Name: ${name}
* Severity: ${severity} 
* Path: ${via.map(v => v.name).join(" > ")}
* Affected Packages: ${effects.join(", ")}
* Range: ${range}
* Nodes: ${nodes.join(", ")}
* Fix Available: ${fixAvailable ? "Yes" : "No"} 
`))
```

##  Convert Audio File to Different Format with Custom Bitrate

```typescript 
// Name: Audio Converter with Bitrate Options
// Description: Converts an audio file to a different format with custom bitrate using ffmpeg 
// Author: johnlindquist 

import "@johnlindquist/kit"

// Prompt the user to select an audio file
const audioFilePath = await path({ 
  filters: [{ name: "Audio Files", extensions: ["mp3", "wav", "m4a", "ogg", "flac"] }],
})

// Prompt for the desired output format 
const outputFormat = await arg("Enter output audio format (e.g., mp3, wav, flac):")

// Prompt for the desired bitrate (in kbps)
const bitrate = await arg("Enter desired bitrate (kbps):")

// Extract the directory and file name from the input audio file path 
const { dir, name } = path.parse(audioFilePath)

// Create the output file path 
const outputFilePath = path.join(dir, `${name}.${outputFormat}`) 

// Convert the audio file using ffmpeg with the specified bitrate
await exec(`ffmpeg -i "${audioFilePath}" -ab ${bitrate}k "${outputFilePath}"`, { shell: true })

// Display a notification
await notify("Audio file converted!", `Saved to ${outputFilePath}`) 

// Reveal the converted audio file in Finder
await revealFile(outputFilePath) 
```


## Create and Send a Scheduled Tweet with Image

```typescript
// Name: Schedule Tweet with Image
// Description: Schedules a tweet with an image to be sent at a later time 
// Author: johnlindquist

import "@johnlindquist/kit" 
import TwitterApi from "twitter-api-v2" 
import schedule from "node-schedule"

// Get your Twitter API credentials
const TWITTER_API_KEY = await env("TWITTER_API_KEY")
const TWITTER_API_SECRET = await env("TWITTER_API_SECRET") 
const TWITTER_ACCESS_TOKEN = await env("TWITTER_ACCESS_TOKEN") 
const TWITTER_ACCESS_SECRET = await env("TWITTER_ACCESS_SECRET") 

// Create a new instance of the Twitter API client
const twitterClient = new TwitterApi({
  appKey: TWITTER_API_KEY, 
  appSecret: TWITTER_API_SECRET, 
  accessToken: TWITTER_ACCESS_TOKEN, 
  accessSecret: TWITTER_ACCESS_SECRET, 
})

// Prompt for the tweet content
const tweetContent = await arg("Enter your tweet:") 

// Prompt the user to select an image to attach 
const imagePath = await path({
  filters: [{ name: "Images", extensions: ["jpg", "jpeg", "png", "gif"] }],
})

// Prompt for the scheduled time (in cron format) 
const scheduleTime = await arg({
  placeholder: "Enter schedule time (cron format):",
  hint: "Example: 0 9 * * * (every day at 9 AM)", 
}) 

// Authenticate with the Twitter API
const client = await twitterClient.readWrite 

// Upload the image to Twitter
const mediaId = await client.v1.uploadMedia(imagePath); 

// Schedule the tweet to be sent at the specified time with the image attached
schedule.scheduleJob(scheduleTime, async () => {
  // Send the tweet with the media ID
  await client.v2.tweet(tweetContent, { media: { media_ids: [mediaId] } }) 

  // Display a notification when the tweet is sent 
  await notify("Scheduled tweet sent!")
})

// Display a confirmation message
await div(md(`## Tweet with image scheduled to be sent at: ${scheduleTime}`))
```

## Convert a Web Page to Markdown with Options

```typescript
// Name: Customizable Web Page to Markdown Converter
// Description: Converts a web page to Markdown with options for heading levels and code block style 
// Author: johnlindquist 

import "@johnlindquist/kit"
import TurndownService from "turndown"

// Prompt for the website URL
const url = await arg("Enter website URL:")

// Prompt for the desired heading level (h1, h2, h3, etc.)
const headingLevel = await arg("Enter desired heading level (h1, h2, h3, etc.):") 

// Prompt for the desired code block style (indented or fenced)
const codeBlockStyle = await arg("Select code block style:", ["indented", "fenced"])

// Fetch the HTML content of the webpage
const response = await get(url)

// Create a new TurndownService instance with custom options
const turndownService = new TurndownService({
  headingStyle: headingLevel as "h1" | "h2" | "h3" | "h4" | "h5" | "h6", // Convert headings to the specified level 
  codeBlockStyle: codeBlockStyle, // Set the code block style 
})

// Convert the HTML content to Markdown using Turndown
const markdown = turndownService.turndown(response.data) 

// Display the Markdown in the editor 
await editor(markdown, {
  language: "markdown", 
})
```

## Get System Information and Display in a Customizable Widget

```typescript
// Name: Customizable System Info Widget
// Description: Displays system information in a customizable widget 
// Author: johnlindquist

import "@johnlindquist/kit"
import si from "systeminformation"

// Prompt for information to display in the widget, allowing multiple selections
const infoToDisplay = await select(
  "Select information to display:",
  [
    "CPU", 
    "Memory", 
    "Battery",
    "Network", 
    "System",
    "Time",
  ],
  {
    // Allow multiple selections
    multiple: true, 
  } 
)

// Create a template for the widget's HTML content, including placeholders for dynamic data
let widgetTemplate = `
<div class="p-4"> 
  <h2 class="text-xl font-bold">System Information</h2> 
  <div class="flex flex-col gap-2">
  {{#if showCPU}}
    <div>
      <span class="font-bold">CPU:</span> {{cpuModel}} ({{cpuCores}} cores)
    </div> 
  {{/if}}
  {{#if showMemory}} 
    <div>
      <span class="font-bold">Memory:</span> {{memoryTotal}}
    </div>
  {{/if}} 
  {{#if showBattery}}
    <div> 
      <span class="font-bold">Battery:</span> {{batteryPercent}}% ({{batteryStatus}}) 
    </div>
  {{/if}}
  {{#if showNetwork}} 
    <div>
      <span class="font-bold">Network:</span> {{networkType}} - {{ipAddress}}
    </div>
  {{/if}}
  {{#if showSystem}} 
    <div>
      <span class="font-bold">System:</span> {{systemModel}} - {{osName}} {{osVersion}}
    </div>
  {{/if}} 
  {{#if showTime}}
    <div> 
      <span class="font-bold">Time:</span> {{currentTime}}
    </div>
  {{/if}}
  </div> 
</div>
` 

// Create an object to store the widget state, including flags for displaying selected information
let widgetState = {
  showCPU: infoToDisplay.includes("CPU"),
  showMemory: infoToDisplay.includes("Memory"), 
  showBattery: infoToDisplay.includes("Battery"),
  showNetwork: infoToDisplay.includes("Network"), 
  showSystem: infoToDisplay.includes("System"), 
  showTime: infoToDisplay.includes("Time"),
  // Initial values for data points, will be updated later
  cpuModel: "",
  cpuCores: 0,
  memoryTotal: "",
  batteryPercent: 0,
  batteryStatus: "", 
  networkType: "",
  ipAddress: "", 
  systemModel: "", 
  osName: "",
  osVersion: "",
  currentTime: "",
}

// Create the widget with the template and initial state
const systemInfoWidget = await widget(
  widgetTemplate, 
  {
    width: 300,
  } 
)

// Update the widget with system information
const updateWidget = async () => {
  // Fetch the required system information
  const osInfo = await si.osInfo() 
  const cpuInfo = await si.cpu()
  const memInfo = await si.mem() 
  const batteryInfo = await si.battery() 
  const networkInfo = (await si.networkInterfaces()).find(iface => iface.default) 
  const time = new Date().toLocaleTimeString()

  // Update the widget state with the fetched data, formatting values as needed
  systemInfoWidget.setState({
    ...widgetState, 
    cpuModel: cpuInfo.manufacturer + " " + cpuInfo.brand, 
    cpuCores: cpuInfo.cores,
    memoryTotal: filesize(memInfo.total), 
    batteryPercent: batteryInfo.percent,
    batteryStatus: batteryInfo.isCharging ? "Charging" : "Discharging", 
    networkType: networkInfo.type,
    ipAddress: networkInfo.ip4,
    systemModel: (await si.system()).model,
    osName: osInfo.distro,
    osVersion: osInfo.release,
    currentTime: time, 
  }) 
} 

// Update the widget initially and then every second
await updateWidget() 
setInterval(updateWidget, 1000)

// Keep the script running to keep the widget active 
hide()
```

## Remove Blank Lines from Text

```typescript
// Name: Remove Blank Lines
// Description: Removes blank lines from selected text 
// Author: johnlindquist 

import "@johnlindquist/kit"

// Get the selected text 
const text = await getSelectedText() 

// Remove blank lines from the text using a regular expression
const newText = text.replace(/^\s*$/gm, "")

// Set the selected text to the modified text 
await setSelectedText(newText)

// Display a notification 
await notify("Blank lines removed!")
```

## Create a New Python Script with Boilerplate Code

```python
# Name: New Python Script from Template 
# Description: Creates a new Python script from a template
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the script name 
const scriptName = await arg({
  placeholder: "Enter Python script name (e.g., my_script.py):",
  // Validate the input to ensure it has a '.py' extension
  validate: (input) => input.endsWith(".py"),
})

// Prompt the user to select a Python template file
const templateFilePath = await path({
  // Start in the user's "templates" directory within their kenv
  startPath: kenvPath("templates"),
  // Filter for Python files 
  filters: [{ name: "Python Templates", extensions: ["py"] }], 
}) 

// Read the contents of the template file
const templateContent = await readFile(templateFilePath, "utf-8")

// Create the new Python script file with the template content
await writeFile(scriptName, templateContent) 

// Display a notification 
await notify("Python script created!", `File created: ${scriptName}`)

// Open the newly created script in VS Code
await exec(`code ${scriptName}`) 
```

##  Convert a Video to a Different Format with Custom Options

```typescript
// Name: Video Converter with Options 
// Description: Converts a video to a different format with customizable options using ffmpeg 
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt for the video file path 
const videoFilePath = await path({ 
  filters: [{ name: "Videos", extensions: ["mp4", "mov", "avi", "mkv", "webm"] }], 
})

// Prompt for the desired output format 
const outputFormat = await arg("Enter desired output format (e.g., mp4, avi, webm):") 

// Prompt for the desired video codec (e.g., libx264, libvpx-vp9)
const videoCodec = await arg({
  placeholder: "Enter video codec (optional):", 
  // Provide some common video codecs as suggestions 
  suggest: (input) => {
    return ["libx264", "libvpx-vp9", "hevc"].filter(codec => codec.startsWith(input))
  },
}) 

// Prompt for the desired audio codec (e.g., aac, libmp3lame)
const audioCodec = await arg({
  placeholder: "Enter audio codec (optional):", 
  // Provide some common audio codecs as suggestions
  suggest: (input) => { 
    return ["aac", "libmp3lame", "opus"].filter(codec => codec.startsWith(input)) 
  }, 
})

// Extract the directory and file name from the video file path
const { dir, name } = path.parse(videoFilePath) 

// Construct the output file path 
const outputFilePath = path.join(dir, `${name}-converted.${outputFormat}`) 

// Build the ffmpeg command with the provided options 
let command = `ffmpeg -i '${videoFilePath}'` 
if (videoCodec) { 
  command += ` -c:v ${videoCodec}` 
} 
if (audioCodec) { 
  command += ` -c:a ${audioCodec}` 
} 
command += ` '${outputFilePath}'` 

// Execute the ffmpeg command
await exec(command, { shell: true })

// Display a notification
await notify("Video converted!", `Saved to ${outputFilePath}`)

// Reveal the converted video in Finder
await revealFile(outputFilePath)
```

##  Create a GitHub Release

```typescript
// Name: Create GitHub Release 
// Description: Creates a new release on GitHub for a repository 
// Author: johnlindquist

import "@johnlindquist/kit"
import { Octokit } from "@octokit/rest"

// Get GitHub authentication token from environment variables 
// You can get a token here: https://github.com/settings/tokens 
const githubToken = await env("GITHUB_TOKEN")

// Prompt for the repository name (owner/repo)
const repo = await arg("Enter repository name (owner/repo):")

// Split the input into owner and repository name
const [owner, repoName] = repo.split("/")

// Create a new Octokit instance
const octokit = new Octokit({
  auth: githubToken, 
})

// Prompt for the release tag name
const tagName = await arg("Enter tag name for the release:") 

// Prompt for the release name
const releaseName = await arg("Enter release name:")

// Prompt for the release body (Markdown supported)
const body = await editor({
  placeholder: "Enter release body (Markdown supported):", 
  language: "markdown",
})

// Create a new release on GitHub
const { data: newRelease } = await octokit.repos.createRelease({
  owner,
  repo: repoName, 
  tag_name: tagName, 
  name: releaseName, 
  body,
  // Make the release a draft (not published immediately) 
  draft: true,
}) 

// Display a confirmation message with a link to the draft release
await div(md(`## Draft release created: [${newRelease.html_url}](${newRelease.html_url})`))

// Open the draft release in the browser
await browse(newRelease.html_url) 
```

##  Check for Unused CSS with a Custom Configuration File

```typescript
// Name: Custom Unused CSS Finder
// Description: Finds unused CSS classes using PurgeCSS with a custom configuration file 
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user to select the PurgeCSS configuration file
const configFilePath = await path({
  startPath: ".", 
  // Allow selecting either JavaScript or JSON configuration files
  filters: [{ name: "Configuration Files", extensions: ["js", "json"] }],
  // Provide a hint 
  hint: "Select your PurgeCSS configuration file (e.g., purgecss.config.js).",
})

// Run PurgeCSS with the specified configuration file
// Assumes PurgeCSS is installed: https://purgecss.com/
await exec(`npx purgecss --config '${configFilePath}'`, { shell: true }) 
```

##  Generate a Random Joke and Send it to a Discord Channel

```typescript 
// Name: Discord Joke Bot 
// Description: Sends a random joke to a Discord channel
// Author: johnlindquist

import "@johnlindquist/kit"
import { Client, IntentsBitField } from "discord.js"

// Get your Discord Bot Token from here: https://discord.com/developers/applications
const DISCORD_BOT_TOKEN = await env("DISCORD_BOT_TOKEN")

// Prompt for the Discord channel ID
const channelId = await arg("Enter Discord channel ID:") 

// Create a new Discord client instance
const client = new Client({ intents: [IntentsBitField.Flags.Guilds] })

// Log in to Discord using the bot token 
client.login(DISCORD_BOT_TOKEN) 

// Fetch a random joke from the JokeAPI 
const jokeResponse = await get("https://v2.jokeapi.dev/joke/Any?blacklistFlags=nsfw,religious,political,racist,sexist,explicit&type=single") 
const { joke } = jokeResponse.data

// Send the joke to the channel 
client.on("ready", async () => { 
  const channel = client.channels.cache.get(channelId)

  if (channel?.isTextBased()) { 
    await channel.send(joke)
    console.log(`Joke sent to channel ${channelId}`)
  } else {
    console.error("Channel not found or not a text channel.")
  } 

  client.destroy() 
}) 
```



## Resize Images and Convert to WebP

```typescript
// Name: Resize and Convert to WebP
// Description: Resizes and converts images to WebP format in a directory
// Author: johnlindquist

import "@johnlindquist/kit"
import sharp from "sharp"

// Prompt for the directory containing images
const directoryPath = await path({
  onlyDirs: true, 
})

// Prompt for the new image width 
const width = parseInt(await arg("Enter desired width (px):"))

// Get all image files in the selected directory (excluding WebP files)
const imageFiles = await globby([`${directoryPath}/*.{jpg,jpeg,png,gif}`, `!${directoryPath}/*.webp`]) 

// Resize and convert images to WebP using sharp 
for (const imagePath of imageFiles) {
  await div(md(`# Processing ${path.basename(imagePath)}...`)) 

  await sharp(imagePath)
    .resize({ width })
    .webp({ quality: 80 }) // Set the WebP quality 
    .toFile(imagePath.replace(/\.(jpg|jpeg|png|gif)$/, ".webp")) 
}

// Display a notification 
await notify("Images resized and converted to WebP!", `in ${directoryPath}`) 
```

## Upload a File to S3 with Progress Bar

```typescript
// Name: S3 Uploader with Progress
// Description: Uploads a file to AWS S3 with a progress bar 
// Author: johnlindquist 

import "@johnlindquist/kit"
import AWS from "aws-sdk" 

// Get AWS credentials from environment variables 
// You can configure AWS credentials here: https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/setting-credentials-node.html
const AWS_ACCESS_KEY_ID = await env("AWS_ACCESS_KEY_ID")
const AWS_SECRET_ACCESS_KEY = await env("AWS_SECRET_ACCESS_KEY")

// Prompt for the S3 bucket name
const bucketName = await arg("Enter S3 bucket name:") 

// Prompt for the file to upload 
const filePath = await path()

// Create a new S3 client instance
const s3 = new AWS.S3({
  accessKeyId: AWS_ACCESS_KEY_ID, 
  secretAccessKey: AWS_SECRET_ACCESS_KEY,
}) 

// Create a progress bar widget 
const progressWidget = await widget(
  `<div class="p-4">
    <h2 class="text-xl font-bold">Uploading to S3</h2>
    <div class="w-full bg-gray-200 rounded-full h-2.5">
      <div class="bg-blue-500 h-2.5 rounded-full" style="width: {{progress}}%"></div> 
    </div>
    <p class="text-sm mt-2">{{progress}}%</p>
  </div>
`,
  {
    width: 300, 
  }
)

// Configure the upload parameters 
const uploadParams = { 
  Bucket: bucketName,
  Key: path.basename(filePath), // Use the original file name as the key
  Body: fs.createReadStream(filePath), 
  ACL: "public-read", // Make the file publicly accessible 
}

// Create an upload manager to track progress 
const uploadManager = s3.upload(uploadParams, (err, data) => {
  if (err) {
    // Handle any errors during the upload 
    console.error("Error uploading file:", err)
    // Close the progress widget 
    progressWidget.close() 
  } else {
    // Display a success message in the widget 
    progressWidget.setState({ html: `<div class="p-4 text-green-500">File uploaded successfully!</div>` }) 
    // Close the widget after a short delay
    setTimeout(() => progressWidget.close(), 2000) 
  } 
})

// Update the progress bar in the widget
uploadManager.on("httpUploadProgress", (progress) => {
  // Calculate the upload progress percentage 
  const progressPercent = Math.round((progress.loaded / progress.total) * 100) 
  // Update the widget's state with the progress percentage 
  progressWidget.setState({ progress: progressPercent })
}) 
```

## Check for Spelling Errors in Text

```typescript
// Name: Spellcheck Text
// Description: Checks for spelling errors in text using the 'spellchecker' library 
// Author: johnlindquist 

import "@johnlindquist/kit" 
import SpellChecker from "spellchecker"

// Prompt for the text to check 
const text = await editor({
  placeholder: "Enter text to check for spelling:",
  language: "text", 
})

// Check for misspellings using spellchecker 
const misspellings = SpellChecker.checkSpelling(text) 

// Create a list of misspellings with suggestions
const misspellingList = misspellings.map(misspelling => `- "${misspelling.word}" (Suggestions: ${SpellChecker.getCorrectionsForMisspelling(misspelling.word).join(", ")})`).join("\n")

if (misspellings.length > 0) {
  // Display the misspelling list in a div
  await div(md(`## Misspellings:\n\n${misspellingList}`))
} else { 
  // Display a message if no misspellings are found
  await div(md(`## No misspellings found! ðŸŽ‰`)) 
} 
```

##  Convert Text to Speech Using Different Voices and Compare

```typescript
// Name: Text to Speech Voice Comparison 
// Description: Converts text to speech using multiple voices from the OpenAI API and allows comparison
// Author: johnlindquist 

import "@johnlindquist/kit" 
import OpenAI from "openai"

// Get your OpenAI API key from here: https://platform.openai.com/account/api-keys 
const OPENAI_API_KEY = await env("OPENAI_API_KEY")

// Create a new OpenAI instance 
const openai = new OpenAI({ 
  apiKey: OPENAI_API_KEY,
})

// Prompt for the text to convert 
const text = await arg("Enter text to convert to speech:")

// Display a list of available voices and allow the user to select two for comparison
const voice1 = await arg("Select the first voice:", [
  "alloy",
  "echo",
  "fable", 
  "onyx", 
  "nova",
  "shimmer", 
]) 
const voice2 = await arg("Select the second voice:", [
  "alloy",
  "echo",
  "fable", 
  "onyx",
  "nova", 
  "shimmer",
]) 

// Generate speech audio for the first voice
const response1 = await openai.audio.speech.create({
  model: "tts-1", 
  voice: voice1, 
  input: text,
})

// Generate speech audio for the second voice 
const response2 = await openai.audio.speech.create({ 
  model: "tts-1",
  voice: voice2, 
  input: text, 
}) 

// Create temporary file paths for the audio files 
const audioFilePath1 = tmpPath(`speech1.mp3`)
const audioFilePath2 = tmpPath(`speech2.mp3`) 

// Save the audio data to the temporary files
await writeFile(audioFilePath1, Buffer.from(await response1.arrayBuffer())) 
await writeFile(audioFilePath2, Buffer.from(await response2.arrayBuffer())) 

// Define a function to play an audio file 
const playAudio = async (filePath: string) => {
  await div(md(`# Playing audio for voice: ${path.parse(filePath).name}`), "flex flex-col gap-2 items-center justify-center text-center")
  await playAudioFile(filePath)
} 

// Play the first audio file 
await playAudio(audioFilePath1) 

// Play the second audio file after the first one finishes 
await playAudio(audioFilePath2)
```

## Create a Shortcut to Toggle Wi-Fi On/Off (macOS only)

```typescript
// Name: Toggle Wi-Fi
// Description: Creates a shortcut to toggle Wi-Fi on or off (macOS only)
// Author: johnlindquist

import "@johnlindquist/kit" 

// Check if running on macOS 
if (isMac) {
  // Prompt for the desired shortcut key combination
  const shortcut = await hotkey({
    placeholder: "Press the desired shortcut key combination:",
  })

  // Register the shortcut to toggle Wi-Fi
  registerShortcut(shortcut.shortcut, async () => {
    // Use applescript to toggle the Wi-Fi state
    await applescript(`
tell application "System Events"
  tell current location
    set airportStatus to get Wi-Fi power
    if airportStatus then
      set Wi-Fi power off
    else
      set Wi-Fi power on
    end if 
  end tell 
end tell
`)
  }) 

  // Display a notification 
  await notify("Shortcut created!", `Press ${shortcut.shortcut} to toggle Wi-Fi.`)
} else {
  // Display a message if not running on macOS 
  await div(md(`## This script is only supported on macOS.`))
} 
```

##  Create and Run a Docker Container

```typescript
// Name: Run Docker Container
// Description: Creates and runs a Docker container from an image
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the Docker image name
const imageName = await arg("Enter Docker image name (e.g., nginx:latest):")

// Prompt for the container name
const containerName = await arg("Enter a name for the container:")

// Prompt for any desired port mappings (e.g., 8080:80)
const portMappings = await arg("Enter port mappings (optional, e.g., 8080:80):")
  .split(",") // Split by comma
  .map(mapping => mapping.trim()) // Trim whitespace from each mapping 
  .filter(mapping => mapping.length > 0) // Remove empty mappings
  .map(mapping => `-p ${mapping}`) // Add "-p" prefix to each mapping for Docker command

// Construct the Docker run command 
let dockerCommand = `docker run -d --name ${containerName} ${portMappings.join(" ")} ${imageName}` 

// Run the Docker command to create and start the container
await exec(dockerCommand, { shell: true })

// Display a confirmation message 
await div(md(`## Docker container "${containerName}" created and running!`))
```

## Convert a Web Page to PDF with a Custom Footer

```typescript
// Name: Web to PDF with Footer
// Description: Converts a web page to a PDF with a custom footer using Puppeteer
// Author: johnlindquist

import "@johnlindquist/kit" 
import puppeteer from "puppeteer"

// Prompt for the website URL
const url = await arg("Enter website URL:")

// Prompt for the output file path
const outputFilePath = await path({
  startPath: home("Downloads"), 
  suggestion: `${url.replace(/[^a-zA-Z0-9]/g, "_").slice(0, 20)}.pdf`, 
})

// Prompt for the footer text 
const footerText = await arg("Enter footer text:")

// Launch a headless browser instance using Puppeteer
const browser = await puppeteer.launch({ headless: "new" }) 

try {
  // Create a new page 
  const page = await browser.newPage()

  // Navigate to the provided URL 
  await page.goto(url, { waitUntil: "networkidle0" }) 

  // Generate the PDF with a custom footer
  await page.pdf({
    path: outputFilePath, 
    // Define the footer template
    displayHeaderFooter: true,
    footerTemplate: `<div style="font-size: 8px; text-align: center; padding: 1cm;">Page <span class="pageNumber"></span> of <span class="totalPages"></span> - ${footerText}</div>`, 
    // Set margins to 1cm 
    margin: { top: "1cm", right: "1cm", bottom: "1cm", left: "1cm" },
  })

  // Display a notification 
  await notify("PDF generated with footer!", `Saved to ${outputFilePath}`)

  // Reveal the PDF file in Finder 
  await revealFile(outputFilePath)

} finally {
  // Close the browser instance 
  await browser.close()
}
```

## Generate a Random Joke and Send it to a Telegram Chat

```typescript 
// Name: Telegram Joke Bot
// Description: Sends a random joke to a Telegram chat
// Author: johnlindquist

import "@johnlindquist/kit"
import { Telegraf } from "telegraf" 

// Get your Telegram Bot Token from BotFather: https://t.me/BotFather
const TELEGRAM_BOT_TOKEN = await env("TELEGRAM_BOT_TOKEN")

// Prompt for the Telegram chat ID (can be a group or channel) 
const chatId = await arg("Enter Telegram Chat ID:") 

// Create a new Telegraf instance 
const bot = new Telegraf(TELEGRAM_BOT_TOKEN)

// Fetch a random joke from the JokeAPI 
const jokeResponse = await get("https://v2.jokeapi.dev/joke/Any?blacklistFlags=nsfw,religious,political,racist,sexist,explicit&type=single")
const { joke } = jokeResponse.data

// Send the joke to the specified Telegram chat 
await bot.telegram.sendMessage(chatId, joke)

// Display a confirmation message
await div(md(`## Joke sent to Telegram chat!`))
```



## Create a Screen Recording of a Specific Window

```typescript
// Name: Window Recorder
// Description: Records a specific window on the screen
// Author: johnlindquist 

import "@johnlindquist/kit"

// Prompt the user to select a window to record
let app = await getActiveAppInfo() 
let windows = await getWindows() 
let windowToRecord = await arg(
  {
    placeholder: `Select Window to record:`,
    // Display currently focused app first 
    focused: app.name,
  },
  windows.map(w => ({ name: w.title, value: w, description: w.process })) 
)

// Start recording the selected window, capturing the file path of the recording 
let { process, title } = windowToRecord 
let filePath = await screenRecording.start({ 
  appName: process, 
  windowName: title,
})

// Prompt the user to stop recording 
await div(
  md(`
## Recording...

Press <kbd>Escape</kbd> to stop recording.
`), 
  "flex flex-col items-center gap-2 justify-center text-center"
)

// Stop the recording when the user presses the Escape key
onKeydown(async (event) => { 
  if (event.key === "Escape") {
    await screenRecording.stop()
  }
})

// Reveal the recorded video in Finder
await revealFile(filePath) 
```

## Check if a Domain Name is Registered

```typescript 
// Name: Domain Availability Checker
// Description: Checks if a domain name is registered using the Whois API
// Author: johnlindquist

import "@johnlindquist/kit"
import whois from "whois-json" 

// Prompt for the domain name to check
const domainName = await arg("Enter domain name:") 

// Check domain availability using the whois-json library 
const whoisData = await whois(domainName);

// Check the 'domainName' property in the whois data to determine if the domain is registered
if (whoisData.domainName) {
  // Display information about the registered domain 
  await div(
    md(`
## Domain Information:

* Domain Name: ${whoisData.domainName}
* Registrar: ${whoisData.registrar}
* Created: ${whoisData.creationDate} 
* Updated: ${whoisData.updatedDate}
* Expires: ${whoisData.expirationDate}
    `)
  ) 
} else {
  // Display a message if the domain is not registered 
  await div(md(`## Domain "${domainName}" is available!`))
}
```

## Create and Send a Personalized Email

```typescript
// Name: Personalized Email Sender
// Description: Sends a personalized email using Nodemailer and Handlebars
// Author: johnlindquist

import "@johnlindquist/kit" 
import nodemailer from "nodemailer"

// Get email credentials from environment variables
// You can create an app password here: https://support.google.com/accounts/answer/185833?hl=en
const emailUser = await env("EMAIL_USER")
const emailPassword = await env("EMAIL_PASSWORD")

// Create a Nodemailer transporter 
const transporter = nodemailer.createTransport({ 
  service: "gmail",
  auth: {
    user: emailUser, 
    pass: emailPassword, 
  },
})

// Prompt for the recipient's email address 
const to = await arg("Enter recipient email address:")

// Prompt for the recipient's name 
const recipientName = await arg("Enter recipient name:") 

// Prompt for the email subject 
const subject = await arg("Enter email subject:")

// Prompt for the email body using the editor
const body = await editor({
  placeholder: "Enter email body:",
  // Provide a personalized greeting in the placeholder 
  value: `Hi ${recipientName},\n\n`,
})

// Define email options
const mailOptions = {
  from: emailUser,
  to,
  subject,
  html: body,
}

// Send the email
await transporter.sendMail(mailOptions)

// Display a confirmation message 
await div(md(`## Email sent to ${to}!`))
```

##  Convert Images to a Different Format and Quality

```typescript
// Name: Image Converter and Optimizer
// Description: Converts and optimizes images in a directory with custom format and quality 
// Author: johnlindquist

import "@johnlindquist/kit"
import sharp from "sharp" 

// Prompt the user to select a directory
const directoryPath = await path({
  onlyDirs: true, 
}) 

// Prompt for the desired output format
const outputFormat = await arg("Enter output format (e.g., jpeg, png, webp):")

// Prompt for the desired quality (0-100) 
const quality = parseInt(await arg("Enter desired quality (0-100):"))

// Get all image files in the directory (excluding images that already have the target format)
const imageFiles = await globby([`${directoryPath}/*.{jpg,jpeg,png,gif}`, `!${directoryPath}/*.${outputFormat}`]) 

// Convert and optimize images using sharp 
for (const imagePath of imageFiles) {
  await div(md(`# Processing ${path.basename(imagePath)}...`))

  await sharp(imagePath)
    .toFormat(outputFormat, { quality }) // Convert to the specified format and quality 
    .toFile(imagePath.replace(/\.(jpg|jpeg|png|gif)$/, `.${outputFormat}`)) 
}

// Display a notification
await notify("Images converted and optimized!", `in ${directoryPath}`)
```

## Create a Shortcut to Open a Terminal in a Specific Directory

```typescript
// Name: Terminal Shortcut to Directory
// Description: Creates a shortcut to open a terminal in a specific directory
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user to select a directory 
const directoryPath = await path({ 
  onlyDirs: true, 
})

// Prompt for the desired shortcut key combination
const shortcut = await hotkey({
  placeholder: "Press the desired shortcut key combination:",
})

// Register the shortcut to open a new terminal in the selected directory 
registerShortcut(shortcut.shortcut, async () => {
  if (isMac) {
    // Open a new Terminal window in the directory on macOS
    await exec(`open -a Terminal '${directoryPath}'`, { shell: true })
  } else { 
    // For other operating systems, open the directory in the default terminal 
    await exec(`cd '${directoryPath}' && ${process.env.SHELL}`, { shell: true })
  }
})

// Display a notification 
await notify("Shortcut created!", `Press ${shortcut.shortcut} to open a terminal in ${directoryPath}`)
```

## Search and Download Images from Google

```typescript
// Name: Google Image Downloader
// Description: Searches for images on Google and downloads them
// Author: johnlindquist

import "@johnlindquist/kit"
import gis from "g-i-s" // Install the 'g-i-s' package for Google Image Search

// Prompt for the search query 
const query = await arg("Enter image search query:")

// Prompt the user for the download location
const downloadPath = await path({
  onlyDirs: true,
  startPath: home("Downloads"),
})

// Search for images using the Google Images Search API 
gis({ searchTerm: query, queryStringAddition: "&tbs=isz:l" }, async (_error, results) => { // Only search for large images using the 'isz:l' filter
  // Prompt the user to select images to download 
  const selectedImages = await select({ 
    placeholder: `Found ${results.length} images. Select images to download:`,
    multiple: true, // Allow selecting multiple images
    width: PROMPT.WIDTH.LG,
    // Use the search results as choices, displaying thumbnails as previews
    choices: results.map(result => ({
      name: result.url,
      value: result.url,
      preview: `<img src="${result.url}" width="200" />`, 
    })),
  })

  // Download the selected images to the chosen directory
  for (const imageUrl of selectedImages) {
    await div(md(`# Downloading ${imageUrl}...`))
    await download(imageUrl, downloadPath)
  }

  // Display a notification after downloads are complete
  await notify("Images downloaded!", `Saved to ${downloadPath}`) 
}) 
```

##  Convert Image to ASCII Art with Color

```typescript
// Name: Color ASCII Art Generator 
// Description: Converts an image to colored ASCII art using the 'image-to-ascii' library 
// Author: johnlindquist

import "@johnlindquist/kit"
import { imageToAscii } from "image-to-ascii" 

// Prompt the user to select an image 
const imagePath = await path({ 
  filters: [{ name: "Images", extensions: ["jpg", "jpeg", "png", "gif"] }], 
}) 

// Convert the image to colored ASCII art using image-to-ascii
const asciiArt = await imageToAscii(imagePath, {
  // Set the desired width and enable colored output
  width: 80, 
  colored: true, 
}) 

// Display the ASCII art in the terminal 
console.log(asciiArt) 
```



## Get and Display Current Weather in a Widget

```typescript
// Name: Weather Widget 
// Description: Displays the current weather for a location in a widget 
// Author: johnlindquist

import "@johnlindquist/kit" 

// Get your OpenWeatherMap API key from here: https://openweathermap.org/api 
const OPENWEATHERMAP_API_KEY = await env("OPENWEATHERMAP_API_KEY") 

// Prompt for the city and country code (e.g., "London,uk") 
const location = await arg("Enter city and country code (e.g., London,uk):")

// Create a widget to display weather information 
const weatherWidget = await widget(
  `
<div class="p-4">
  <h2 class="text-xl font-bold">Weather in {{city}}</h2> 
  <div class="flex items-center">
    <img :src="weatherIcon" alt="{{description}}" class="w-16 h-16">
    <p class="text-2xl ml-4">{{temperature}}Â°C</p> 
  </div>
  <p class="text-sm">{{description}}</p> 
</div> 
`,
  {
    width: 300, 
    state: {
      city: "", 
      temperature: "", 
      description: "",
      weatherIcon: "", 
    },
  } 
)

// Function to fetch and update weather data
const updateWeather = async () => {
  // Fetch weather data from OpenWeatherMap
  const response = await get(`https://api.openweathermap.org/data/2.5/weather?q=${location}&appid=${OPENWEATHERMAP_API_KEY}&units=metric`) 
  // Extract relevant weather information
  const { name: city, main, weather } = response.data 
  const temperature = Math.round(main.temp) 
  const description = weather[0].description 
  const iconCode = weather[0].icon 
  const weatherIcon = `http://openweathermap.org/img/wn/${iconCode}@2x.png` 

  // Update the widget's state
  weatherWidget.setState({
    city, 
    temperature, 
    description,
    weatherIcon,
  }) 
}

// Update weather information initially and then every 10 minutes 
await updateWeather() 
setInterval(updateWeather, 10 * 60 * 1000) 

// Keep the script running in the background to keep the widget active 
hide()
```

## Resize Images to Fit a Container

```typescript
// Name: Resize Image to Container
// Description: Resizes an image to fit a container, preserving aspect ratio
// Author: johnlindquist

import "@johnlindquist/kit"
import sharp from "sharp" 

// Prompt the user to select an image file 
const imagePath = await path({
  filters: [{ name: "Images", extensions: ["jpg", "jpeg", "png", "gif"] }],
}) 

// Prompt for the container width
const containerWidth = parseInt(await arg("Enter container width (px):"))

// Prompt for the container height 
const containerHeight = parseInt(await arg("Enter container height (px):")) 

// Resize the image using sharp, ensuring it fits within the container while maintaining aspect ratio 
await sharp(imagePath)
  .resize({
    width: containerWidth, 
    height: containerHeight, 
    fit: "inside", 
  })
  .toFile(imagePath) 

// Display a notification
await notify("Image resized to fit container!", `${imagePath}`)
```

##  Upload a File to Google Drive with Sharing Options

```typescript
// Name: Upload and Share to Google Drive
// Description: Uploads a file to Google Drive and sets sharing permissions
// Author: johnlindquist

import "@johnlindquist/kit"
import { google } from "googleapis"
import { JWT } from "google-auth-library" 

// Get credentials for Google Service Account through environment variables
// You can create service account credentials here: https://console.cloud.google.com/apis/credentials
let SA_EMAIL = await env("GOOGLE_SA_EMAIL")
let SA_KEY = await env("GOOGLE_SA_CREDS")

// Define the scopes and client
let jwtClient = new JWT({
  email: SA_EMAIL, 
  key: SA_KEY,
  scopes: ["https://www.googleapis.com/auth/drive"],
}) 

let drive = google.drive("v3")

// Function to upload a file to Google Drive
async function uploadFile(auth, filePath, fileName, folderId = null) {
  // Create the file metadata 
  const fileMetadata = {
    name: fileName, 
    // Optionally, specify a folder ID to upload the file to a specific folder
    parents: folderId ? [folderId] : undefined,
  }

  // Read the file content 
  const media = {
    mimeType: mime.getType(filePath), 
    body: createReadStream(filePath),
  }

  // Upload the file using the Google Drive API 
  try { 
    const response = await drive.files.create({ 
      auth,
      requestBody: fileMetadata, 
      media, 
      fields: "id, webViewLink",
    })

    // Display a success message with the file's view link
    await div(md(`## File uploaded to Google Drive!\n\nView Link: ${response.data.webViewLink}`))
    // Return the file ID and web view link
    return response.data 
  } catch (error) {
    // Handle any errors that occur during upload 
    console.error(`Error uploading file: ${error}`) 
    await div(md(`## Error uploading file: ${error}`)) 
  }
}

// Function to share a file on Google Drive
async function shareFile(auth, fileId, email, role) {
  try {
    // Create a permission for the specified user
    await drive.permissions.create({
      auth,
      fileId, 
      requestBody: {
        type: "user",
        role, 
        emailAddress: email, 
      },
    }) 
  } catch (error) {
    // Handle errors during sharing
    console.error(`Error sharing file: ${error}`) 
    await div(md(`## Error sharing file: ${error}`)) 
  }
}

// Prompt for the file to upload
const filePath = await path()

// Extract the file name from the selected path
const fileName = path.basename(filePath)

// Prompt for optional folder ID
const folderId = await arg("Enter folder ID (optional):") 

// Upload the file to Google Drive (optionally to a specific folder)
const { id: fileId, webViewLink: fileUrl } = await uploadFile(
  jwtClient, 
  filePath,
  fileName, 
  folderId
) 

// Prompt for the number of users to share the file with 
const numUsers = parseInt(await arg("Enter number of users to share with:")) 

// Share the file with each user
for (let i = 0; i < numUsers; i++) {
  const email = await arg(`Enter email address for user ${i + 1}:`)
  const role = await arg(`Enter role for ${email} (reader, writer, owner):`, [
    "reader", 
    "writer",
    "owner", 
  ]) 

  await shareFile(jwtClient, fileId, email, role)
} 

// Display a confirmation message 
await div(md(`## File uploaded and shared!`))
```

## Get and Display System Timezone

```typescript
// Name: Timezone Info 
// Description: Displays the system's current timezone
// Author: johnlindquist 

import "@johnlindquist/kit"

// Get the system's timezone using Intl.DateTimeFormat().resolvedOptions().timeZone
const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone 

// Display the timezone in a div
await div(md(`## Your current timezone is: ${timezone}`))
```

## Compress Images with Custom Settings and Preview

```typescript
// Name: Customizable Image Compressor
// Description: Compresses images in a directory with customizable options and preview
// Author: johnlindquist

import "@johnlindquist/kit"
import sharp from "sharp"

// Prompt for the directory containing images
const directoryPath = await path({
  onlyDirs: true, 
})

// Prompt for the compression quality (0-100)
const quality = parseInt(await arg("Enter desired quality (0-100):"))

// Prompt for the output format 
const outputFormat = await arg(
  "Select output format:",
  ["jpg", "jpeg", "png", "webp"]
)

// Get all image files in the directory 
const imageFiles = await globby([`${directoryPath}/*.{jpg,jpeg,png,gif,webp}`]) 

// Function to generate a preview of a compressed image 
const generatePreview = async (imagePath: string, quality: number, format: string) => {
  // Create a temporary file for the preview image
  const previewImagePath = tmpPath(`preview.${format}`) 
  // Compress the image using sharp and save it to the temporary file
  await sharp(imagePath)
    .toFormat(format, { quality })
    .toFile(previewImagePath) 
  return previewImagePath
} 

// Display a preview of the first image compressed with the specified settings
let previewImagePath = await generatePreview(imageFiles[0], quality, outputFormat)
setPreview(md(`![Preview](${previewImagePath})`))

// Prompt the user to select images to compress
const selectedImagePaths = await select({
  placeholder: "Select images to compress:", 
  multiple: true,
  width: PROMPT.WIDTH.LG, 
  // Dynamically generate choices with previews for each image in the directory
  choices: imageFiles.map(imagePath => ({
    name: path.basename(imagePath), 
    value: imagePath,
    preview: async () => {
      // Generate a preview for the selected image 
      previewImagePath = await generatePreview(imagePath, quality, outputFormat) 
      return md(`![Preview](${previewImagePath})`) 
    },
  })), 
})

// Compress the selected images 
for (const imagePath of selectedImagePaths) {
  await div(md(`# Compressing ${path.basename(imagePath)}...`))

  await sharp(imagePath) 
    .toFormat(outputFormat, { quality }) 
    .toFile(imagePath)
} 

// Display a notification 
await notify("Images compressed!", `Processed ${selectedImagePaths.length} images.`)
```

## Create a New Branch in a Git Repository and Make an Initial Commit

```typescript
// Name: New Git Branch with Commit
// Description: Creates a new branch in a Git repository and makes an initial commit
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the new branch name 
const branchName = await arg("Enter new branch name:")

// Create the new branch and switch to it 
await $`git checkout -b ${branchName}`

// Prompt for the initial commit message
const commitMessage = await arg("Enter initial commit message:")

// Stage all changes and create a commit with the specified message
await $`git add . && git commit -m "${commitMessage}"` 

// Display a confirmation message
await div(md(`## New branch "${branchName}" created with initial commit!`)) 
```

##  Get a List of Your GitHub Repositories

```typescript
// Name: My GitHub Repositories 
// Description: Displays a list of your GitHub repositories
// Author: johnlindquist

import "@johnlindquist/kit" 
import { Octokit } from "@octokit/rest"

// Get GitHub authentication token from environment variables 
// You can get a token from here: https://github.com/settings/tokens 
const githubToken = await env("GITHUB_TOKEN") 

// Create a new Octokit instance
const octokit = new Octokit({ 
  auth: githubToken, 
})

// Fetch the authenticated user's repositories 
const repos = await octokit.paginate(octokit.repos.listForAuthenticatedUser, {
  // Retrieve a maximum of 100 repositories 
  per_page: 100,
  // Sort repositories by name in ascending order 
  sort: "full_name",
  direction: "asc",
}) 

// Create a list of choices for the repositories
const repoChoices = repos.map(repo => ({
  name: repo.full_name, 
  value: repo.html_url, 
  // Display a preview of the repository's README.md file
  preview: async () => { 
    try { 
      const readmeResponse = await get(repo.url + "/readme") 
      return md(readmeResponse?.data)
    } catch (error) { 
      return `No README.md found`
    }
  }, 
}))

// Prompt the user to select a repository 
let selectedRepo = await arg({ 
  placeholder: "Select a repository:", 
  enter: "Open in Browser", 
}, repoChoices)

// Open the selected repository in the browser
await browse(selectedRepo) 
```

## Send a Message to a Discord Channel with an Embed

```typescript
// Name: Send Discord Embed Message 
// Description: Sends a message with an embed to a Discord channel
// Author: johnlindquist 

import "@johnlindquist/kit"
import { Client, IntentsBitField, EmbedBuilder } from "discord.js" 

// Get your Discord Bot Token from here: https://discord.com/developers/applications 
const DISCORD_BOT_TOKEN = await env("DISCORD_BOT_TOKEN") 

// Prompt for the Discord channel ID 
const channelId = await arg("Enter Discord channel ID:")

// Prompt for the embed title
const embedTitle = await arg("Enter embed title:") 

// Prompt for the embed description
const embedDescription = await arg("Enter embed description:") 

// Create a new Discord client instance 
const client = new Client({ intents: [IntentsBitField.Flags.Guilds] }) 

// Log in to Discord using the bot token 
client.login(DISCORD_BOT_TOKEN)

// Create the embed 
const embed = new EmbedBuilder() 
  .setTitle(embedTitle)
  .setDescription(embedDescription)
  // Optionally, set the embed color
  .setColor(0x00ff00)

// Send the embed to the specified channel
client.on("ready", async () => { 
  const channel = client.channels.cache.get(channelId) 

  if (channel?.isTextBased()) {
    await channel.send({ embeds: [embed] })
    console.log(`Message with embed sent to channel ${channelId}`)
  } else {
    console.error("Channel not found or not a text channel.")
  }

  // Disconnect from Discord 
  client.destroy()
})
```

## Convert a Web Page to PDF with a Custom Header

```typescript
// Name: Web to PDF with Header 
// Description: Converts a web page to a PDF with a custom header using Puppeteer 
// Author: johnlindquist

import "@johnlindquist/kit" 
import puppeteer from "puppeteer" 

// Prompt for the website URL 
const url = await arg("Enter website URL:") 

// Prompt for the output file path
const outputFilePath = await path({ 
  startPath: home("Downloads"), 
  // Suggest a filename based on the URL 
  suggestion: `${url.replace(/[^a-zA-Z0-9]/g, "_").slice(0, 20)}.pdf`,
})

// Prompt for the header text 
const headerText = await arg("Enter header text:") 

// Launch a headless browser instance using Puppeteer 
const browser = await puppeteer.launch({ headless: "new" })

try {
  // Create a new page 
  const page = await browser.newPage() 

  // Navigate to the provided URL
  await page.goto(url, { waitUntil: "networkidle0" })

  // Generate the PDF with a custom header
  await page.pdf({
    path: outputFilePath,
    // Enable header and footer display 
    displayHeaderFooter: true, 
    // Define the header template 
    headerTemplate: `<div style="font-size: 8px; text-align: right; padding: 1cm;">${headerText} - Page <span class="pageNumber"></span> of <span class="totalPages"></span></div>`,
    // Set margins to 1cm 
    margin: { top: "1cm", right: "1cm", bottom: "1cm", left: "1cm" },
  }) 

  // Display a notification 
  await notify("PDF generated with header!", `Saved to ${outputFilePath}`) 

  // Reveal the PDF file in Finder 
  await revealFile(outputFilePath)

} finally {
  // Close the browser instance
  await browser.close() 
}
```


## Create and Share a Public GitHub Gist from Clipboard

```typescript
// Name: Share Clipboard as Gist
// Description: Creates a public GitHub Gist from clipboard content
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the text content from the clipboard
const clipboardContent = await paste() 

// Prompt for a description for the Gist 
const description = await arg("Enter Gist description:")

// Prompt for the filename (with extension)
const fileName = await arg("Enter file name (with extension):") 

// Create a public Gist on GitHub using the clipboard content
let { html_url: gistUrl } = await createGist(clipboardContent, {
  description,
  fileName,
  isPublic: true,
}) 

// Display the Gist URL in a div
await div(md(`## Public Gist created at: ${gistUrl}`))

// Copy the Gist URL to the clipboard
await copy(gistUrl) 

// Open the Gist in the browser 
await browse(gistUrl) 
```

## Analyze Website Performance with PageSpeed Insights 

```typescript
// Name: PageSpeed Insights Checker 
// Description: Analyzes website performance using PageSpeed Insights and displays the results
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt for the website URL
const url = await arg("Enter website URL:") 

// Fetch performance data from PageSpeed Insights API 
const response = await get(`https://www.googleapis.com/pagespeedonline/v5/runPagespeed?url=${url}&strategy=mobile`)
// Requires a Google API key, but you can manually test it here: 
// https://pagespeed.web.dev/

// Extract performance score and data
const { data: { lighthouseResult: { categories: { performance }, audits } } } = response

// Display the overall performance score 
await div(md(`## Performance Score: ${Math.round(performance.score * 100)}`))

// Prompt the user to select specific metrics to view in detail
const selectedMetrics = await select("Select metrics to view:", [ 
  "first-contentful-paint", 
  "speed-index", 
  "largest-contentful-paint", 
  "interactive", 
  "total-blocking-time",
  "cumulative-layout-shift",
], { multiple: true }) 

// Display detailed information for each selected metric
for (const metric of selectedMetrics) { 
  await div(md(`
### ${audits[metric].title}:

* Score: ${audits[metric].score * 100} 
* Display Value: ${audits[metric].displayValue}
* Description: ${audits[metric].description}
  `))
}
```

## Extract Colors from an Image

```typescript
// Name: Image Color Extractor 
// Description: Extracts prominent colors from an image using Vibrant
// Author: johnlindquist 

import "@johnlindquist/kit"
import { Vibrant } from "node-vibrant"

// Prompt the user to select an image
const imagePath = await path({
  filters: [{ name: "Images", extensions: ["jpg", "jpeg", "png", "gif", "webp"] }],
}) 

// Extract the color palette from the image using Vibrant
const palette = await Vibrant.from(imagePath).getPalette() 

// Display swatches for each extracted color in a div
await div(
  `<div class="flex flex-row gap-2 p-4">
    ${Object.entries(palette).map(([name, swatch]) => ` 
      <div style="background-color: ${swatch.getHex()}; width: 48px; height: 48px;" title="${name}"></div> 
    `).join("")} 
  </div>`
)
```

##  Rename Files with Sequential Numbers

```typescript
// Name: Sequential File Renamer 
// Description: Renames files in a directory with sequential numbers
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the directory containing the files 
const directoryPath = await path({ 
  onlyDirs: true, 
}) 

// Prompt for the new file name prefix
const fileNamePrefix = await arg("Enter new file name prefix:")

// Get all files in the directory
const files = await readdir(directoryPath) 

// Rename files sequentially
for (let i = 0; i < files.length; i++) {
  const oldFilePath = path.join(directoryPath, files[i])
  const newFilePath = path.join(directoryPath, `${fileNamePrefix}-${i + 1}${path.extname(files[i])}`)
  await mv(oldFilePath, newFilePath)
}

// Display a confirmation message
await div(md(`## Files renamed sequentially in ${directoryPath}!`))
```

## Search and Open a File in VS Code

```typescript
// Name: VS Code File Search 
// Description: Searches for a file in the current directory and opens it in VS Code 
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the file name to search for
const fileName = await arg("Enter file name to search for:")

// Find the file using the `find` command 
const filePath = await find(fileName, { onlyin: "." }) 

// Open the found file in VS Code 
await exec(`code '${filePath}'`, { shell: true })
```

##  Get Commit History for a File with Details

```typescript
// Name: File Commit History Viewer 
// Description: Displays the commit history for a file with details using Git 
// Author: johnlindquist 

import "@johnlindquist/kit"

// Prompt for the file path 
const filePath = await path() 

// Get the commit history for the file using git log, with detailed formatting
const { stdout: commitHistory } = await exec(`git log --pretty=format:"%h - %ad - %an: %s" --date=short --follow -- "${filePath}"`, { 
  shell: true,
}) 

// Display the commit history in the editor
await editor(commitHistory, {
  language: "text",
})
```

##  Generate a Python Package

```typescript
// Name: Python Package Generator
// Description: Generates a new Python package structure
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt for the package name 
const packageName = await arg("Enter package name:")

// Create the package directory
await mkdir(packageName)

// Change to the package directory
cd(packageName)

// Create subdirectories for the package 
await Promise.all([
  mkdir(path.join(packageName, "tests")),
  mkdir(path.join(packageName, "docs")),
])

// Create the "__init__.py" file, marking the directory as a package 
await writeFile(path.join(packageName, "__init__.py"), "")

// Create a "main.py" file for the main package code
await writeFile(
  path.join(packageName, "main.py"),
  `
def greet(name): 
  print(f"Hello, {name}!") 

if __name__ == "__main__":
  greet("World")
`
)

// Display a confirmation message
await div(md(`## Python package "${packageName}" created!`)) 

// Open the package directory in VS Code
await exec(`code .`)
```


## Create and Schedule a Google Meet with Participants

```typescript
// Name: Schedule Google Meet with Participants
// Description: Creates and schedules a Google Meet meeting with participants using the Google Calendar API
// Author: johnlindquist

import "@johnlindquist/kit"
import { google } from "googleapis"
import { JWT } from "google-auth-library"

// Get credentials for Google Service Account through environment variables 
// You can create service account credentials here: https://console.cloud.google.com/apis/credentials
let SA_EMAIL = await env("GOOGLE_SA_EMAIL") 
let SA_KEY = await env("GOOGLE_SA_CREDS")

// Define the scopes and client
let jwtClient = new JWT({
  email: SA_EMAIL, 
  key: SA_KEY,
  scopes: ["https://www.googleapis.com/auth/calendar"],
}) 

let calendar = google.calendar("v3")

// Function to create a calendar event
async function createEvent(auth, event) { 
  // Create the event using the Google Calendar API 
  const response = await calendar.events.insert( { 
    auth,
    calendarId: "primary", 
    resource: event,
    conferenceDataVersion: 1, // Required for creating a Meet conference 
  })

  // Return the event's Hangouts Meet link 
  return response.data.hangoutLink 
} 

// Prompt for the event summary
const eventSummary = await arg("Enter event summary:")

// Prompt for the meeting start time (in UTC) 
const eventStartTime = await arg(
  {
    placeholder: "Enter meeting start time (YYYY-MM-DDTHH:mm:ssZ):", 
    hint: "Example: 2024-03-20T10:00:00Z", 
  }
)

// Prompt for the meeting end time (in UTC) 
const eventEndTime = await arg(
  {
    placeholder: "Enter meeting end time (YYYY-MM-DDTHH:mm:ssZ):", 
    hint: "Example: 2024-03-20T11:00:00Z",
  }
)

// Prompt for the participant email addresses, separated by commas
const participants = await arg("Enter participant email addresses (comma-separated):")
  .split(",")
  .map(email => ({ email: email.trim() })) 

// Create the event object, including participant emails and a request for a Meet conference 
let event = {
  summary: eventSummary,
  start: { dateTime: eventStartTime, timeZone: "UTC" },
  end: { dateTime: eventEndTime, timeZone: "UTC" }, 
  attendees: participants,
  conferenceData: {
    createRequest: {
      requestId: Math.random().toString(),
      conferenceSolutionKey: { type: "hangoutsMeet" }, 
    }, 
  }, 
}

// Create the event and get the Meet link 
const meetLink = await createEvent(jwtClient, event) 

// Display the Meet link in a div
await div(md(`## Join Google Meet:\n\n${meetLink}`))

// Copy the Meet link to the clipboard 
await copy(meetLink) 
```

##  Convert an Image to Different Sizes

```typescript
// Name: Multi-Size Image Converter
// Description: Creates multiple resized versions of an image
// Author: johnlindquist

import "@johnlindquist/kit" 
import sharp from "sharp"

// Prompt for the image path
const imagePath = await path({
  filters: [{ name: "Images", extensions: ["jpg", "jpeg", "png", "gif"] }], 
}) 

// Prompt for the desired widths, separated by commas
const widthsString = await arg("Enter desired widths (comma-separated, in pixels):") 
const widths = widthsString.split(",").map(width => parseInt(width.trim(), 10))

// Resize the image to each specified width using sharp
for (const width of widths) { 
  // Create a new file name with the width appended 
  const outputImagePath = imagePath.replace(/(\.\w+)$/, `-${width}$1`) 

  await sharp(imagePath)
    .resize({ width })
    .toFile(outputImagePath) 
}

// Display a notification 
await notify("Images resized!", `Created ${widths.length} resized images.`)
```

## Check for Updates to a Python Package

```python
# Name: Python Package Update Checker 
# Description: Checks for updates to a Python package using pip 
// Author: johnlindquist

import "@johnlindquist/kit" 
import { execa } from "execa"

// Prompt for the package name
const packageName = await arg("Enter Python package name:") 

// Use pip to check for outdated packages, including the package name 
let { stdout: outdatedPackages } = await execa("pip", ["list", "--outdated", "--format=columns", packageName], {
  shell: true,
})

// Check if the specified package is in the output 
if (outdatedPackages.includes(packageName)) {
  await div(md(`## Updates are available for ${packageName}. Run 'pip install --upgrade ${packageName}' to update.`)) 
} else {
  await div(md(`## ${packageName} is up to date.`)) 
}
```

## Clean Up Unused Files in Downloads Directory

```typescript
// Name: Downloads Cleanup
// Description: Removes unused files from the Downloads directory based on file type and age
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt for the file types to target for cleanup
const fileTypes = await select(
  "Select file types to clean up:", 
  [
    ".zip", 
    ".dmg",
    ".pkg", 
    ".log", 
    ".tmp",
    ".txt", // Add ".txt" to the list of file types
  ],
  {
    multiple: true,
  } 
)

// Prompt for the maximum age of files to keep (in days) 
const maxAgeDays = parseInt(await arg("Enter maximum age of files to keep (days):"))

// Get the current timestamp
const now = Date.now() 

// Construct the glob patterns for the selected file types in the Downloads directory
const globPatterns = fileTypes.map(fileType => `${home("Downloads")}/*${fileType}`)

// Get the list of files matching the selected types 
const files = await globby(globPatterns)

// Create a list of files to delete based on their age
const filesToDelete: string[] = []
for (const file of files) {
  const { mtimeMs } = await stat(file) 

  // Calculate the age of the file in days
  const fileAgeDays = (now - mtimeMs) / (1000 * 60 * 60 * 24) 

  // Add the file to the deletion list if it's older than the maximum age 
  if (fileAgeDays > maxAgeDays) { 
    filesToDelete.push(file) 
  }
}

if (filesToDelete.length > 0) { 
  // Prompt for confirmation before deleting files
  let shouldDelete = await arg(
    {
      placeholder: `Found ${filesToDelete.length} files older than ${maxAgeDays} days. Delete them?`, 
      // Display the list of files to be deleted in the preview
      preview: md(filesToDelete.map(file => `- ${file}`).join("\n")),
      height: PROMPT.HEIGHT.LG,
    }, 
    ["Yes", "No"]
  ) 

  // Delete the files if confirmed
  if (shouldDelete === "Yes") { 
    await trash(filesToDelete)
    await notify("Old files deleted from Downloads!") 
  } 
} else {
  // Display a message if no files are older than the specified age
  await div(md(`## No files older than ${maxAgeDays} days found in Downloads.`)) 
}
```

## Get and Set the System Brightness

```typescript
// Name: Brightness Control
// Description: Controls the system brightness (macOS only) 
// Author: johnlindquist

import "@johnlindquist/kit"

// Check if running on macOS 
if (isMac) {
  // Prompt the user to choose whether to increase or decrease brightness
  const action = await arg("Adjust brightness:", ["Increase", "Decrease"])

  // Adjust brightness based on the selected action using osascript 
  if (action === "Increase") {
    await applescript(`tell application "System Events" to key code 144`) // Press F2 to increase brightness 
  } else if (action === "Decrease") {
    await applescript(`tell application "System Events" to key code 145`) // Press F1 to decrease brightness 
  } 
} else {
  // Display a message if not running on macOS
  await div(md(`## This script is only supported on macOS.`)) 
}
```

##  Create a Time-Lapse Video with Custom Start and End Times from Webcam

```typescript
// Name: Trimmed Webcam Time-lapse
// Description: Creates a time-lapse video from webcam captures with specific start and end times
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the duration of the capture (in minutes)
const captureDurationMinutes = parseFloat(
  await arg("Enter capture duration (minutes):") 
) 

// Prompt for the interval between captures (in seconds) 
const intervalSeconds = parseInt(await arg("Enter interval between captures (seconds):"))

// Prompt for the start time for the time-lapse (in seconds from the start of the capture)
const startTimeSeconds = parseFloat(await arg("Enter start time for time-lapse (seconds):")) 

// Prompt for the end time for the time-lapse (in seconds from the start of the capture) 
const endTimeSeconds = parseFloat(await arg("Enter end time for time-lapse (seconds):"))

// Prompt for the output file path 
const outputFilePath = await path({
  startPath: home("Downloads"),
})

// Create a temporary directory to store captures 
const capturesDir = tmpPath("captures") 
await ensureDir(capturesDir)

// Calculate the total number of captures 
const totalCaptures = Math.floor(captureDurationMinutes * 60 / intervalSeconds) 

// Display a progress bar while capturing images 
let captureCount = 0 
const progressBar = await div(md(`# Capturing webcam images...

${captureCount} of ${totalCaptures}`))

// Capture images from the webcam at the specified interval 
let intervalId = setInterval(async () => {
  // Capture an image from the webcam 
  const capturePath = path.join(
    capturesDir, 
    `capture-${captureCount}.jpg`
  ) 
  await webcam({ 
    filePath: capturePath, 
  }) 

  // Increment the capture count and update the progress bar 
  captureCount++ 
  progressBar.setState({
    html: md(`# Capturing webcam images...

    ${captureCount} of ${totalCaptures}`),
  })

  // Stop the timer when all captures are done 
  if (captureCount >= totalCaptures) {
    clearInterval(intervalId) 
    // Close the progress bar 
    progressBar.close() 
  }
}, intervalSeconds * 1000) 

// Wait for the captures to complete
await wait(captureDurationMinutes * 60 * 1000) 

// Generate the time-lapse video from the captured images using ffmpeg, trimming the video based on the specified start and end times
await exec(`ffmpeg -y -framerate 30 -start_number 0 -i '${capturesDir}/capture-%d.jpg' -ss ${startTimeSeconds} -to ${endTimeSeconds} -c:v libx264 -pix_fmt yuv420p '${outputFilePath}'`, { shell: true }) 

// Display a notification 
await notify("Time-lapse video created!", `Saved to ${outputFilePath}`)

// Reveal the time-lapse video in Finder 
await revealFile(outputFilePath) 
```

## Create a Dynamic Countdown Timer

```typescript
// Name: Dynamic Countdown Timer
// Description: Creates a countdown timer with adjustable duration
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt for the initial duration of the countdown (in seconds) 
let durationSeconds = parseInt(await arg("Enter countdown duration (seconds):"))

// Create a widget to display the countdown 
const timerWidget = await widget(
  `
<div class="p-4">
  <h2 class="text-xl font-bold">Countdown Timer:</h2>
  <p class="text-3xl">{{ remainingTime }}</p> 
  <div class="flex gap-2"> 
    <button class="px-2 py-1 rounded bg-blue-500 text-white" @click="addTime(60)">+1 Minute</button> 
    <button class="px-2 py-1 rounded bg-blue-500 text-white" @click="addTime(10)">+10 Seconds</button> 
    <button class="px-2 py-1 rounded bg-red-500 text-white" @click="addTime(-60)">-1 Minute</button> 
    <button class="px-2 py-1 rounded bg-red-500 text-white" @click="addTime(-10)">-10 Seconds</button> 
  </div>
</div> 
`,
  { 
    width: 300,
    // Set the initial widget state 
    state: {
      remainingTime: durationSeconds, 
      addTime: (seconds: number) => {
        // Update the remaining time in the widget state 
        timerWidget.setState({
          remainingTime: timerWidget.state.remainingTime + seconds,
        }) 
      },
    }, 
  }
) 

// Update the timer every second
let intervalId = setInterval(() => {
  // Decrement the remaining time
  timerWidget.setState({
    remainingTime: timerWidget.state.remainingTime - 1, 
  })

  // Stop the timer and update the widget when the countdown reaches 0 
  if (timerWidget.state.remainingTime <= 0) {
    clearInterval(intervalId)
    timerWidget.setState({ remainingTime: "Time's up!" })
    sendNotification("Countdown Timer", "Time's up!")
  }
}, 1000) 
```

##  Compare Two Text Files 

```typescript
// Name: Text File Comparator
// Description: Compares two text files and highlights the differences 
// Author: johnlindquist

import "@johnlindquist/kit"
import { diffChars } from "diff" 

// Prompt for the first file path 
const filePath1 = await path()

// Prompt for the second file path 
const filePath2 = await path() 

// Read the contents of both files
const fileContent1 = await readFile(filePath1, "utf-8")
const fileContent2 = await readFile(filePath2, "utf-8") 

// Compare the file contents using diffChars 
const diffResult = diffChars(fileContent1, fileContent2) 

// Generate HTML to display the differences, highlighting added and removed characters
let diffHtml = `<pre class="whitespace-pre-wrap">`
for (const part of diffResult) { 
  if (part.added) {
    diffHtml += `<span style="color: green;">${part.value}</span>` 
  } else if (part.removed) {
    diffHtml += `<span style="color: red;">${part.value}</span>`
  } else { 
    diffHtml += `<span>${part.value}</span>`
  } 
} 

// Close the <pre> tag
diffHtml += `</pre>` 

// Display the differences in a div 
await div(diffHtml) 
```





## Create a New Google Calendar Event with Attendees 

```typescript
// Name: Create Google Calendar Event with Attendees
// Description: Creates a new Google Calendar event and invites attendees
// Author: johnlindquist

import "@johnlindquist/kit"
import { google } from "googleapis"
import { JWT } from "google-auth-library"

// Get credentials for Google Service Account through environment variables
// You can create service account credentials here: https://console.cloud.google.com/apis/credentials
let SA_EMAIL = await env("GOOGLE_SA_EMAIL") 
let SA_KEY = await env("GOOGLE_SA_CREDS") 

// Define the scopes and client
let jwtClient = new JWT({
  email: SA_EMAIL,
  key: SA_KEY,
  scopes: ["https://www.googleapis.com/auth/calendar"],
})

let calendar = google.calendar("v3")

// Function to create a calendar event
async function createEvent(auth, event) {
  // Create the event using the Google Calendar API
  const response = await calendar.events.insert( {
    auth,
    calendarId: "primary",
    requestBody: event, 
    conferenceDataVersion: 1,
  });

  // Display a confirmation message with the event link 
  await div(md(`## Event created: [${response.data.htmlLink}](${response.data.htmlLink})`))
}

// Prompt for event details 
let eventSummary = await arg("Enter event summary:") 
let eventStartTime = await arg("Enter event start time (YYYY-MM-DDTHH:mm:ssZ):")
let eventEndTime = await arg("Enter event end time (YYYY-MM-DDTHH:mm:ssZ):")

// Prompt for the number of attendees 
const numAttendees = parseInt(await arg("Enter number of attendees:"))

// Collect attendee emails
let attendees = []
for (let i = 0; i < numAttendees; i++) {
  attendees.push({
    email: await arg(`Enter email address for attendee ${i + 1}:`),
  }) 
}

// Create the event object with attendees 
let event = { 
  summary: eventSummary,
  start: { dateTime: eventStartTime, timeZone: "UTC" },
  end: { dateTime: eventEndTime, timeZone: "UTC" },
  attendees: attendees,
} 

// Create the event 
await createEvent(jwtClient, event)
```

##  Rename Files and Update References

```typescript
// Name: Rename File and Update References
// Description: Renames a file and updates references to it in other files
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt the user to select a file to rename
const oldFilePath = await path()

// Prompt for the new file name
const newFileName = await arg("Enter new file name:") 

// Construct the new file path
const newFilePath = path.join(path.dirname(oldFilePath), newFileName)

// Rename the file
await mv(oldFilePath, newFilePath)

// Update references to the file in other files using ripgrep and sed
// This example assumes you want to update references in .js and .ts files
await exec(`rg '${path.basename(oldFilePath)}' -l *.{js,ts} | xargs -I {} sed -i '' 's/${path.basename(oldFilePath)}/${newFileName}/g' {}`, {
  shell: true,
}) 

// Display a confirmation message 
await div(md(`## File renamed and references updated!`))
```

## Get and Display Lyrics for a Song

```typescript
// Name: Song Lyrics Viewer
// Description: Retrieves and displays lyrics for a song
// Author: johnlindquist 

import "@johnlindquist/kit"
import lyricsFinder from "lyrics-finder"

// Prompt for the artist name
const artist = await arg("Enter artist name:")

// Prompt for the song title 
const songTitle = await arg("Enter song title:") 

// Fetch lyrics using lyrics-finder
const lyrics = await lyricsFinder(artist, songTitle).catch(() => "Lyrics not found.") 

// Display the lyrics in the editor
await editor(lyrics, { 
  language: "text", 
  // Automatically resize the editor to fit the lyrics content 
  resize: true, 
}) 
```

## Remove Unused Docker Images with Confirmation

```typescript
// Name: Docker Image Cleanup
// Description: Removes unused Docker images with confirmation
// Author: johnlindquist 

import "@johnlindquist/kit" 

// Run 'docker images' to list all Docker images 
let { stdout: dockerImages } = await exec(`docker images`, {
  shell: true,
})

// Display the list of Docker images and prompt the user to select images to remove 
const imagesToRemove = await arg(
  {
    placeholder: "Select images to remove (use cmd/ctrl for multiple):",
    // Use the output of docker images as the prompt content 
    // The user will see the list of images directly in the prompt
    input: dockerImages, 
    // Allow multiple selections 
    multiple: true, 
    // Set a custom width and height for the prompt
    width: PROMPT.WIDTH.LG,
    height: PROMPT.HEIGHT.LG, 
  },
  // No need to provide choices, as they are dynamically generated from the docker images command 
  [] as string[] 
)

// If the user selected images, proceed with removal 
if (imagesToRemove.length > 0) {
  // Display a confirmation dialog before removing images
  let confirmed = await arg(
    `Are you sure you want to remove the following images?\n\n${imagesToRemove.join("\n")}`,
    [
      { name: "Yes", value: true },
      { name: "No", value: false }, 
    ]
  )

  // Remove the selected images using 'docker rmi' if confirmed 
  if (confirmed) { 
    for (const image of imagesToRemove) { 
      // Remove the image using its ID or tag 
      await exec(`docker rmi ${image}`, { shell: true })
    }

    // Display a notification
    await notify("Docker images removed!", `Removed ${imagesToRemove.length} images.`) 
  }
}
```

## Generate a Python Script with Docstrings

```python
# Name: Documented Python Script
# Description: Creates a new Python script with docstrings 
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the script name 
const scriptName = await arg("Enter Python script name (e.g., my_script.py):")

// Prompt for the function name
const functionName = await arg("Enter function name:")

// Prompt for a description of the function
const functionDescription = await arg("Enter function description:")

// Create the Python script content with docstrings
const scriptContent = `def ${functionName}():
  """${functionDescription}

  Returns:
      None
  """
  # Your code here
  pass

if __name__ == "__main__":
  ${functionName}()
`

// Write the script content to a file
await writeFile(scriptName, scriptContent)

// Display a confirmation message 
await div(md(`## Python script "${scriptName}" created with docstrings!`))

// Open the script file in VS Code
await exec(`code ${scriptName}`)
```

## Create a New Google Calendar Event with a Reminder

```typescript
// Name: Create Google Calendar Event with Reminder 
// Description: Creates a new Google Calendar event with a reminder
// Author: johnlindquist

import "@johnlindquist/kit" 
import { google } from "googleapis" 
import { JWT } from "google-auth-library"

// Get credentials for Google Service Account through environment variables
// You can create service account credentials here: https://console.cloud.google.com/apis/credentials
let SA_EMAIL = await env("GOOGLE_SA_EMAIL") 
let SA_KEY = await env("GOOGLE_SA_CREDS")

// Define the scopes and client
let jwtClient = new JWT({ 
  email: SA_EMAIL,
  key: SA_KEY,
  scopes: ["https://www.googleapis.com/auth/calendar"],
})

let calendar = google.calendar("v3") 

// Function to create a calendar event
async function createEvent(auth, event) {
  // Create the event using the Google Calendar API
  const response = await calendar.events.insert({ 
    auth, 
    calendarId: "primary", 
    requestBody: event, 
    conferenceDataVersion: 1,
  })

  // Display a confirmation message with the event link
  await div(md(`## Event created: [${response.data.htmlLink}](${response.data.htmlLink})`)) 
}

// Prompt for the event summary
const eventSummary = await arg("Enter event summary:")

// Prompt for the meeting start time (in UTC)
const eventStartTime = await arg({
  placeholder: "Enter meeting start time (YYYY-MM-DDTHH:mm:ssZ):",
  hint: "Example: 2024-03-20T10:00:00Z",
}) 

// Prompt for the meeting end time (in UTC) 
const eventEndTime = await arg({
  placeholder: "Enter meeting end time (YYYY-MM-DDTHH:mm:ssZ):", 
  hint: "Example: 2024-03-20T11:00:00Z",
}) 

// Prompt for the reminder time (in minutes)
const reminderMinutes = parseInt(await arg("Enter reminder time (minutes before event):"))

// Create the event object with a reminder
let event = {
  summary: eventSummary,
  start: { dateTime: eventStartTime, timeZone: "UTC" }, 
  end: { dateTime: eventEndTime, timeZone: "UTC" }, 
  reminders: {
    useDefault: false, 
    overrides: [ 
      { method: "popup", minutes: reminderMinutes },
    ],
  },
} 

// Create the event 
await createEvent(jwtClient, event)
```

## Automatically Compress Images on Save

```typescript
// Name: Auto Image Compressor
// Description: Watches for image file changes and automatically compresses them
// Author: johnlindquist 

import "@johnlindquist/kit" 
import sharp from "sharp"

// Prompt for the directory to watch for image changes
const directoryPath = await path({
  onlyDirs: true,
}) 

// Watch for changes to image files in the directory
await watch( 
  `${directoryPath}/*.{jpg,jpeg,png,gif}`, // Specify glob pattern to watch for image files
  async (filePath) => {
    // Compress the image using sharp with a quality of 80
    await sharp(filePath)
      .jpeg({ quality: 80 })
      .toFile(filePath) 

    // Display a notification
    await notify(`Image compressed: ${filePath}`)
  }, 
  { events: ["add", "change"] } // Trigger the script on file creation or modification 
)
```



## Resize Image with Confirmation

```typescript
// Name: Resize Image with Confirmation
// Description: Resizes an image to a specified width, prompting for confirmation before overwriting
// Author: johnlindquist

import "@johnlindquist/kit"
import Jimp from "jimp"

// Get the image path from the user
let imagePath = await arg("Enter image path:")

// Prompt for the new width
let newWidth = await arg(
  "Enter new width in pixels:",
  imagePath
    ? md(`![Image](${imagePath})`)
    : `Please select an image first.`
)

// Calculate the new height based on the aspect ratio
let image = await Jimp.read(imagePath)
let newHeight = Math.floor(
  (image.bitmap.height * parseInt(newWidth)) /
    image.bitmap.width
)

// Confirm overwrite if the file already exists
if (await isFile(imagePath)) {
  let overwrite = await arg(
    "Overwrite existing file?",
    [
      { name: "Yes", value: true },
      { name: "No", value: false },
    ]
  )
  if (!overwrite) {
    exit()
  }
}

// Resize and save the image
await image
  .resize(parseInt(newWidth), newHeight)
  .writeAsync(imagePath)

console.log(`Image resized to ${newWidth}x${newHeight} pixels.`)
```

## Generate TypeScript Typings from JSON

```typescript
// Name: Generate TypeScript Typings from JSON
// Description: Converts a JSON object to TypeScript typings
// Author: johnlindquist

import "@johnlindquist/kit"
import { quicktype, InputData, JSONSchemaInput } from "quicktype-core"

// Prompt for the JSON object
let jsonObject = await arg("Enter a JSON object:")

// Function to generate TypeScript typings from JSON
async function generateTypes(json: string) {
  const schemaInput = new JSONSchemaInput(undefined)
  // Add the JSON as input data
  await schemaInput.addSource({
    name: "TopLevel",
    schema: json,
  })

  const inputData = new InputData()
  inputData.addInput(schemaInput)

  // Generate the TypeScript code
  const { lines } = await quicktype({
    inputData,
    lang: "typescript",
  })
  // Join the generated lines
  return lines.join("\n")
}

// Generate TypeScript types and display in the editor
let typeScriptTypes = await generateTypes(jsonObject)
await editor({
  value: typeScriptTypes,
  language: "typescript",
})
```

## Create and Push a Git Branch

```typescript
// Name: Create and Push Git Branch 
// Description: Creates a new Git branch and pushes it to the remote repository
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the branch name
let branchName = await arg("Enter new branch name:")

// Execute Git commands to create and push the branch
await $`git checkout -b ${branchName}`
await $`git push -u origin ${branchName}`

console.log(`Branch ${branchName} created and pushed to remote.`)
```

## Convert Markdown to HTML and Copy to Clipboard

```typescript
// Name: Markdown to HTML
// Description: Converts Markdown to HTML and copies it to the clipboard
// Author: johnlindquist

import "@johnlindquist/kit"
import { marked } from "marked"

// Get Markdown from the clipboard
const markdown = await paste()

// Convert Markdown to HTML
const html = marked.parse(markdown)

// Copy the HTML to the clipboard
await copy(html)

console.log("Markdown converted to HTML and copied to clipboard.")
```

## Search NPM Packages and Display Details

```typescript
// Name: NPM Package Search
// Description: Searches for NPM packages and displays details
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the package name 
const packageName = await arg("Enter package name:") 

// Fetch package details from the NPM registry
const packageData = await get(`https://registry.npmjs.org/${packageName}`)

// Extract relevant information 
const { name, description, version, author, repository, homepage } = packageData.data 

// Create a markdown-formatted string for the package details
const packageDetails = md(`
## ${name} (${version})

${description}

**Author:** ${author.name} 
**Repository:** ${repository.url} 
**Homepage:** ${homepage}
`); 

// Display the package details in a div prompt
await div(packageDetails)
```

## Generate a Random Password

```typescript
// Name: Generate Random Password
// Description: Generates a random password of specified length
// Author: johnlindquist 

import "@johnlindquist/kit"
import { generate } from "generate-password" 

// Prompt for the desired password length
const passwordLength = parseInt(await arg("Enter password length:")) 

// Generate a random password with the specified length
const password = generate({
  length: passwordLength,
  numbers: true,
  symbols: true,
  uppercase: true,
  lowercase: true, 
  excludeSimilarCharacters: true,
})

// Copy the generated password to the clipboard 
await copy(password) 

console.log("Password generated and copied to clipboard.")
```

## Convert Text to Speech and Play

```typescript
// Name: Text to Speech
// Description: Converts text to speech and plays it
// Author: johnlindquist

import "@johnlindquist/kit"
import { Configuration, OpenAIApi } from "openai";

// Get the OpenAI API key from the environment
// https://beta.openai.com/account/api-keys
const openaiApiKey = await env("OPENAI_API_KEY")

// Initialize OpenAI API
const openai = new OpenAIApi(new Configuration({ apiKey: openaiApiKey }));

// Prompt for text input
let inputText = await arg("Enter text to convert to speech:") 

// Generate speech audio
const response = await openai.audio.speech.create({
  model: "tts-1", 
  voice: "alloy",
  input: inputText,
})

// Save the audio data as an MP3 file 
const audioFilePath = tmpPath("speech.mp3"); 
const audioArrayBuffer = await response.arrayBuffer();
const audioBuffer = Buffer.from(audioArrayBuffer);
await writeFile(audioFilePath, audioBuffer);

// Play the generated speech 
await playAudioFile(audioFilePath); 

console.log("Text converted to speech and played successfully.")
```

## Create a ZIP Archive of a Folder

```typescript
// Name: Create ZIP Archive
// Description: Creates a ZIP archive of a selected folder 
// Author: johnlindquist

import "@johnlindquist/kit"
import { create } from "archiver";
import { createWriteStream } from "fs" 

// Prompt for the folder path
const folderPath = await path({
  onlyDirs: true,
  hint: "Select a folder to archive" 
}) 

// Create a ZIP archive
const output = fs.createWriteStream(`${folderPath}.zip`);
const archive = create("zip", { 
  zlib: { level: 9 } // Sets the compression level
});

// Pipe the archive data to the output stream
archive.pipe(output); 

// Append the selected folder to the archive
archive.directory(folderPath, false); 

// Finalize the archive
await archive.finalize(); 

console.log(`ZIP archive created: ${folderPath}.zip`);
```

## Get Weather Information for a Location

```typescript
// Name: Get Weather
// Description: Retrieves weather information for a given location
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the OpenWeatherMap API key from the environment
// https://openweathermap.org/api
const openWeatherMapApiKey = await env("OPENWEATHERMAP_API_KEY") 

// Prompt for the location
let location = await arg("Enter location:") 

// Fetch weather data from the API
const response = await get(
  `https://api.openweathermap.org/data/2.5/weather?q=${location}&appid=${openWeatherMapApiKey}&units=metric`
)

// Extract relevant information
const { name, main, weather } = response.data 

// Create markdown-formatted string for the weather details
const weatherInfo = md(`
## Weather in ${name}

* Temperature: ${main.temp}Â°C
* Feels like: ${main.feels_like}Â°C
* Condition: ${weather[0].description}
`) 

// Display the weather information
await div(weatherInfo)
```

## Translate Text Using Google Translate API

```typescript
// Name: Translate Text 
// Description: Translates text using the Google Translate API 
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the Google Cloud Translation API key from the environment
// https://cloud.google.com/translate/docs/setup
const googleTranslateApiKey = await env("GOOGLE_TRANSLATE_API_KEY")

// Prompt for text input
let textToTranslate = await arg("Enter text to translate:") 

// Prompt for the target language code
let targetLanguage = await arg("Enter target language code (e.g., 'fr' for French):") 

// Translate text using the API
const response = await get(
  `https://translation.googleapis.com/language/translate/v2?key=${googleTranslateApiKey}`,
  {
    params: {
      q: textToTranslate,
      target: targetLanguage,
    },
  } 
)

// Extract the translated text
const translatedText = response.data.data.translations[0].translatedText

// Display the translated text
await div(md(`# Translated Text:\n\n${translatedText}`))
```

## Send Email using Nodemailer

```typescript
// Name: Send Email 
// Description: Sends an email using Nodemailer
// Author: johnlindquist

import "@johnlindquist/kit"
import nodemailer from "nodemailer" 

// Get the email credentials from the environment
// https://nodemailer.com/about/
const emailUser = await env("EMAIL_USER") 
const emailPassword = await env("EMAIL_PASSWORD")

// Create a transporter using your chosen email provider's settings
const transporter = nodemailer.createTransport({
  service: await arg("Enter email provider (e.g., 'gmail'):"),
  auth: {
    user: emailUser,
    pass: emailPassword, 
  },
})

// Prompt for email details
const recipientEmail = await arg("Enter recipient email address:") 
const subject = await arg("Enter email subject:")
const body = await arg("Enter email body:") 

// Compose the email 
const mailOptions = { 
  from: emailUser,
  to: recipientEmail, 
  subject: subject,
  text: body,
} 

// Send the email 
await transporter.sendMail(mailOptions)

console.log("Email sent successfully.") 
```

## Convert a CSV File to JSON

```typescript
// Name: CSV to JSON
// Description: Converts a CSV file to a JSON object
// Author: johnlindquist

import "@johnlindquist/kit"
import { parse } from "csv-parse" 

// Prompt for the CSV file path 
const csvFilePath = await path({
  hint: "Select a CSV file"
})

// Function to parse the CSV file and convert it to JSON
async function convertCsvToJson(filePath: string): Promise<any> {
  // Read the CSV file contents
  const csvContent = await readFile(filePath, "utf-8")

  // Create a promise to handle the CSV parsing 
  const parsedData = new Promise((resolve, reject) => {
    parse(
      csvContent, 
      { 
        columns: true, // Extract column headers
        skip_empty_lines: true // Ignore empty lines
      },
      (err, records) => { 
        if (err) {
          reject(err)
        } else { 
          resolve(records)
        }
      } 
    ) 
  }) 

  return parsedData; 
}

// Convert the CSV file to JSON and display in the editor
const jsonData = await convertCsvToJson(csvFilePath)
await editor({
  value: JSON.stringify(jsonData, null, 2), 
  language: "json",
})
```

## Create a Screenshot of the Current Screen

```typescript
// Name: Screenshot
// Description: Takes a screenshot of the current screen
// Author: johnlindquist

import "@johnlindquist/kit"

// Hide the prompt to avoid capturing it in the screenshot
await hide()

// Get a screenshot of the current screen
const screenshot = await getScreenshot()

// Prompt for a file path to save the screenshot 
let imagePath = await path({
  hint: "Select a location to save the screenshot"
})

// Append ".png" to the file name if it doesn't have an extension
if (!path.extname(imagePath)) {
  imagePath = `${imagePath}.png` 
}

// Write the screenshot data to the file 
await writeFile(imagePath, screenshot)

console.log(`Screenshot saved to: ${imagePath}`)
```

## Generate QR Code from Text

```typescript
// Name: Generate QR Code
// Description: Generates a QR code from text input 
// Author: johnlindquist

import "@johnlindquist/kit"
import QRCode from "qrcode"

// Prompt for text input
let inputText = await arg("Enter text for QR code:")

// Generate QR code as a data URL
const qrCodeDataUrl = await QRCode.toDataURL(inputText)

// Display the QR code in a div
await div(`<img src="${qrCodeDataUrl}" alt="QR Code" />`) 
```

## Search and Replace Text in Multiple Files

```typescript
// Name: Search and Replace
// Description: Replaces text in multiple files
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the directory to search
const directoryPath = await path({
  hint: "Select a directory",
  onlyDirs: true, 
})

// Prompt for the search term 
const searchTerm = await arg("Enter search term:")

// Prompt for the replacement text 
const replacementText = await arg("Enter replacement text:")

// Search and replace in files
await replace({ 
  files: path.join(directoryPath, "**/*"), // Search all files in the directory 
  from: searchTerm,
  to: replacementText,
});

console.log(`Text replaced in files within ${directoryPath}.`)
```

## Get System Information

```typescript
// Name: System Info
// Description: Displays system information
// Author: johnlindquist

import "@johnlindquist/kit"
import os from "os";

// Get system information
const platform = os.platform() 
const hostname = os.hostname() 
const cpu = os.cpus()[0].model 
const memory = os.totalmem() 
const uptime = os.uptime()

// Format system information
const systemInfo = md(`
## System Information

* Platform: ${platform} 
* Hostname: ${hostname}
* CPU: ${cpu}
* Memory: ${filesize(memory)} 
* Uptime: ${formatDistanceToNow(new Date(Date.now() - uptime * 1000))}
`); 

// Display system information
await div(systemInfo)
```

## Convert Image to Base64

```typescript
// Name: Image to Base64
// Description: Converts an image to Base64 encoding
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the image path
let imagePath = await path({
  hint: "Select an image" 
})

// Read the image file
const imageBuffer = await readFile(imagePath) 

// Convert the image buffer to Base64 encoding
const base64Image = imageBuffer.toString('base64')

// Copy the Base64 encoded image to the clipboard 
await copy(base64Image) 

console.log("Image converted to Base64 and copied to clipboard.")
```

## Create and Send a Personalized Email

```typescript
// Name: Personalized Email Sender
// Description: Sends a personalized email to a recipient
// Author: johnlindquist

import "@johnlindquist/kit"
import nodemailer from "nodemailer"

// Get the email credentials from the environment
// https://nodemailer.com/about/ 
const emailUser = await env("EMAIL_USER")
const emailPassword = await env("EMAIL_PASSWORD")

// Create a transporter using your chosen email provider's settings 
const transporter = nodemailer.createTransport({
  service: await arg("Enter email provider (e.g., 'gmail'):"), 
  auth: {
    user: emailUser,
    pass: emailPassword,
  },
})

// Prompt for recipient's name
const recipientName = await arg("Enter recipient's name:") 

// Prompt for recipient's email address
const recipientEmail = await arg("Enter recipient's email address:")

// Compose the email with personalized subject and body
const mailOptions = {
  from: emailUser,
  to: recipientEmail,
  subject: `Hello, ${recipientName}!`, 
  // Use template literals for easy string interpolation
  text: `Hi ${recipientName},

This is a personalized email sent from Script Kit.

How are you doing today?`,
}

// Send the email
await transporter.sendMail(mailOptions)

console.log(`Email sent to ${recipientName} <${recipientEmail}>.`)
```

## Generate a New Script from a Template

```typescript
// Name: Generate Script from Template
// Description: Creates a new script from a chosen template
// Author: johnlindquist

import "@johnlindquist/kit"
import { generate } from "@johnlindquist/kit-internal/project-name-generator"

// Function to strip the extension from a file name
const stripExtension = (fileName: string) =>
  fileName.replace(path.extname(fileName), "")

// Get available templates from the templates directory
const templates = (await readdir(kenvPath("templates")))
  .map(stripExtension)
  .filter(t => !t.startsWith(".")) // ignore dotfiles 

// Prompt for template selection
let template = await arg(
  "Select a template:",
  templates
)

// Prompt for script name input
let scriptName = await arg({
  placeholder: "Enter script name:",
  validate: exists, // Make sure the script name doesn't already exist 
})

// Create the new script using the selected template
await cli("new", scriptName, "--template", template)
```

## Convert Text to Uppercase

```typescript
// Name: Uppercase Text
// Description: Converts selected text to uppercase
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the selected text 
const selectedText = await getSelectedText()

// Convert to uppercase 
const uppercaseText = selectedText.toUpperCase()

// Set the selected text to the uppercase version
await setSelectedText(uppercaseText)

console.log(`Converted "${selectedText}" to "${uppercaseText}"`)
```

## Create a New To-Do List Item

```typescript
// Name: Add To-Do
// Description: Adds a new to-do item to a list
// Author: johnlindquist

import "@johnlindquist/kit"

// Define the path to the to-do list file
const todoFilePath = kenvPath("todo.md")

// Get existing to-do items from the file
let todoItems = (await readFile(todoFilePath, "utf8"))
  .split("\n")
  .filter(line => line.trim().startsWith("- [ ]"))
  .map(line => line.replace("- [ ]", "").trim())

// Prompt for a new to-do item
let newTodo = await arg("Enter a new to-do item:")

// Add the new item to the list
todoItems.push(newTodo)

// Update the to-do list file
await writeFile(
  todoFilePath,
  todoItems.map(item => `- [ ] ${item}`).join("\n")
)

console.log("New to-do item added to the list.")
```

## Create a New Note

```typescript
// Name: New Note
// Description: Creates a new note with a timestamp
// Author: johnlindquist 

import "@johnlindquist/kit"

// Generate a timestamp for the note file name
const timestamp = formatDate(new Date(), "yyyyMMddHHmmss")

// Create a new note file with the timestamp 
const noteFilePath = kenvPath("notes", `note-${timestamp}.md`)
await ensureFile(noteFilePath)

// Open the new note file in the editor 
await edit(noteFilePath)
```

## Check Website Status

```typescript
// Name: Website Status Checker 
// Description: Checks the status of a website and displays the result 
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for a website URL
const url = await arg({
  placeholder: "Enter a website URL:", 
})

try { 
  // Attempt to fetch the website 
  const response = await fetch(url)

  // Display the status code and message
  await div(
    md(`
# Status Code: ${response.status} (${response.statusText})

## ${url} is ${response.ok ? "up" : "down"}
    `)
  )
} catch (error) {
  // Display an error message if the fetch fails 
  await div(md(`# Error: ${error.message}`))
}
```

## Calculate File Hash

```typescript
// Name: Calculate File Hash
// Description: Calculates the SHA-256 hash of a file
// Author: johnlindquist

import "@johnlindquist/kit"
import { createHash } from "crypto"
import { createReadStream } from "fs"

// Prompt for the file path
const filePath = await path()

// Calculate the SHA-256 hash of the file 
const hash = createHash("sha256")
const stream = createReadStream(filePath) 

stream.on("data", data => hash.update(data)) 
stream.on("end", () => { 
  const fileHash = hash.digest("hex")
  console.log(`SHA-256 hash of ${filePath}: ${fileHash}`) 
}) 
```

 

## Extract Text from PDF and Summarize

```typescript
// Name: PDF Summarizer
// Description: Extracts text from a PDF file and summarizes it using OpenAI
// Author: johnlindquist

import "@johnlindquist/kit"
import { PDFExtract } from "pdf.js-extract"

// Get OpenAI API key from environment
// https://platform.openai.com/account/api-keys
const openaiApiKey = await env("OPENAI_API_KEY")

// Prompt for PDF file path
const pdfFilePath = await path({
  hint: "Select a PDF file",
})

// Extract text from the PDF file
const pdfExtract = new PDFExtract()
const data = await pdfExtract.extract(pdfFilePath, {})

// Join the extracted text from all pages
const extractedText = data.pages
  .map(page => page.content.map(c => c.str).join(" "))
  .join(" ")

// Summarize the extracted text using OpenAI API
const response = await post(
  "https://api.openai.com/v1/completions",
  {
    model: "text-davinci-003",
    prompt: `Summarize this text:\n\n${extractedText}`,
    temperature: 0.7,
    max_tokens: 200,
  },
  {
    headers: {
      Authorization: `Bearer ${openaiApiKey}`,
      "Content-Type": "application/json",
    },
  }
)
const summary = response.data.choices[0].text.trim()

// Display the summary in the editor
await editor(summary)
```

## Check GitHub Repository for Updates

```typescript
// Name: GitHub Repo Update Checker
// Description: Checks if a GitHub repository has new commits since the last check
// Author: johnlindquist

import "@johnlindquist/kit"
import { Octokit } from "@octokit/rest"

// Get GitHub token from environment
// https://github.com/settings/tokens
const githubToken = await env("GITHUB_TOKEN")

// Initialize GitHub API client
const octokit = new Octokit({ auth: githubToken })

// Prompt for repository name 
const repoName = await arg({
  placeholder: "Enter repository name (e.g., 'johnlindquist/kit'):",
})

// Split repository name into owner and repo
const [owner, repo] = repoName.split("/")

// Retrieve the latest commit SHA
const { data: commits } = await octokit.repos.listCommits({
  owner,
  repo,
  per_page: 1,
})

const latestCommitSha = commits[0].sha

// Get stored last checked SHA from the database
let lastCheckedSha = await db(repoName, { lastCheckedSha: "" })
  .then(db => db.lastCheckedSha)
  .catch(() => "")

// Check if there are new commits
if (latestCommitSha !== lastCheckedSha) {
  // Display a notification and update the last checked SHA in the database 
  await notify({
    title: "New Commits",
    message: `Repository ${repoName} has new commits.`,
  })

  lastCheckedSha = latestCommitSha
  await db(repoName, { lastCheckedSha })
    .then(async db => {
      db.lastCheckedSha = lastCheckedSha
      await db.write()
    })
    .catch(error => {
      console.error(`Error writing to database: ${error.message}`) 
    })
} else { 
  // Display a message indicating no new commits
  await div(md(`# No New Commits 

Repository ${repoName} is up to date.`)) 
}
```

## Generate Shortened URL with Bitly

```typescript
// Name: Shorten URL with Bitly
// Description: Shortens a URL using the Bitly API
// Author: johnlindquist

import "@johnlindquist/kit" 

// Get the Bitly access token from the environment 
// https://app.bitly.com/settings/api/
const bitlyAccessToken = await env("BITLY_ACCESS_TOKEN");

// Prompt for a URL to shorten 
const longUrl = await arg({
  placeholder: "Enter URL to shorten:"
})

// Create the request body
const requestBody = {
  long_url: longUrl, 
  domain: "bit.ly", // or your custom Bitly domain 
}; 

// Shorten the URL using the Bitly API
const response = await post(
  "https://api-ssl.bitly.com/v4/shorten", 
  requestBody, 
  {
    headers: {
      Authorization: `Bearer ${bitlyAccessToken}`, 
      "Content-Type": "application/json",
    },
  }
);

// Extract and display the shortened URL
const shortUrl = response.data.link

await div(md(`# Shortened URL:\n\n[${shortUrl}](${shortUrl})`))
```

## Create New File with Content

```typescript
// Name: Create File with Content
// Description: Creates a new file with the specified content
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the file name
const fileName = await arg("Enter file name:")

// Prompt for the file content using the editor
const fileContent = await editor({
  placeholder: "Enter file content:",
})

// Write the content to the file
await writeFile(fileName, fileContent); 

console.log(`File "${fileName}" created with content.`)
```

## Convert Text to Title Case

```typescript
// Name: Title Case Converter
// Description: Converts text to title case
// Author: johnlindquist

import "@johnlindquist/kit"
import { titleCase } from "title-case";

// Get the text from the clipboard
const text = await paste()

// Convert to title case 
const titleCasedText = titleCase(text)

// Set the selected text to the title-cased version 
await setSelectedText(titleCasedText)

console.log(`Converted text to title case: ${titleCasedText}`)
```

## Generate Random Quote and Speak It

```typescript
// Name: Random Quote Speaker
// Description: Retrieves a random quote and speaks it
// Author: johnlindquist

import "@johnlindquist/kit"

// Fetch a random quote from the Quotable API 
const response = await get("https://api.quotable.io/random")

// Extract the quote text and author
const { content, author } = response.data 

// Speak the quote
say(`${content}, by ${author}`) 

// Display the quote in a div 
await div(md(`> ${content}\n\n- ${author}`))
```

## Create Event on Google Calendar

```typescript
// Name: Create Google Calendar Event
// Description: Creates an event on your Google Calendar
// Author: johnlindquist

import "@johnlindquist/kit"
import { google } from "googleapis";

// Get the Google Calendar API credentials from the environment
// https://developers.google.com/calendar/api/quickstart/nodejs
const googleCalendarCredentials = JSON.parse(await env("GOOGLE_CALENDAR_CREDENTIALS"))
// Authorize with the Google Calendar API
const auth = new google.auth.GoogleAuth({
  credentials: googleCalendarCredentials,
  scopes: ["https://www.googleapis.com/auth/calendar"],
}) 
const calendar = google.calendar({ version: "v3", auth }); 

// Prompt for event details
const eventSummary = await arg("Enter event summary:");
const eventStartTime = await arg("Enter event start time (YYYY-MM-DDTHH:mm:ss):");
const eventEndTime = await arg("Enter event end time (YYYY-MM-DDTHH:mm:ss):"); 

// Create the event object
const event = {
  summary: eventSummary, 
  start: {
    dateTime: eventStartTime, 
  },
  end: {
    dateTime: eventEndTime, 
  }, 
};

// Insert the event into the user's primary calendar
await calendar.events.insert({
  calendarId: "primary",
  requestBody: event, 
}); 

console.log("Event created successfully on your Google Calendar.")
```
## Check and Update Node Version

```typescript
// Name: Node Version Manager
// Description: Checks current Node.js version and allows updating to the latest LTS version
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the current Node.js version
const currentNodeVersion = process.version

// Prompt the user to check if they want to update to the latest LTS version
const shouldUpdate = await arg(
  `Current Node.js version: ${currentNodeVersion}\nUpdate to latest LTS?`,
  [
    { name: "Yes", value: true },
    { name: "No", value: false },
  ]
)

if (shouldUpdate) {
  // Display a terminal with the update command
  await term({
    command: "nvm install --lts",
    cwd: home(),
    height: 140,
    enter: "Exit",
    shortcuts: [],
  })
}

exit()
```

## Create a New GitHub Repository

```typescript
// Name: Create GitHub Repository
// Description: Creates a new repository on GitHub
// Author: johnlindquist

import "@johnlindquist/kit"

import { Octokit } from "@octokit/rest"

// Get the GitHub API token from the environment
// https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token
const githubToken = await env("GITHUB_TOKEN")

// Initialize GitHub API client
const octokit = new Octokit({ auth: githubToken })

// Prompt for the repository name
const repoName = await arg("Enter repository name:")

// Prompt for the repository description
const repoDescription = await arg("Enter repository description:")

// Prompt for repository visibility
const isPublic = await arg("Public repository?", [
  { name: "Yes", value: true },
  { name: "No", value: false },
])

// Create the repository on GitHub
await octokit.repos.createForAuthenticatedUser({
  name: repoName,
  description: repoDescription,
  private: !isPublic,
})

console.log(`Repository ${repoName} created successfully.`)
```

## Convert Image to WebP

```typescript
// Name: Convert Image to WebP
// Description: Converts an image to WebP format
// Author: johnlindquist

import "@johnlindquist/kit"
import sharp from "sharp"

// Prompt for the image path
let imagePath = await path({
  hint: "Select an image to convert",
})

// Convert the image to WebP format using Sharp
const webpImage = await sharp(imagePath)
  .webp({ quality: 80 }) // Adjust quality as needed
  .toBuffer()

// Create a new file path with the .webp extension
const webpFilePath = imagePath.replace(/\.[^/.]+$/, ".webp")

// Write the WebP image data to the file
await writeFile(webpFilePath, webpImage)

console.log(`Image converted to WebP: ${webpFilePath}`)
```

## Create and Edit a Markdown File

```typescript
// Name: Create Markdown Note
// Description: Creates a new Markdown file and opens it in the editor
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the file name 
const fileName = await arg("Enter file name:")

// Create the file with default content 
await writeFile(fileName, `# ${fileName}\n\n`) 

// Open the file in the editor
await editor({
  file: fileName,
  language: "markdown",
})
```

## Generate and Display Random Joke

```typescript
// Name: Random Joke 
// Description: Retrieves a random joke from an API and displays it 
// Author: johnlindquist

import "@johnlindquist/kit"

// Fetch a random joke from the JokeAPI
const response = await get("https://v2.jokeapi.dev/joke/Any?safe-mode") 

// Extract the joke setup and delivery (if applicable)
const { setup, delivery, joke } = response.data 

// Construct the joke string
const jokeText = setup ? `${setup}\n\n${delivery}` : joke

// Display the joke in a div prompt 
await div(md(`# ${jokeText}`)) 
```

## Get Current Location's Time Zone

```typescript
// Name: Get Time Zone
// Description: Gets the time zone of the current location
// Author: johnlindquist

import "@johnlindquist/kit"
import { DateTime } from "luxon"

// Get the current time zone using Luxon
const timeZone = DateTime.now().zoneName

// Display the time zone 
await div(md(`# Current Time Zone:\n\n${timeZone}`))
```

## Convert Timestamp to Date

```typescript
// Name: Timestamp to Date 
// Description: Converts a Unix timestamp to a human-readable date
// Author: johnlindquist

import "@johnlindquist/kit"
import { DateTime } from "luxon"

// Prompt for a Unix timestamp
const timestamp = await arg("Enter a Unix timestamp:")

// Convert the timestamp to a Date object
const date = DateTime.fromSeconds(parseInt(timestamp, 10))

// Format and display the date 
await div(md(`# ${date.toLocaleString(DateTime.DATE_HUGE)}`)) 
```


## Get Stock Price 

```typescript
// Name: Get Stock Price
// Description: Fetches and displays the current stock price for a given symbol
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the Financial Modeling Prep API key from the environment 
// https://site.financialmodelingprep.com/developer/docs/
const fmpApiKey = await env("FMP_API_KEY");

// Prompt for a stock symbol
let stockSymbol = await arg("Enter stock symbol:") 

// Fetch stock price from the API 
const response = await get(
  `https://financialmodelingprep.com/api/v3/quote-short/${stockSymbol}?apikey=${fmpApiKey}`
) 

// Extract and display the price
const price = response.data[0].price 

await div(md(`# Current price of ${stockSymbol}: $${price}`))
```

## Check Spelling of Selected Text

```typescript
// Name: Spell Check Selection
// Description: Checks the spelling of the selected text and provides suggestions 
// Author: johnlindquist

import "@johnlindquist/kit"
import SpellChecker from "simple-spellchecker"

// Prompt for the language 
const language = await arg("Enter language (e.g., 'en-US'):") 

// Get the selected text
const selectedText = await getSelectedText(); 

// Load the dictionary for the selected language 
const dictionary = await new Promise((resolve, reject) => {
  SpellChecker.getDictionary(language, (err, dictionary) => {
    if (err) {
      reject(err) 
    } else {
      resolve(dictionary)
    }
  }) 
}) 

// Find misspelled words and get suggestions 
const misspelledWords = selectedText.split(" ").filter(word => {
  // Check if the word is spelled correctly 
  return !dictionary.spellCheck(word);
});

if (misspelledWords.length > 0) {
  // Create choices with suggestions for each misspelled word 
  const choices = misspelledWords.map(word => ({ 
    name: `Misspelled: ${word}`,
    // Get spelling suggestions for the misspelled word 
    choices: dictionary.getSuggestions(word), 
  })) 

  // Display the misspelled words and suggestions 
  await arg("Misspelled words:", choices) 
} else {
  // Display a message if no misspelled words are found 
  await div(md("# No misspelled words found!"))
}
```

## Compress Images in a Directory

```typescript
// Name: Compress Images
// Description: Compresses images in a selected directory using Sharp
// Author: johnlindquist

import "@johnlindquist/kit"
import sharp from "sharp"
import { globby } from "globby"

// Prompt for the directory path
const directoryPath = await path({
  hint: "Select directory containing images:",
  onlyDirs: true,
})

// Get all image files in the directory
const imageFiles = await globby([
  `${directoryPath}/*.jpg`,
  `${directoryPath}/*.jpeg`,
  `${directoryPath}/*.png`, 
], {
  expandDirectories: {
    extensions: ["jpg", "jpeg", "png"],
  },
})

// Compress each image file 
for (const file of imageFiles) {
  const compressedImageBuffer = await sharp(file) 
    .jpeg({ quality: 80 }) // Adjust quality as needed 
    .toBuffer()

  // Overwrite the original file with the compressed image
  await writeFile(file, compressedImageBuffer)

  console.log(`Compressed: ${file}`) 
}
console.log("All images compressed.") 
```

## Convert YouTube Video to MP3

```typescript
// Name: YouTube to MP3 Converter
// Description: Converts a YouTube video to an MP3 audio file
// Author: johnlindquist

import "@johnlindquist/kit"
import ytdl from "ytdl-core"
import { PassThrough } from "stream";

// Prompt for the YouTube video URL
let youtubeUrl = await arg({
  placeholder: "Enter YouTube video URL:",
})

// Get the video info
const info = await ytdl.getInfo(youtubeUrl)

// Ask the user to pick an audio format
let format = await arg(
  "Select audio format:",
  info.formats
    .filter(f => f.hasAudio && !f.hasVideo)
    .map(f => ({
      name: `${f.audioQuality} (${f.audioBitrate}kbps)`,
      value: f,
    }))
)

// Create a readable stream from the selected audio format
const audioStream = ytdl.downloadFromInfo(info, {
  format,
})

// Use PassThrough to fix stream piping on Windows
let passThroughStream = new PassThrough()
audioStream.pipe(passThroughStream)

// Set the output file path 
const outputPath = tmpPath(`${info.videoDetails.title}.mp3`) 

// Execute FFmpeg to convert and save the audio
await execa(
  "ffmpeg",
  [
    "-i",
    "-", // Input from stdin
    "-vn", // Disable video 
    "-acodec",
    "libmp3lame",
    "-ab",
    "192k", // Set audio bitrate 
    outputPath, // Output file path
  ], 
  {
    input: passThroughStream,
  }
)

console.log(`YouTube video converted to MP3: ${outputPath}`)
```

##  Send a Message to Slack

```typescript
// Name: Send Slack Message
// Description: Sends a message to a Slack channel
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the Slack webhook URL from the environment
// https://api.slack.com/messaging/webhooks
const slackWebhookUrl = await env("SLACK_WEBHOOK_URL")

// Prompt for the channel name 
const channel = await arg("Enter Slack channel name (e.g., '#general'):")

// Prompt for the message content
const message = await arg("Enter your message:")

// Send the message to Slack 
await post(slackWebhookUrl, {
  channel,
  text: message, 
})

console.log(`Message sent to Slack channel ${channel}.`)
```

## Create and Share a GitHub Gist

```typescript
// Name: Create and Share Gist
// Description: Creates a new Gist on GitHub and copies the URL to the clipboard
// Author: johnlindquist

import "@johnlindquist/kit"
import { Octokit } from "@octokit/rest"

// Get the GitHub API token from the environment
// https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token
const githubToken = await env("GITHUB_TOKEN") 

// Initialize GitHub API client
const octokit = new Octokit({ auth: githubToken }) 

// Prompt for the file name 
const fileName = await arg("Enter file name:") 

// Prompt for the file content
const fileContent = await editor({
  placeholder: "Enter file content:"
}) 

// Create the Gist on GitHub 
const gist = await octokit.gists.create({
  files: {
    [fileName]: {
      content: fileContent,
    },
  },
  public: true, // Make the Gist public
});

// Copy the Gist URL to the clipboard 
copy(gist.data.html_url)

console.log("Gist created and URL copied to clipboard.")
```

## Generate a Random Password and Save to 1Password

```typescript
// Name: Generate Password and Save to 1Password 
// Description: Generates a random password and saves it to 1Password 
// Author: johnlindquist

import "@johnlindquist/kit"
import { generate } from "generate-password";
import opn from "opn";

// Prompt for the website or service name
const website = await arg("Enter website or service name:")

// Generate a random password 
const password = generate({ 
  length: 20,
  numbers: true,
  symbols: true, 
  uppercase: true,
  lowercase: true,
  excludeSimilarCharacters: true, 
});

// Copy the generated password to the clipboard
await copy(password);

// Construct the 1Password URL scheme 
const opnUrl = `op://add/password/${website}/${password}`
 
// Open the 1Password URL to initiate saving the password 
await opn(opnUrl); 

console.log(
  `Password generated, copied to clipboard, and 1Password URL opened.`
)
``` 

## Search and Open Google Maps Location

```typescript
// Name: Search Google Maps
// Description: Searches for a location on Google Maps and opens it in the browser
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the location to search for 
const location = await arg("Enter a location:")

// Construct the Google Maps URL
const mapsUrl = `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(location)}`

// Open the URL in the browser
open(mapsUrl) 
```

## Convert Image to ASCII Art

```typescript
// Name: Image to ASCII Art
// Description: Converts an image to ASCII art
// Author: johnlindquist

import "@johnlindquist/kit"
import Jimp from "jimp"

// Prompt for the image path
const imagePath = await path({
  hint: "Select an image file",
})

// Read the image using Jimp
const image = await Jimp.read(imagePath);

// Convert the image to ASCII art 
const asciiArt = await image.resize(80, Jimp.AUTO).getBufferAsync("image/png");

// Display the ASCII art in the editor
await editor(asciiArt.toString()) 
```

## Download a File and Show Progress

```typescript
// Name: Download File with Progress
// Description: Downloads a file from a URL and displays the progress
// Author: johnlindquist

import "@johnlindquist/kit"
import { get, CancelToken } from "axios"

// Prompt for the download URL 
const url = await arg("Enter URL to download:")

// Create a cancel token for the download
const cancelTokenSource = CancelToken.source();

// Function to display download progress
const displayProgress = (progress: number) => {
  const progressBarLength = 20;
  const filledBlocks = Math.round(progress * progressBarLength);
  const emptyBlocks = progressBarLength - filledBlocks;

  // Create a visual progress bar 
  const progressBar = `[${"#".repeat(filledBlocks)}${" ".repeat(emptyBlocks)}] ${Math.round(
    progress * 100
  )}%`

  setPanel(md(`# Downloading...\n\n${progressBar}`))
}

// Download the file with progress updates 
await get(url, {
  responseType: "stream",
  cancelToken: cancelTokenSource.token,
  onDownloadProgress: (progressEvent) => {
    const progress = progressEvent.progress || 0;
    displayProgress(progress)
  },
})
  .then(async (response) => {
    // Set the output file path 
    const fileName = path.basename(url)
    const outputPath = path.join(tmpPath(), fileName)

    // Create a write stream to save the downloaded file
    const writer = createWriteStream(outputPath)

    // Pipe the response data to the writer 
    response.data.pipe(writer)

    // Wait for the download to finish
    await new Promise((resolve, reject) => {
      writer.on("finish", resolve)
      writer.on("error", reject)
    })

    console.log(`File downloaded to: ${outputPath}`) 
  })
  .catch((error) => { 
    if (axios.isCancel(error)) { 
      console.log("Download cancelled.")
    } else {
      console.error("Download error:", error)
    }
  })

```

## Check if Website Uses Google Analytics

```typescript
// Name: Check for Google Analytics
// Description: Checks if a website uses Google Analytics
// Author: johnlindquist

import "@johnlindquist/kit"
import { load } from "cheerio"

// Prompt for the website URL
const url = await arg("Enter website URL:")

try {
  // Fetch the website's HTML
  const response = await get(url);

  // Load the HTML content with Cheerio
  const $ = load(response.data);

  // Search for Google Analytics script tag
  const hasGoogleAnalytics = $("script[src*='google-analytics.com/analytics.js']").length > 0;

  // Display result in a div prompt 
  await div(md(`# ${url} ${hasGoogleAnalytics ? "uses" : "does not use"} Google Analytics.`))
} catch (error) {
  // Display an error message if the fetch fails 
  await div(md(`# Error: ${error.message}`)) 
}
```

## Get System Uptime

```typescript
// Name: System Uptime
// Description: Displays the system uptime
// Author: johnlindquist

import "@johnlindquist/kit"
import os from "os" 

// Get the system uptime in seconds
const uptimeInSeconds = os.uptime() 

// Format the uptime using date-fns
const uptimeString = formatDistanceToNow(new Date(Date.now() - uptimeInSeconds * 1000), {
  addSuffix: true, // Adds "ago" to the end of the string 
})

// Display the formatted uptime in a div
await div(md(`# System Uptime: ${uptimeString}`)) 
```

## Convert Text to Morse Code

```typescript
// Name: Text to Morse Code 
// Description: Converts text to Morse code 
// Author: johnlindquist

import "@johnlindquist/kit"
import morse from "morse-code-converter"

// Prompt for text input
const text = await arg("Enter text:")

// Convert the text to Morse code
const morseCode = morse.textToMorse(text)

// Display the Morse code in the editor
await editor(morseCode)
```

## Get a List of Running Docker Containers

```typescript
// Name: List Docker Containers
// Description: Lists running Docker containers
// Author: johnlindquist

import "@johnlindquist/kit"

// Execute the Docker command to list running containers 
const { stdout } = await exec("docker ps")

// Format the output using markdown
const formattedOutput = md(`
\`\`\` 
${stdout}
\`\`\`
`) 

// Display the formatted output in a div 
await div(formattedOutput)
```
## Generate Password with Strength Checker

```typescript
// Name: Generate Strong Password
// Description: Generates a random password and checks its strength
// Author: johnlindquist

import "@johnlindquist/kit"
import { generate } from "generate-password"
import zxcvbn from "zxcvbn"

// Function to display password strength
async function displayPasswordStrength(password: string) {
  // Calculate password strength using zxcvbn
  const strength = zxcvbn(password)
  // Display the strength score and feedback
  await div(
    md(`# Password Strength: ${strength.score} / 4

## Feedback: ${strength.feedback.warning}
    
${strength.feedback.suggestions.map(s => `- ${s}`).join("\n")}
`)
  )
}

while (true) {
  // Generate a random password
  const password = generate({
    length: 12,
    numbers: true,
    symbols: true,
    uppercase: true,
    lowercase: true,
    excludeSimilarCharacters: true,
  })

  // Display the generated password and its strength
  await arg(
    {
      placeholder: "Password Generator",
      enter: "Accept Password",
      shortcuts: [
        {
          name: "Generate New",
          key: `${cmd}+g`,
          onPress: () => {
            submit("")
          },
          bar: "right",
        },
        {
          name: "Copy to Clipboard",
          key: `${cmd}+c`,
          onPress: async () => {
            await copy(password)
            await toast("Copied to Clipboard!")
          },
          bar: "right",
        },
      ],
    },
    async () => {
      await displayPasswordStrength(password)
      return password
    }
  )
}
```

## Send a Tweet

```typescript
// Name: Send Tweet
// Description: Sends a tweet using the Twitter API
// Author: johnlindquist

import "@johnlindquist/kit"
import Twitter from "twitter-api-v2"

// Get Twitter API keys from the environment
// https://developer.twitter.com/en/portal/dashboard
const twitterConsumerKey = await env("TWITTER_CONSUMER_KEY")
const twitterConsumerSecret = await env(
  "TWITTER_CONSUMER_SECRET"
)
const twitterAccessTokenKey = await env("TWITTER_ACCESS_TOKEN_KEY")
const twitterAccessTokenSecret = await env(
  "TWITTER_ACCESS_TOKEN_SECRET"
)

// Initialize Twitter API client
const twitterClient = new Twitter({
  appKey: twitterConsumerKey,
  appSecret: twitterConsumerSecret,
  accessToken: twitterAccessTokenKey,
  accessSecret: twitterAccessTokenSecret,
})

// Prompt for the tweet content
const tweetContent = await arg("Enter your tweet:")

// Send the tweet
await twitterClient.v2.tweet(tweetContent)

console.log("Tweet sent successfully!")
```

## Resize Image to Fit Dimensions

```typescript
// Name: Resize Image to Fit
// Description: Resizes an image to fit within specified dimensions
// Author: johnlindquist

import "@johnlindquist/kit"
import sharp from "sharp"

// Prompt for the image path
let imagePath = await path({
  hint: "Select an image file",
})

// Prompt for the maximum width
let maxWidth = await arg("Enter maximum width in pixels:")

// Prompt for the maximum height
let maxHeight = await arg("Enter maximum height in pixels:")

// Resize the image using sharp, fitting within the specified dimensions
const resizedImage = await sharp(imagePath)
  .resize(parseInt(maxWidth), parseInt(maxHeight), {
    fit: "inside", // Ensures the image fits within the dimensions without cropping
  })
  .toBuffer()

// Overwrite the original file with the resized image
await writeFile(imagePath, resizedImage)

console.log(`Image resized to fit within ${maxWidth}x${maxHeight} pixels.`)
```

## Create and Send a WhatsApp Message

```typescript
// Name: Send WhatsApp Message
// Description: Sends a message to a WhatsApp contact
// Author: johnlindquist

import "@johnlindquist/kit"
import qrcode from "qrcode-terminal";
import { Client, LocalAuth } from "whatsapp-web.js"

// Initialize WhatsApp client with local authentication
const client = new Client({
  authStrategy: new LocalAuth()
})

// Generate QR code for authentication
client.on("qr", qr => {
  qrcode.generate(qr, { small: true })
})

// Log when the client is ready
client.on("ready", () => {
  console.log("Client is ready!")
})

// Initialize the client
client.initialize()

// Prompt for the recipient's phone number
const phoneNumber = await arg(
  "Enter recipient's phone number (with country code):"
)

// Prompt for the message content
const message = await arg("Enter your message:")

// Send the message
client.sendMessage(`${phoneNumber}@c.us`, message)

console.log(
  `Message "${message}" sent to WhatsApp contact ${phoneNumber}.`
)
```

## Convert Text to Audio with Amazon Polly

```typescript
// Name: Text to Speech (Amazon Polly)
// Description: Converts text to speech using Amazon Polly
// Author: johnlindquist

import "@johnlindquist/kit"
import AWS from "aws-sdk"

// Get the AWS credentials from the environment
// https://docs.aws.amazon.com/sdk-for-javascript/v2/developer-guide/getting-started-nodejs.html
const awsAccessKeyId = await env("AWS_ACCESS_KEY_ID")
const awsSecretAccessKey = await env("AWS_SECRET_ACCESS_KEY")

// Prompt for text to convert to speech
const inputText = await arg("Enter text:")

// Configure AWS SDK
AWS.config.update({
  accessKeyId: awsAccessKeyId,
  secretAccessKey: awsSecretAccessKey,
  region: "us-east-1", // Replace with your desired AWS region 
}) 

// Create an instance of Amazon Polly
const polly = new AWS.Polly()

// Define the parameters for text-to-speech conversion
const params = {
  OutputFormat: "mp3",
  Text: inputText,
  VoiceId: "Joanna", // Replace with your desired voice ID
}

// Convert the text to speech
polly.synthesizeSpeech(params, (err, data) => { 
  if (err) {
    console.error(err)
  } else {
    // Save the audio data as an MP3 file
    const audioFilePath = tmpPath("speech.mp3")
    const audioBuffer = data.AudioStream as Buffer;
    writeFile(audioFilePath, audioBuffer) 

    // Play the generated speech
    playAudioFile(audioFilePath)
  }
})
```

## Create a New Trello Card

```typescript
// Name: Create Trello Card
// Description: Creates a new card on a Trello board
// Author: johnlindquist

import "@johnlindquist/kit" 

// Get the Trello API key and token from the environment 
// https://developer.atlassian.com/cloud/trello/guides/rest-api/authorization/
const trelloApiKey = await env("TRELLO_API_KEY") 
const trelloToken = await env("TRELLO_TOKEN") 

// Prompt for the board ID 
const boardId = await arg({
  placeholder: "Enter Trello board ID:",
}) 

// Prompt for the list ID 
const listId = await arg({
  placeholder: "Enter Trello list ID:",
}) 

// Prompt for the card name
const cardName = await arg("Enter card name:")

// Create the card on Trello 
const response = await post(
  `https://api.trello.com/1/cards?key=${trelloApiKey}&token=${trelloToken}`, 
  { 
    idList: listId,
    name: cardName,
  }
)

console.log("Trello card created successfully.")
```

## Get Current Exchange Rate

```typescript
// Name: Get Exchange Rate
// Description: Gets the current exchange rate between two currencies
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the base currency
const baseCurrency = await arg({
  placeholder: "Enter base currency (e.g., USD):",
  hint: "Use three-letter currency codes",
})

// Prompt for the target currency
const targetCurrency = await arg({
  placeholder: "Enter target currency (e.g., EUR):",
  hint: "Use three-letter currency codes",
})

// Fetch exchange rate data from the ExchangeRate-API 
const response = await get(
  `https://v6.exchangerate-api.com/v6/${await env(
    "EXCHANGERATE_API_KEY"
  )}/latest/${baseCurrency}`
) 

// Extract and display the exchange rate 
const exchangeRate = response.data.conversion_rates[targetCurrency] 

await div(
  md(`
# 1 ${baseCurrency} = ${exchangeRate} ${targetCurrency}
`)
)
```


##  Create a New Meeting in Zoom

```typescript
// Name: Schedule Zoom Meeting 
// Description: Creates a new Zoom meeting and copies the join link to the clipboard
// Author: johnlindquist

import "@johnlindquist/kit";
import { Zoom } from "@zoomus/websdk";

// Get the Zoom API key and secret from the environment
// https://marketplace.zoom.us/docs/guides/build/jwt-app
const zoomApiKey = await env("ZOOM_API_KEY");
const zoomApiSecret = await env("ZOOM_API_SECRET");

// Initialize the Zoom client
const zoom = new Zoom({
  apiKey: zoomApiKey,
  apiSecret: zoomApiSecret,
});

// Prompt for meeting details
const meetingTopic = await arg("Enter meeting topic:")
const meetingDuration = parseInt(
  await arg("Enter meeting duration (minutes):"),
  10
)

// Create the Zoom meeting
const { join_url } = await zoom.meetings.create({
  topic: meetingTopic,
  type: 1, // Instant meeting 
  duration: meetingDuration,
});

// Copy the meeting join URL to the clipboard
await copy(join_url);

// Display confirmation message
await div(md(`# Zoom Meeting Created

The join link has been copied to your clipboard:

[${join_url}](${join_url})
`))
```

## Create and Publish a New Gist 

```typescript
// Name: Create and Publish Gist
// Description: Creates and publishes a new GitHub Gist 
// Author: johnlindquist 

import "@johnlindquist/kit" 
import { Octokit } from "@octokit/rest"

// Get the GitHub API token from the environment 
// https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token 
const githubToken = await env("GITHUB_TOKEN");

// Initialize the GitHub API client
const octokit = new Octokit({ auth: githubToken }); 

// Prompt for the file name
const fileName = await arg("Enter file name:")

// Prompt for the file content
const fileContent = await editor({
  placeholder: "Enter file content:",
});

// Prompt for the Gist description
const description = await arg({
  placeholder: "Enter a description for the Gist:"
}); 

// Create the Gist on GitHub 
const { data: gist } = await octokit.gists.create({
  files: {
    [fileName]: {
      content: fileContent,
    },
  },
  public: true,
  description, 
}); 

// Open the created Gist in the browser
await open(gist.html_url);

console.log(`Gist created and opened in browser: ${gist.html_url}`)
```

## Check Current Weather and Display Forecast

```typescript
// Name: Weather Forecast
// Description: Retrieves and displays the current weather and forecast for a location 
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the OpenWeatherMap API key from the environment 
// https://openweathermap.org/api
const openWeatherMapApiKey = await env("OPENWEATHERMAP_API_KEY"); 

// Prompt for the location
let location = await arg("Enter location:") 

// Fetch weather data from the API 
const currentWeatherResponse = await get( 
  `https://api.openweathermap.org/data/2.5/weather?q=${location}&appid=${openWeatherMapApiKey}&units=metric`
);

const { coord } = currentWeatherResponse.data;

// Fetch the forecast for the location using the coordinates
const forecastResponse = await get( 
  `https://api.openweathermap.org/data/2.5/onecall?lat=${coord.lat}&lon=${coord.lon}&appid=${openWeatherMapApiKey}&exclude=current,minutely,hourly,alerts&units=metric`
) 

// Extract relevant data from the forecast response
const forecastData = forecastResponse.data.daily

// Create an array of forecast items for the next 5 days 
let forecastChoices = forecastData.slice(0, 5).map((day, index) => ({
  name: `Day ${index + 1}: ${new Date(day.dt * 1000).toLocaleDateString()}`,
  // Include relevant weather information for the day in the choice
  description: `Temperature: ${day.temp.day}Â°C, Feels like: ${day.feels_like.day}Â°C, Condition: ${day.weather[0].description}`,
  value: day,
}))

// Display the choices to the user 
let selectedForecast = await arg("Select a day to view details:", forecastChoices)

// Display detailed forecast information in a div
await div(md(`
## Detailed Forecast for ${new Date(selectedForecast.dt * 1000).toLocaleDateString()}

* Temperature:
    * Day: ${selectedForecast.temp.day}Â°C
    * Night: ${selectedForecast.temp.night}Â°C
    * High: ${selectedForecast.temp.max}Â°C
    * Low: ${selectedForecast.temp.min}Â°C
* Feels like:
    * Day: ${selectedForecast.feels_like.day}Â°C
    * Night: ${selectedForecast.feels_like.night}Â°C
* Condition: ${selectedForecast.weather[0].description}
* Humidity: ${selectedForecast.humidity}%
* Wind Speed: ${selectedForecast.wind_speed} m/s
* UV Index: ${selectedForecast.uvi}
`))
```

## Compress PDF File

```typescript
// Name: Compress PDF
// Description: Compresses a PDF file using Ghostscript
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the PDF file path
const pdfFilePath = await path({
  hint: "Select a PDF file",
})

// Define the output file path for the compressed PDF
const compressedFilePath = pdfFilePath.replace(
  /\.pdf$/i,
  "-compressed.pdf"
)

// Execute the Ghostscript command to compress the PDF
await exec(
  `gs -sDEVICE=pdfwrite -dCompatibilityLevel=1.4 -dPDFSETTINGS=/screen -dNOPAUSE -dQUIET -dBATCH -sOutputFile="${compressedFilePath}" "${pdfFilePath}"`
)

// Reveal the compressed PDF file in Finder 
await revealFile(compressedFilePath)
```

## Get Directions Using Apple Maps

```typescript
// Name: Get Directions (Apple Maps)
// Description: Gets directions from current location to a destination using Apple Maps
// Author: johnlindquist 

import "@johnlindquist/kit"

// Prompt for the destination address
const destination = await arg("Enter destination:") 

// Construct the Apple Maps URL scheme
const mapsUrl = `maps://?daddr=${encodeURIComponent(destination)}` 

// Open the URL in Apple Maps
open(mapsUrl)
```

## Scan Network for Devices

```typescript
// Name: Network Scanner 
// Description: Scans the local network for connected devices
// Author: johnlindquist

import "@johnlindquist/kit"
import { networkInterfaces } from "os";

// Get the local network interfaces
const interfaces = networkInterfaces()

// Iterate over the interfaces and display IP addresses 
for (const interfaceName in interfaces) {
  const addresses = interfaces[interfaceName] 
  for (const address of addresses) {
    // Only display IPv4 addresses
    if (address.family === "IPv4") {
      console.log(`Interface: ${interfaceName}, IP: ${address.address}`) 
    } 
  }
}

// Scan the network using nmap
await term({ 
  command: "nmap -T4 -F 192.168.1.0/24", // Replace with your network range
  shortcuts: [],
})
```

## Clean Up Downloads Directory

```typescript
// Name: Downloads Cleanup 
// Description: Cleans up the Downloads directory based on file age 
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt for the maximum age of files to keep (in days)
const maxAgeInDays = parseInt(await arg("Enter maximum age of files to keep (in days):"))

// Get the current timestamp 
const now = Date.now() 

// Iterate through files in the Downloads directory
for await (const file of await readdir(home("Downloads"))) {
  // Get the file's stats 
  const stats = await stat(path.join(home("Downloads"), file))

  // Calculate the file's age in days
  const fileAgeInDays = (now - stats.mtimeMs) / (1000 * 60 * 60 * 24) 

  // If the file is older than the maximum age, move it to the trash 
  if (fileAgeInDays > maxAgeInDays) {
    await trash(path.join(home("Downloads"), file)) 
    console.log(`Trashed: ${file}`)
  }
}

console.log(`Downloads directory cleaned up.`)
```

## Search DuckDuckGo and Display Results

```typescript
// Name: DuckDuckGo Search
// Description: Searches DuckDuckGo and displays the top results 
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for a search query 
const query = await arg("Enter your search query:")

// Fetch search results from the DuckDuckGo Instant Answer API
const response = await get(
  `https://api.duckduckgo.com/?q=${encodeURIComponent(
    query
  )}&format=json`
)

// Extract relevant data from the response 
const { Abstract, RelatedTopics } = response.data

// Display the abstract and related topics 
await div(md(`
# ${Abstract || "No abstract found"}

## Related Topics:

${RelatedTopics
  .map(topic => `- [${topic.Text}](${topic.FirstURL})`)
  .join("\n")}
`))
```


## Find and Replace in Clipboard

```typescript
// Name: Find and Replace Clipboard
// Description: Finds and replaces text in the clipboard
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the text from the clipboard
const clipboardText = await paste() 

// Prompt for the text to find
const findText = await arg("Enter text to find:")

// Prompt for the replacement text
const replaceText = await arg("Enter replacement text:") 

// Perform the replacement
const newClipboardText = clipboardText.replaceAll(findText, replaceText) 

// Copy the updated text to the clipboard
await copy(newClipboardText)

console.log("Clipboard text updated.")
```

## Check for Broken Links in a Markdown File

```typescript
// Name: Broken Link Checker (Markdown)
// Description: Checks for broken links in a Markdown file
// Author: johnlindquist

import "@johnlindquist/kit"
import { load } from "cheerio"

// Prompt for the Markdown file path 
const filePath = await path({
  hint: "Select a Markdown file", 
})

// Read the Markdown file
const markdownContent = await readFile(filePath, "utf-8")

// Load the Markdown content using Cheerio 
const $ = load(markdownContent)

// Get all links from the Markdown
const links = $("a").map((i, el) => $(el).attr("href")).get()

// Check each link for validity
for await (const link of links) { 
  try {
    // Attempt to fetch the link
    const response = await fetch(link)
    // Log the status code if successful
    console.log(`Status ${response.status} - ${link}`)
  } catch (error) {
    // Display an error message if the link is broken
    await div(md(`## Broken link found! ðŸ’€\n\n${link}`))
  }
}

console.log(`Finished checking for broken links in ${filePath}`)
```

## Generate Color Palette from Image

```typescript
// Name: Generate Color Palette
// Description: Generates a color palette from an image using Vibrant.js
// Author: johnlindquist

import "@johnlindquist/kit"
import Vibrant from "node-vibrant"

// Prompt for the image path 
const imagePath = await path({
  hint: "Select an image file"
}) 

// Generate a color palette using Vibrant.js
const palette = await Vibrant.from(imagePath).getPalette()

// Extract the prominent colors 
const { Vibrant, Muted, DarkVibrant, LightVibrant } = palette; 

// Display color swatches in a div 
await div(`
<div class="grid grid-cols-4 gap-2 p-4"> 
  <div style="background-color: ${Vibrant?.hex};" class="w-16 h-16"></div>
  <div style="background-color: ${Muted?.hex};" class="w-16 h-16"></div>
  <div style="background-color: ${DarkVibrant?.hex};" class="w-16 h-16"></div>
  <div style="background-color: ${LightVibrant?.hex};" class="w-16 h-16"></div>
</div>
`)
```

##  Resize Images in Bulk

```typescript
// Name: Bulk Image Resizer 
// Description: Resizes multiple images in a directory
// Author: johnlindquist

import "@johnlindquist/kit"
import { globby } from "globby";
import sharp from "sharp";

// Prompt for directory containing images
const directoryPath = await path({
  hint: "Select directory containing images:",
  onlyDirs: true,
}) 

// Get all image files in the directory
const imageFiles = await globby([
  `${directoryPath}/*.jpg`,
  `${directoryPath}/*.jpeg`,
  `${directoryPath}/*.png`,
], {
  expandDirectories: {
    extensions: ["jpg", "jpeg", "png"],
  }, 
});

// Prompt for the new width
const newWidth = parseInt(await arg("Enter new width in pixels:"));

// Resize each image and overwrite the original file 
for (const file of imageFiles) {
  await sharp(file)
    .resize({ width: newWidth })
    .toFile(file);

  console.log(`Resized: ${file}`)
} 

console.log("All images resized.") 
```

## Send a Text Message with Twilio

```typescript
// Name: Send Text Message
// Description: Sends a text message using the Twilio API 
// Author: johnlindquist

import "@johnlindquist/kit"
import twilio from "twilio"

// Get the Twilio credentials from the environment
// https://www.twilio.com/console
const twilioAccountSid = await env("TWILIO_ACCOUNT_SID");
const twilioAuthToken = await env("TWILIO_AUTH_TOKEN"); 

// Prompt for the recipient's phone number 
const toPhoneNumber = await arg("Enter recipient's phone number:")

// Prompt for the message
const message = await arg("Enter message:")

// Initialize Twilio client
const client = twilio(twilioAccountSid, twilioAuthToken)

// Send the text message
await client.messages.create({
  body: message, 
  from: await env("TWILIO_PHONE_NUMBER"), // Your Twilio phone number
  to: toPhoneNumber,
})

console.log(`Text message sent to ${toPhoneNumber}`)
```

## Create a New Google Doc

```typescript
// Name: Create Google Doc
// Description: Creates a new Google Doc and opens it in the browser 
// Author: johnlindquist

import "@johnlindquist/kit"
import { google } from "googleapis";

// Get Google Docs API credentials from the environment 
// https://developers.google.com/docs/api/quickstart/nodejs 
const googleDocsCredentials = JSON.parse(await env("GOOGLE_DOCS_CREDENTIALS"));
// Authorize with the Google Docs API
const auth = new google.auth.GoogleAuth({
  credentials: googleDocsCredentials,
  scopes: ["https://www.googleapis.com/auth/documents"], 
});
const docs = google.docs({ version: "v1", auth });

// Create a new Google Doc 
const { data: newDoc } = await docs.documents.create({
  requestBody: {
    title: await arg("Enter document title:"), // Prompt for the document title
  },
});

// Open the newly created document in the browser 
await open(newDoc.documentId);

console.log(`New Google Doc created: ${newDoc.documentId}`) 
```

## Convert Video to GIF 

```typescript
// Name: Convert Video to GIF
// Description: Converts a video to a GIF using FFmpeg
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the video file path 
const videoPath = await path({
  hint: "Select a video file",
}) 

// Define the output file path for the GIF
const outputPath = videoPath.replace(/\.[^/.]+$/, ".gif") 

// Execute FFmpeg command to convert the video to a GIF 
await execa("ffmpeg", [ 
  "-i", 
  videoPath, 
  "-vf",
  "fps=10,scale=320:-1:flags=lanczos", // Adjust frame rate and size as needed 
  "-loop",
  "0", 
  outputPath, 
]);

// Reveal the generated GIF in Finder
await revealFile(outputPath)
```



## Create a New Task in Asana

```typescript
// Name: Create Asana Task
// Description: Creates a new task in Asana
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the Asana API token from the environment
// https://developers.asana.com/docs/personal-access-token
const asanaToken = await env("ASANA_TOKEN")

// Prompt for the workspace ID
const workspaceId = await arg("Enter Asana workspace ID:")

// Prompt for the project ID
const projectId = await arg("Enter Asana project ID:")

// Prompt for the task name
const taskName = await arg("Enter task name:") 

// Create the task in Asana
const response = await post( 
  `https://app.asana.com/api/1.0/tasks`, 
  {
    data: { 
      workspace: workspaceId,
      projects: [projectId],
      name: taskName,
    },
  },
  {
    headers: {
      Authorization: `Bearer ${asanaToken}`,
    },
  }
);

console.log(`Task "${taskName}" created successfully in Asana.`)
```

##  Get Current Bitcoin Price

```typescript
// Name: Bitcoin Price Checker
// Description: Fetches and displays the current Bitcoin price
// Author: johnlindquist

import "@johnlindquist/kit"

// Fetch Bitcoin price from CoinGecko API
const response = await get("https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd")

// Extract and display the Bitcoin price in USD
const bitcoinPrice = response.data.bitcoin.usd

await div(md(`# Current Bitcoin Price: $${bitcoinPrice}`)) 
```

## Resize and Compress Images

```typescript
// Name: Resize and Compress Images
// Description: Resizes and compresses images in a directory using Sharp
// Author: johnlindquist

import "@johnlindquist/kit"
import sharp from "sharp"
import { globby } from "globby"

// Prompt for the directory containing images
const directoryPath = await path({ 
  hint: "Select directory containing images:",
  onlyDirs: true, 
})

// Get all image files in the directory
const imageFiles = await globby([
  `${directoryPath}/*.jpg`,
  `${directoryPath}/*.jpeg`, 
  `${directoryPath}/*.png`,
], { 
  expandDirectories: {
    extensions: ["jpg", "jpeg", "png"], 
  }, 
})

// Prompt for the new width 
const newWidth = parseInt(await arg("Enter new width in pixels:")) 

// Resize and compress each image file
for (const file of imageFiles) { 
  const compressedImageBuffer = await sharp(file)
    .resize({ width: newWidth })
    .jpeg({ quality: 80 }) // Adjust quality as needed 
    .toBuffer()

  // Overwrite the original file with the compressed image
  await writeFile(file, compressedImageBuffer);

  console.log(`Resized and compressed: ${file}`)
}

console.log("All images resized and compressed.")
```

##  Convert Text to Handwriting

```typescript
// Name: Text to Handwriting
// Description: Converts text to handwriting using the Handwriter API
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the Handwriter API key from the environment
// https://rapidapi.com/zws53475/api/handwriter/
const handwriterApiKey = await env("HANDWRITER_API_KEY")

// Prompt for text input
const text = await arg("Enter text to convert:") 

// Prompt for handwriting style
const handwritingStyle = await arg("Select handwriting style:", [
  "BALLPOINT",
  "CURSIVE",
  "MARKER",
])

// Convert the text to handwriting using the API
const response = await post(
  "https://handwriter.p.rapidapi.com/write", 
  {
    handwriting_id: handwritingStyle, 
    text,
  },
  { 
    headers: {
      "x-rapidapi-host": "handwriter.p.rapidapi.com", 
      "x-rapidapi-key": handwriterApiKey,
      "Content-Type": "application/json",
    },
  }
); 

// Get the image URL from the response
const imageUrl = response.data.url

// Display the handwriting image in a div 
await div(`<img src="${imageUrl}" alt="Handwriting" class="w-full" />`) 
```

## Create a New GitHub Issue

```typescript
// Name: Create GitHub Issue
// Description: Creates a new issue in a GitHub repository
// Author: johnlindquist

import "@johnlindquist/kit"
import { Octokit } from "@octokit/rest"

// Get the GitHub API token from the environment 
// https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token
const githubToken = await env("GITHUB_TOKEN")

// Initialize GitHub API client
const octokit = new Octokit({ auth: githubToken });

// Prompt for repository information 
const repoOwner = await arg("Enter repository owner:")
const repoName = await arg("Enter repository name:")

// Prompt for issue details 
const issueTitle = await arg("Enter issue title:") 
const issueBody = await editor({
  placeholder: "Enter issue body:", 
})

// Create the issue on GitHub
await octokit.issues.create({
  owner: repoOwner,
  repo: repoName,
  title: issueTitle,
  body: issueBody,
}); 

console.log(`Issue "${issueTitle}" created successfully in ${repoOwner}/${repoName}.`) 
```

##  Get Lyrics for a Song

```typescript
// Name: Get Song Lyrics
// Description: Fetches and displays lyrics for a given song 
// Author: johnlindquist

import "@johnlindquist/kit"
//Prompt for the song title and artist
const songTitle = await arg("Enter song title:")
const artist = await arg("Enter artist:")

// Search for lyrics using the Lyrics.ovh API
const lyricsResponse = await get( 
  `https://api.lyrics.ovh/v1/${encodeURIComponent(artist)}/${encodeURIComponent(songTitle)}`
)

// Display the lyrics 
await editor({
  value: lyricsResponse.data.lyrics,
  language: "text", 
})
``` 

## Convert Currency

```typescript
// Name: Currency Converter 
// Description: Converts an amount from one currency to another
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the amount to convert 
const amount = parseFloat(await arg("Enter amount:")) 

// Prompt for the base currency
const fromCurrency = await arg("Enter base currency (e.g., USD):") 

// Prompt for the target currency
const toCurrency = await arg("Enter target currency (e.g., EUR):")

// Fetch exchange rate data from the ExchangeRate-API
const exchangeRateResponse = await get(
  `https://v6.exchangerate-api.com/v6/${await env(
    "EXCHANGERATE_API_KEY" 
  )}/latest/${fromCurrency}`
)

// Extract the exchange rate
const exchangeRate = exchangeRateResponse.data.conversion_rates[toCurrency] 

// Calculate the converted amount
const convertedAmount = amount * exchangeRate

// Display the converted amount 
await div(md(`# ${amount} ${fromCurrency} = ${convertedAmount.toFixed(2)} ${toCurrency}`))
```


## Send Email with Attachment

```typescript
// Name: Send Email with Attachment
// Description: Sends an email with an attachment using Nodemailer
// Author: johnlindquist

import "@johnlindquist/kit"
import nodemailer from "nodemailer"

// Get the email credentials from the environment
// https://nodemailer.com/about/
const emailUser = await env("EMAIL_USER")
const emailPassword = await env("EMAIL_PASSWORD")

// Create a transporter using your chosen email provider's settings
const transporter = nodemailer.createTransport({
  service: await arg("Enter email provider (e.g., 'gmail'):"), 
  auth: {
    user: emailUser,
    pass: emailPassword,
  },
})

// Prompt for email details
const recipientEmail = await arg("Enter recipient email address:")
const subject = await arg("Enter email subject:") 
const body = await arg("Enter email body:")

// Prompt for the attachment file path
const attachmentPath = await path({
  hint: "Select a file to attach",
})

// Compose the email with attachment
const mailOptions = {
  from: emailUser,
  to: recipientEmail, 
  subject: subject,
  text: body,
  attachments: [
    {
      filename: path.basename(attachmentPath), 
      path: attachmentPath,
    },
  ],
};

// Send the email
await transporter.sendMail(mailOptions) 

console.log(`Email with attachment sent to ${recipientEmail}.`)
```

## Create a New Google Sheets Spreadsheet

```typescript
// Name: Create Google Spreadsheet
// Description: Creates a new Google Spreadsheet
// Author: johnlindquist

import "@johnlindquist/kit"
import { google } from "googleapis"

// Get the Google Sheets API credentials from the environment
// https://developers.google.com/sheets/api/quickstart/nodejs
const googleSheetsCredentials = JSON.parse(
  await env("GOOGLE_SHEETS_CREDENTIALS")
)
// Authorize with the Google Sheets API
const auth = new google.auth.GoogleAuth({
  credentials: googleSheetsCredentials,
  scopes: ["https://www.googleapis.com/auth/spreadsheets"],
}); 
const sheets = google.sheets({ version: "v4", auth });

// Create the new spreadsheet
const { data: newSpreadsheet } = await sheets.spreadsheets.create({
  requestBody: {
    properties: {
      title: await arg("Enter spreadsheet title:"), 
    }, 
  },
});

// Open the newly created spreadsheet in the browser
await open(newSpreadsheet.spreadsheetUrl)

console.log(`Spreadsheet created: ${newSpreadsheet.spreadsheetUrl}`)
```

##  Get Random Advice

```typescript
// Name: Get Advice
// Description: Fetches and displays a piece of random advice
// Author: johnlindquist

import "@johnlindquist/kit"

// Fetch a random advice slip from the Advice Slip API
const { data: adviceSlip } = await get("https://api.adviceslip.com/advice");

// Extract and display the advice
await div(md(`# ${adviceSlip.slip.advice}`))
```

## Shorten URL with TinyURL

```typescript
// Name: Shorten URL
// Description: Shortens a URL using the TinyURL API
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the URL to shorten
const urlToShorten = await arg("Enter URL to shorten:") 

// Shorten the URL using the TinyURL API 
const response = await get(
  `https://tinyurl.com/api-create.php?url=${encodeURIComponent(urlToShorten)}`
) 

// Extract the shortened URL
const shortenedUrl = response.data

// Display the shortened URL
await div(md(`# Shortened URL:\n\n[${shortenedUrl}](${shortenedUrl})`))
```

## Convert Image to Grayscale

```typescript
// Name: Convert Image to Grayscale
// Description: Converts an image to grayscale using Jimp
// Author: johnlindquist

import "@johnlindquist/kit" 
import Jimp from "jimp"

// Prompt for the image path
const imagePath = await path({
  hint: "Select an image", 
}) 

// Convert the image to grayscale using Jimp 
const grayscaleImage = await Jimp.read(imagePath)
  .then(image => image.grayscale()) // Apply grayscale
  .then(image => image.getBufferAsync(Jimp.MIME_PNG))

// Overwrite the original image file with the grayscale version
await writeFile(imagePath, grayscaleImage)

console.log(`Converted "${imagePath}" to grayscale.`) 
```

## Check for Available Updates for NPM Packages

```typescript
// Name: Check for NPM Updates
// Description: Checks for available updates for NPM packages in the current directory
// Author: johnlindquist

import "@johnlindquist/kit"

// Execute the 'npm outdated' command and capture its output 
const { stdout: outdatedPackages } = await exec("npm outdated") 

// Check if there are any outdated packages
if (outdatedPackages) {
  // Display the list of outdated packages in the editor 
  await editor({
    value: outdatedPackages,
    language: "text", 
  }) 
} else {
  // Display a message if no updates are found
  await div(md(`# All NPM packages are up to date.`))
}
```

##  Send a Message to a Telegram Chat

```typescript
// Name: Send Telegram Message 
// Description: Sends a message to a Telegram chat 
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the Telegram bot token and chat ID from the environment
// https://core.telegram.org/bots#6-botfather 
const telegramBotToken = await env("TELEGRAM_BOT_TOKEN");
const telegramChatId = await env("TELEGRAM_CHAT_ID");

// Prompt for the message content 
const message = await arg("Enter your message:")

// Send the message to the Telegram chat 
await get(`https://api.telegram.org/bot${telegramBotToken}/sendMessage`, { 
  params: {
    chat_id: telegramChatId,
    text: message,
  },
});

console.log(`Message sent to Telegram chat ${telegramChatId}.`);
```


## Create a New Snippet from Selected Text

```typescript
// Name: Create Snippet from Selection
// Description: Creates a new text snippet from the selected text
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the selected text 
let selectedText = await getSelectedText()

// Prompt for the snippet name
let snippetName = await arg("Enter snippet name:")

// Create the snippet file path 
let snippetFilePath = kenvPath("snippets", `${snippetName}.txt`) 

// Write the selected text to the snippet file
await writeFile(snippetFilePath, selectedText) 

console.log(`Snippet "${snippetName}" created successfully.`) 
```

## Check for Unused Dependencies in package.json

```typescript
// Name: Unused Dependencies Checker 
// Description: Checks for unused dependencies in a package.json file
// Author: johnlindquist

import "@johnlindquist/kit"
import { sync as depcheck } from "depcheck"

// Prompt for the project directory path
const projectPath = await path({ 
  hint: "Select your project directory", 
  onlyDirs: true,
})

// Analyze dependencies using depcheck 
const { dependencies } = depcheck(projectPath, {
  ignoreBinPackage: false, // Check for unused binary packages
  skipMissing: false,      // Detect missing dependencies 
})

// Display unused dependencies
if (dependencies.length > 0) {
  let unusedDependencies = dependencies.map(dependency => `* ${dependency}`).join("\n")
  await div(
    md(`## Unused dependencies found:

${unusedDependencies}

Review the list of unused dependencies above. If you're sure you're not using these, you may want to consider removing them from your "package.json".

To remove all of the listed dependencies, type "uninstall" and hit enter.

Otherwise, hit "Escape" to go back to the main menu. 
`)
  )

  // Prompt to ask if user wants to uninstall unused dependencies
  let uninstall = await arg(
    "Uninstall unused dependencies?",
    ["uninstall", "no"]
  )

  if (uninstall === "uninstall") {
    // Uninstall unused dependencies using npm 
    for (const dependency of dependencies) {
      await term({
        command: `npm uninstall ${dependency}`,
        cwd: projectPath,
        height: 140,
        enter: "Exit",
        shortcuts: [],
      })
    }
  }
} else {
  await div(md("# No unused dependencies found."))
}
```

## Convert Text to QR Code and Save as Image

```typescript
// Name: Generate QR Code Image
// Description: Generates a QR code image from text
// Author: johnlindquist

import "@johnlindquist/kit"
import QRCode from "qrcode"

// Prompt for text input
let inputText = await arg("Enter text for QR code:") 

// Generate QR code and save as a PNG image
QRCode.toFile(
  tmpPath("qrcode.png"), 
  inputText, 
  {
    errorCorrectionLevel: "H", // Set error correction level for better readability
    width: 500,               // Specify the width of the QR code image 
  }, 
  (err) => {
    if (err) throw err
    console.log("QR code generated and saved as qrcode.png")
  }
)
```

##  Check for Upcoming Calendar Events

```typescript
// Name: Upcoming Calendar Events
// Description: Checks and displays upcoming events on your Google Calendar 
// Author: johnlindquist

import "@johnlindquist/kit"
import { google } from "googleapis";

// Get the Google Calendar API credentials from the environment 
// https://developers.google.com/calendar/api/quickstart/nodejs 
const googleCalendarCredentials = JSON.parse(await env("GOOGLE_CALENDAR_CREDENTIALS"))
// Authorize with the Google Calendar API
const auth = new google.auth.GoogleAuth({
  credentials: googleCalendarCredentials, 
  scopes: ["https://www.googleapis.com/auth/calendar"], 
});
const calendar = google.calendar({ version: "v3", auth });

// Get upcoming events for the next 7 days 
const now = new Date();
const nextWeek = new Date();
nextWeek.setDate(now.getDate() + 7);

const res = await calendar.events.list({
  calendarId: "primary", 
  timeMin: now.toISOString(),
  timeMax: nextWeek.toISOString(), 
  maxResults: 10, // Limit to 10 upcoming events
  singleEvents: true,
  orderBy: "startTime", 
});

const events = res.data.items

if (events.length) {
  // Create a list of upcoming events to display
  const eventChoices = events.map(event => ({ 
    name: event.summary,
    value: event,
    description: `Starts at ${new Date(event.start.dateTime).toLocaleString()}`,
  }))

  // Prompt the user to select an event
  const selectedEvent = await arg("Upcoming events:", eventChoices)

  // Display the selected event's details 
  await div(
    md(`
# ${selectedEvent.summary} 

**Start:** ${new Date(selectedEvent.start.dateTime).toLocaleString()}
**End:** ${new Date(selectedEvent.end.dateTime).toLocaleString()} 
${selectedEvent.description ? `\n\n**Description:** ${selectedEvent.description}` : ""} 
${selectedEvent.location ? `\n\n**Location:** ${selectedEvent.location}` : ""}
`)
  )
} else {
  // Display a message if no events are found 
  await div(md("# No upcoming events found.")) 
}
```

##  Merge PDF Files

```typescript
// Name: Merge PDFs 
// Description: Merges multiple PDF files into a single PDF
// Author: johnlindquist

import "@johnlindquist/kit"
import PDFMerge from 'pdf-merger-js'

// Prompt for the PDF file paths
const pdfFilePaths = await arg(
  {
    placeholder: "Select PDF files to merge",
    multiple: true,
  },
  async () => {
    // Get the selected files from Finder
    const selectedFiles = await getSelectedFile() 
    // Split file paths 
    return selectedFiles ? selectedFiles.split("\n") : []
  }
) 

// Create a new PDFMerge instance
const merger = new PDFMerge()

// Add the selected PDF files to the merger
for (const filePath of pdfFilePaths) {
  merger.add(filePath)
}

// Merge the PDFs
const mergedPdfBuffer = await merger.saveAsBuffer();

// Prompt for the output file path 
const outputPath = await path({ 
  hint: "Select a location to save the merged PDF", 
})

// Write the merged PDF data to the file 
await writeFile(outputPath, mergedPdfBuffer) 

console.log(`PDF files merged and saved to: ${outputPath}`)
```

## Get Current Public IP Address

```typescript
// Name: Get Public IP
// Description: Fetches and displays your public IP address
// Author: johnlindquist

import "@johnlindquist/kit" 

// Fetch public IP address from ipify API
const response = await get("https://api.ipify.org?format=json") 

// Extract and display the IP address
const publicIp = response.data.ip

await div(md(`# Your Public IP Address:\n\n${publicIp}`))
```

## Generate Random User Data

```typescript
// Name: Generate User Data
// Description: Generates random user data using Faker.js 
// Author: johnlindquist

import "@johnlindquist/kit" 
import { faker } from "@faker-js/faker"; 

// Generate random user data
const name = faker.person.fullName()
const email = faker.internet.email() 
const address = faker.location.streetAddress() 
const phoneNumber = faker.phone.number()
const bio = faker.lorem.paragraph()

// Display the generated data in the editor
await editor({
  value: `
Name: ${name}
Email: ${email}
Address: ${address} 
Phone: ${phoneNumber}
Bio: ${bio} 
`,
  language: "text", 
})
```


## Create GitHub Pull Request

```typescript
// Name: Create GitHub Pull Request
// Description: Creates a new pull request on GitHub
// Author: johnlindquist

import "@johnlindquist/kit"
import { Octokit } from "@octokit/rest"

// Get the GitHub API token from the environment
// https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token
const githubToken = await env("GITHUB_TOKEN")

// Initialize GitHub API client
const octokit = new Octokit({ auth: githubToken })

// Prompt for repository information
const repoOwner = await arg("Enter repository owner:")
const repoName = await arg("Enter repository name:") 

// Prompt for pull request details 
const baseBranch = await arg("Enter base branch:")
const headBranch = await arg("Enter head branch:")
const prTitle = await arg("Enter pull request title:") 
const prBody = await editor({
  placeholder: "Enter pull request body:",
})

// Create the pull request on GitHub 
await octokit.pulls.create({
  owner: repoOwner,
  repo: repoName,
  title: prTitle,
  head: headBranch, 
  base: baseBranch,
  body: prBody, 
});

console.log(
  `Pull request "${prTitle}" created successfully for ${repoOwner}/${repoName}.`
)
```

## Get Current Location's Weather

```typescript
// Name: Current Weather
// Description: Gets the current weather for your location
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the OpenWeatherMap API key from the environment
// https://openweathermap.org/api
const openWeatherMapApiKey = await env("OPENWEATHERMAP_API_KEY")

// Get the user's current location 
const location = await getLocation()

// Fetch weather data from the API
const response = await get(`https://api.openweathermap.org/data/2.5/weather?lat=${location.latitude}&lon=${location.longitude}&appid=${openWeatherMapApiKey}&units=metric`)

// Extract relevant weather information
const { name, main, weather } = response.data

// Display the weather information
await div(md(`
# Current Weather in ${name}

* Temperature: ${main.temp}Â°C
* Feels like: ${main.feels_like}Â°C
* Condition: ${weather[0].description}
`))
```

## Create a New Project in Notion

```typescript
// Name: Create Notion Project
// Description: Creates a new project in Notion
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the Notion API token from the environment
// https://developers.notion.com/docs/getting-started 
const notionToken = await env("NOTION_TOKEN")

// Prompt for the parent page ID
const parentPageId = await arg({
  placeholder: "Enter Notion parent page ID:"
})

// Prompt for the project title
const projectTitle = await arg("Enter project title:")

// Create a new page in Notion as a project
await post(
  `https://api.notion.com/v1/pages`,
  {
    parent: {
      page_id: parentPageId,
    },
    properties: {
      title: [
        {
          text: {
            content: projectTitle,
          },
        },
      ],
    }, 
  }, 
  {
    headers: {
      Authorization: `Bearer ${notionToken}`,
      "Notion-Version": "2022-06-28", // Specify Notion API version
      "Content-Type": "application/json", 
    },
  }
)

console.log(`Project "${projectTitle}" created successfully in Notion.`) 
```

## Generate a Sitemap for a Website

```typescript
// Name: Generate Sitemap 
// Description: Generates a sitemap for a website
// Author: johnlindquist

import "@johnlindquist/kit"
import { SitemapStream, streamToPromise } from "sitemap"

// Prompt for the website URL
const websiteUrl = await arg("Enter website URL:")

// Create a sitemap stream
const sitemapStream = new SitemapStream({ hostname: websiteUrl });

// Add URLs to the sitemap (replace with your website's URLs) 
sitemapStream.write({ url: "/", changefreq: "daily", priority: 1 }); 
sitemapStream.write({ url: "/about", changefreq: "weekly", priority: 0.8 })
sitemapStream.write({ url: "/contact", changefreq: "monthly", priority: 0.5 }) 

// End the sitemap stream
sitemapStream.end() 

// Convert the stream to a promise
const sitemapXml = await streamToPromise(sitemapStream)

// Write the sitemap to a file
await writeFile(kenvPath("sitemap.xml"), sitemapXml)

console.log("Sitemap generated and saved to sitemap.xml")
```

## Generate Shortened URL with Short.io

```typescript
// Name: Shorten URL with Short.io 
// Description: Shortens a URL using the Short.io API 
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the Short.io API key from the environment 
// https://app.short.io/settings/integrations/api-key
const shortIoApiKey = await env("SHORT_IO_API_KEY")

// Prompt for the original URL to shorten
const originalUrl = await arg("Enter URL to shorten:") 

// Shorten the URL using the Short.io API
const { data: shortLinkData } = await post(
  "https://api.short.io/links",
  { 
    originalURL: originalUrl, 
    domain: "j.mp", // or your custom Short.io domain
  },
  {
    headers: {
      Authorization: shortIoApiKey,
      "Content-Type": "application/json",
    }, 
  }
); 

// Extract the shortened URL
const shortenedUrl = shortLinkData.shortURL

// Display the shortened URL
await div(md(`# Shortened URL: \n\n[${shortenedUrl}](${shortenedUrl})`)) 
``` 

##  Check for Available System Updates

```typescript
// Name: Check for System Updates
// Description: Checks for and displays available system updates
// Author: johnlindquist

import "@johnlindquist/kit" 

// Display a terminal with the software update command 
await term({ 
  command: "softwareupdate --list", 
  enter: "Exit", // Override the default "Enter" key behavior
  shortcuts: [],  // Disable default shortcuts 
})
```

##  Clean Up Temporary Files

```typescript
// Name: Clean Up Temporary Files
// Description: Cleans up temporary files and directories
// Author: johnlindquist

import "@johnlindquist/kit"
import { tmpdir } from "os"

// Get the temporary directory path
const tempDir = tmpdir()

// Clean up the temporary directory using rimraf
await rimraf(tempDir, { glob: true }) 

console.log(`Temporary directory (${tempDir}) cleaned up.`)
```


## Create and Upload a File to Dropbox

```typescript
// Name: Upload to Dropbox
// Description: Uploads a file to Dropbox
// Author: johnlindquist

import "@johnlindquist/kit";
import { Dropbox } from "dropbox"

// Get the Dropbox API token from the environment
// https://www.dropbox.com/developers/apps
const dropboxToken = await env("DROPBOX_TOKEN")

// Prompt for the file path
const filePath = await path({
  hint: "Select a file to upload",
})

// Read the file contents
const fileContent = await readFile(filePath)

// Initialize the Dropbox client
const dbx = new Dropbox({ accessToken: dropboxToken })

// Upload the file to Dropbox
await dbx.filesUpload({
  path: `/${path.basename(filePath)}`,
  contents: fileContent,
  mode: { ".tag": "overwrite" }, // Overwrite if file exists
})

console.log(`File "${filePath}" uploaded to Dropbox.`)
```

##  Get Current Public IP Address and Location

```typescript
// Name: Get Public IP and Location
// Description: Fetches and displays your public IP address and location
// Author: johnlindquist

import "@johnlindquist/kit"

// Fetch public IP address and location information from IP-API
const response = await get("http://ip-api.com/json/")

// Extract and display the information
const { ip, city, regionName, country, zip } = response.data

await div(md(`
# IP Address: ${ip}

## Location:

* City: ${city}
* Region: ${regionName}
* Country: ${country} 
* Zip Code: ${zip}
`))
```

## Generate a Secure Random Password

```typescript
// Name: Generate Secure Password
// Description: Generates a cryptographically secure random password
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the desired password length
const passwordLength = parseInt(await arg("Enter password length:"))

// Generate a secure random password
const password = await new Promise<string>((resolve, reject) => {
  crypto.randomBytes(passwordLength, (err, buffer) => {
    if (err) {
      reject(err)
    } else {
      // Convert buffer to base64url encoded string
      resolve(buffer.toString("base64url"))
    }
  }) 
})

// Copy the password to the clipboard
await copy(password)

console.log(`Secure password generated and copied to clipboard.`)
```

##  Get Trending Repositories on GitHub

```typescript
// Name: GitHub Trending
// Description: Fetches and displays trending repositories on GitHub
// Author: johnlindquist 

import "@johnlindquist/kit" 

// Prompt for the programming language
const language = await arg({
  placeholder: "Enter programming language (e.g., JavaScript):", 
}) 

// Fetch trending repositories from the GitHub API
const response = await get(
  `https://api.github.com/search/repositories?q=language:${language}&sort=stars&order=desc`
) 

// Extract and display the top 5 repositories
const repositories = response.data.items.slice(0, 5)
let repoChoices = repositories.map(repo => ({
  name: repo.full_name,
  description: repo.description, 
  value: repo.html_url,
}))

let repoUrl = await arg("Trending repositories:", repoChoices);
await open(repoUrl)
```

## Convert Text to Speech and Save to File

```typescript
// Name: Text to Speech and Save 
// Description: Converts text to speech and saves it to an audio file 
// Author: johnlindquist

import "@johnlindquist/kit"
import { Configuration, OpenAIApi } from "openai"

// Get the OpenAI API key from the environment
// https://beta.openai.com/account/api-keys
const openaiApiKey = await env("OPENAI_API_KEY")

// Initialize OpenAI API
const openai = new OpenAIApi(new Configuration({ apiKey: openaiApiKey }))

// Prompt for text input
let inputText = await arg("Enter text to convert to speech:")

// Generate speech audio 
const response = await openai.audio.speech.create({
  model: "tts-1",
  voice: "alloy", 
  input: inputText,
})

// Save the audio data as an MP3 file
const audioFilePath = tmpPath(`speech-${Date.now()}.mp3`);
const audioArrayBuffer = await response.arrayBuffer();
const audioBuffer = Buffer.from(audioArrayBuffer)
await writeFile(audioFilePath, audioBuffer); 

console.log(`Speech saved to file: ${audioFilePath}`)
```

##  Create a New Jira Issue

```typescript
// Name: Create Jira Issue
// Description: Creates a new issue in Jira
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the Jira API token and project key from the environment 
// https://developer.atlassian.com/cloud/jira/platform/basic-auth-for-rest-apis/
const jiraEmail = await env("JIRA_EMAIL")
const jiraToken = await env("JIRA_TOKEN")
const jiraProjectKey = await env("JIRA_PROJECT_KEY")

// Prompt for the issue summary
const issueSummary = await arg("Enter issue summary:") 

// Prompt for the issue description
const issueDescription = await editor({
  placeholder: "Enter issue description:",
})

// Create the issue in Jira 
await post( 
  `https://your-jira-domain.atlassian.net/rest/api/3/issue`,
  {
    fields: { 
      project: {
        key: jiraProjectKey, 
      },
      summary: issueSummary, 
      description: issueDescription, 
      issuetype: {
        name: "Task", // Set the issue type
      },
    }, 
  }, 
  {
    headers: {
      Authorization: `Basic ${Buffer.from(`${jiraEmail}:${jiraToken}`).toString("base64")}`, 
      "Content-Type": "application/json",
    }, 
  } 
) 

console.log(`Jira issue "${issueSummary}" created successfully.`)
```

## Extract Images from a PDF

```typescript
// Name: Extract Images from PDF 
// Description: Extracts images from a PDF file 
// Author: johnlindquist

import "@johnlindquist/kit" 
import { PDFImage } from "pdf-image" 

// Prompt for the PDF file path
const pdfFilePath = await path({
  hint: "Select a PDF file",
}); 

// Create a new PDFImage instance 
const pdfImage = new PDFImage(pdfFilePath)

// Extract the images from the PDF
const imagePaths = await pdfImage.extract() 

// Display the extracted image file paths in the editor
await editor(imagePaths.join("\n"))
```


## Upload Image to Imgur

```typescript
// Name: Upload Image to Imgur
// Description: Uploads an image to Imgur and copies the link to the clipboard
// Author: johnlindquist

import "@johnlindquist/kit" 
import FormData from "form-data"

// Get the Imgur Client ID from the environment
// https://apidocs.imgur.com/#authorization-and-oauth
const imgurClientId = await env("IMGUR_CLIENT_ID"); 

// Prompt for the image path
const imagePath = await path({
  hint: "Select an image file",
})

// Read the image file
const imageBuffer = await readFile(imagePath);

// Create a FormData instance to upload the image
const formData = new FormData();
formData.append("image", imageBuffer, { filename: path.basename(imagePath) }) 

// Upload the image to Imgur
const response = await fetch("https://api.imgur.com/3/image", {
  method: "POST",
  headers: {
    Authorization: `Client-ID ${imgurClientId}`,
  },
  body: formData as any, 
});

// Extract the image link from the response 
const { data: imgurData } = await response.json()
const imageUrl = imgurData.link 

// Copy the image URL to the clipboard
await copy(imageUrl); 

console.log(`Image uploaded to Imgur: ${imageUrl}`)
```

## Get Trending Topics on Twitter

```typescript
// Name: Twitter Trends 
// Description: Fetches and displays trending topics on Twitter 
// Author: johnlindquist

import "@johnlindquist/kit"
import Twitter from "twitter-api-v2" 

// Get Twitter API keys from the environment 
// https://developer.twitter.com/en/portal/dashboard
const twitterConsumerKey = await env("TWITTER_CONSUMER_KEY")
const twitterConsumerSecret = await env("TWITTER_CONSUMER_SECRET") 
const twitterAccessTokenKey = await env("TWITTER_ACCESS_TOKEN_KEY") 
const twitterAccessTokenSecret = await env("TWITTER_ACCESS_TOKEN_SECRET")

// Initialize Twitter API client 
const twitterClient = new Twitter({
  appKey: twitterConsumerKey,
  appSecret: twitterConsumerSecret,
  accessToken: twitterAccessTokenKey, 
  accessSecret: twitterAccessTokenSecret,
}); 

// Get trending topics for a specific location (WOEID) - replace with your desired WOEID
// Find WOEID using: https://www.findmecity.com/
const location = await arg("Enter WOEID:");
const trends = await twitterClient.v2.trendsPlace(location); 

// Extract trending topics 
const trendingTopics = trends[0].trends.map(trend => trend.name)

// Display trending topics
await div(md(`# Trending Topics:

${trendingTopics.map(topic => `- ${topic}`).join("\n")} 
`))
```

##  Create a New Google Calendar Event from Template

```typescript
// Name: Create Calendar Event from Template
// Description: Creates a new Google Calendar event from a template
// Author: johnlindquist

import "@johnlindquist/kit"
import { google } from "googleapis"

// Get the Google Calendar API credentials from the environment 
// https://developers.google.com/calendar/api/quickstart/nodejs
const googleCalendarCredentials = JSON.parse(
  await env("GOOGLE_CALENDAR_CREDENTIALS")
)
// Authorize with the Google Calendar API
const auth = new google.auth.GoogleAuth({
  credentials: googleCalendarCredentials,
  scopes: ["https://www.googleapis.com/auth/calendar"],
})
const calendar = google.calendar({ version: "v3", auth }); 

// Prompt for the event template 
let eventTemplate = await arg({
  placeholder: "Enter event template:", 
  hint: "Use placeholders like ${summary}, ${start}, ${end}", 
  // Provide initial content as a template 
  input: "Summary: ${summary}\nStart: ${start}\nEnd: ${end}",
});

// Prompt the user to fill in the template 
let eventDetails = await template(eventTemplate)

// Parse the event details from the template 
let { summary, start, end } = eventDetails
  .split("\n")
  .map(line => line.split(": ")[1])
  .reduce((acc, curr, index) => {
    const keys = ["summary", "start", "end"]
    acc[keys[index]] = curr 
    return acc
  }, {})

// Create the event object
const event = {
  summary,
  start: {
    dateTime: start,
  },
  end: {
    dateTime: end,
  },
} 

// Insert the event into the user's primary calendar 
await calendar.events.insert({
  calendarId: "primary",
  requestBody: event,
});

console.log("Event created successfully on your Google Calendar.")
```

##  Check for Spelling Errors in a Markdown File

```typescript
// Name: Markdown Spell Checker
// Description: Checks a Markdown file for spelling errors
// Author: johnlindquist

import "@johnlindquist/kit"
import SpellChecker from "simple-spellchecker"

// Prompt for the Markdown file path
const filePath = await path({
  hint: "Select a Markdown file",
})

// Read the Markdown file 
const markdownContent = await readFile(filePath, "utf8")

// Load the English (US) dictionary 
const dictionary = await new Promise((resolve, reject) => { 
  SpellChecker.getDictionary("en-US", (err, dictionary) => { 
    if (err) { 
      reject(err) 
    } else {
      resolve(dictionary)
    } 
  })
})

// Extract words from the Markdown content 
const words = markdownContent
  .replace(/`.*?`/g, "") // Remove code snippets 
  .replace(/#+\s/g, "") // Remove headers
  .split(/\s+/)
  .filter(word => word.length > 0)

// Check each word for spelling errors
const misspelledWords = words.filter(word => !dictionary.spellCheck(word))

// Display misspelled words and suggestions
if (misspelledWords.length > 0) {
  let words = misspelledWords.join(", ")
  let suggestions = await arg(
    "Misspelled words. Hit Enter to copy them to your clipboard or type a correction then select it.",
    async input => {
      let words = input.split(",").map(w => w.trim())
      let results = []
      for await (let word of words) {
        if (word) {
          results.push({
            name: word,
            choices: dictionary.getSuggestions(word),
          })
        }
      }

      return results
    }
  )

  copy(suggestions)
} else {
  await div(md(`# No misspelled words found in ${filePath}`))
}

```

## Create a Time-Tracking Entry with Toggl Track

```typescript
// Name: Start Toggl Timer
// Description: Starts a new time entry in Toggl Track 
// Author: johnlindquist

import "@johnlindquist/kit"
import { Toggl } from "toggl-api"

// Get the Toggl Track API token from the environment
// https://track.toggl.com/profile
const togglApiKey = await env("TOGGL_API_KEY") 

// Prompt for the task description 
const description = await arg("Enter task description:") 

// Initialize the Toggl Track client
const toggl = new Toggl({ apiToken: togglApiKey });

// Start a new time entry 
toggl.startTimeEntry({ description: description }, (err, data) => {
  if (err) {
    console.error("Error starting time entry:", err)
  } else {
    console.log("Time entry started:", data); 
  }
});
```

## Create a New GitHub Project

```typescript
// Name: Create GitHub Project
// Description: Creates a new project in a GitHub repository 
// Author: johnlindquist

import "@johnlindquist/kit"
import { Octokit } from "@octokit/rest" 

// Get the GitHub API token from the environment 
// https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token
const githubToken = await env("GITHUB_TOKEN")

// Initialize GitHub API client 
const octokit = new Octokit({ auth: githubToken })

// Prompt for the repository owner and name
const repoOwner = await arg("Enter repository owner:"); 
const repoName = await arg("Enter repository name:") 

// Prompt for the project name
const projectName = await arg("Enter project name:"); 

// Create a new GitHub Project
const { data: project } = await octokit.projects.createForRepo({
  owner: repoOwner, 
  repo: repoName,
  name: projectName, 
}); 

console.log(`Project "${projectName}" created successfully for ${repoOwner}/${repoName}.`)
```

## Convert a Website to PDF

```typescript
// Name: Convert Website to PDF 
// Description: Converts a website to a PDF file using Puppeteer
// Author: johnlindquist 

import "@johnlindquist/kit" 
import puppeteer from "puppeteer"

// Prompt for the website URL
const websiteUrl = await arg({
  placeholder: "Enter website URL:",
}) 

// Launch a headless Chrome instance
const browser = await puppeteer.launch();
const page = await browser.newPage();

// Go to the specified URL
await page.goto(websiteUrl, { waitUntil: "networkidle2" }) 

// Generate the PDF
const pdfBuffer = await page.pdf({ format: "A4" }); 

// Close the browser
await browser.close()

// Prompt for the output file path
const outputPath = await path({
  hint: "Select a location to save the PDF:",
})

// Save the PDF to the chosen location
await writeFile(outputPath, pdfBuffer); 

console.log(`Website converted to PDF and saved to: ${outputPath}`)
```




## Create and Upload a File to S3

```typescript
// Name: Upload to S3 
// Description: Uploads a file to an Amazon S3 bucket 
// Author: johnlindquist

import "@johnlindquist/kit"
import AWS from "aws-sdk"

// Get AWS credentials from the environment
// https://docs.aws.amazon.com/sdk-for-javascript/v2/developer-guide/setting-credentials-node.html
const awsAccessKeyId = await env("AWS_ACCESS_KEY_ID") 
const awsSecretAccessKey = await env("AWS_SECRET_ACCESS_KEY") 

// Configure AWS SDK 
AWS.config.update({
  accessKeyId: awsAccessKeyId,
  secretAccessKey: awsSecretAccessKey, 
  region: "us-east-1", // Replace with your desired AWS region
})

// Prompt for the bucket name
const bucketName = await arg("Enter bucket name:") 

// Prompt for the file path 
const filePath = await path({
  hint: "Select a file to upload", 
}) 

// Create an instance of Amazon S3
const s3 = new AWS.S3()

// Read the file contents 
const fileContent = await readFile(filePath) 

// Upload the file to S3 
const uploadParams = {
  Bucket: bucketName,
  Key: path.basename(filePath), 
  Body: fileContent, 
} 

s3.upload(uploadParams, (err, data) => {
  if (err) {
    console.error("Error uploading file:", err) 
  } else { 
    console.log("File uploaded successfully:", data.Location); 
  }
});
```

## Get Random Wikipedia Article Summary

```typescript
// Name: Random Wikipedia Article
// Description: Fetches and displays a summary of a random Wikipedia article
// Author: johnlindquist

import "@johnlindquist/kit"

// Fetch a random Wikipedia article
const response = await get("https://en.wikipedia.org/api/rest_v1/page/random/summary")

// Extract the article title and extract
const { title, extract } = response.data 

// Display the title and extract in a div
await div(md(`# ${title}\n\n${extract}`)) 
```

##  Download and Install an NPM Package Globally

```typescript
// Name: Install Global NPM Package 
// Description: Downloads and installs an NPM package globally 
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the package name
let packageName = await arg("Enter NPM package name:"); 

// Install the package globally using npm 
await term({
  command: `npm install -g ${packageName}`, 
  cwd: home(),
  height: 140,
  enter: "Exit",
  shortcuts: [],
});
```

##  Check for Outdated Global NPM Packages

```typescript
// Name: Check for Global Updates 
// Description: Checks for and displays outdated globally installed NPM packages 
// Author: johnlindquist

import "@johnlindquist/kit"

// Display a terminal with the npm outdated command for globally installed packages 
await term({
  command: "npm outdated -g", // List outdated global packages 
  shortcuts: [],
}) 
```

## Get Latest News Headlines

```typescript
// Name: News Headlines
// Description: Fetches and displays the latest news headlines
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the News API key from the environment 
// https://newsapi.org/ 
const newsApiKey = await env("NEWS_API_KEY") 

// Prompt for a news category
let category = await arg("Enter news category (e.g., 'technology'):")

// Fetch news headlines from the News API 
const response = await get( 
  `https://newsapi.org/v2/top-headlines?category=${category}&apiKey=${newsApiKey}` 
)

// Extract and display the headlines
const headlines = response.data.articles.map(article => `- [${article.title}](${article.url})`).join("\n")

await div(md(`# Top Headlines in ${category}:\n\n${headlines}`)) 
```

## Convert a Video File to a Different Format

```typescript
// Name: Video Converter 
// Description: Converts a video file to a different format using FFmpeg 
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the input video file path
const videoPath = await path({
  hint: "Select a video file to convert"
})

// Prompt for the desired output format
const outputFormat = await arg("Enter desired output format (e.g., mp4, avi, mov):") 

// Construct the output file path 
const outputPath = videoPath.replace(/\.[^/.]+$/, `.${outputFormat}`)

// Execute FFmpeg command to convert the video 
await execa(
  "ffmpeg",
  ["-i", videoPath, outputPath], 
  {
    stdio: "inherit" // Display FFmpeg output in the terminal
  } 
)

// Reveal the converted video file in Finder
await revealFile(outputPath)
```

## Get the Definition of a Word

```typescript
// Name: Define Word
// Description: Retrieves and displays the definition of a word 
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the word
const word = await arg("Enter a word:")

// Fetch word definition from the Dictionary API 
const response = await get(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`)

// Extract and display the first definition
const definition = response.data[0].meanings[0].definitions[0].definition

await div(md(`## Definition of "${word}":\n\n${definition}`))
```
## Generate Random Password and Store in Keychain

```typescript
// Name: Generate Password and Store in Keychain
// Description: Generates a random password and stores it in the system keychain
// Author: johnlindquist 

import "@johnlindquist/kit"
import { generate } from "generate-password"

// Prompt for the account or service name
const account = await arg("Enter account or service name:")

// Generate a random password
const password = generate({
  length: 20,
  numbers: true,
  symbols: true, 
  uppercase: true, 
  lowercase: true,
  excludeSimilarCharacters: true,
}) 

// Store the password in the keychain
await keychain.setItem({
  account, 
  password, 
  service: "Script Kit" // You can set a custom service name
})

// Copy the password to the clipboard
await copy(password)

// Display a confirmation message 
await div(md(`# Password for ${account} generated and saved to keychain.

Password also copied to clipboard:

\`\`\`
${password}
\`\`\`
`)) 
```

## Get Current Location Information

```typescript
// Name: Get Location
// Description: Fetches and displays your current location information
// Author: johnlindquist

import "@johnlindquist/kit"

// Get location information using the browser's geolocation API
const location = await getLocation();

await div(md(`# Your Location:

* Latitude: ${location.latitude}
* Longitude: ${location.longitude}
* Accuracy: ${location.accuracy} meters 
`)) 
```

## Create a New Branch and Switch to It

```typescript
// Name: Git New Branch and Switch
// Description: Creates a new branch and switches to it
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the branch name 
let branchName = await arg("Enter new branch name:")

// Execute Git commands to create the branch and switch to it 
await $`git checkout -b ${branchName}`

console.log(`Switched to new branch: ${branchName}`);
```

## Generate and Display a Random Chuck Norris Joke

```typescript
// Name: Chuck Norris Joke
// Description: Fetches and displays a random Chuck Norris joke
// Author: johnlindquist

import "@johnlindquist/kit" 

// Fetch a random Chuck Norris joke from the ICNDb API
const response = await get("https://api.chucknorris.io/jokes/random");

// Extract the joke 
const { value: joke } = response.data

// Display the joke in a div prompt
await div(md(`# ${joke}`))
```

## Download and Install a VS Code Extension

```typescript
// Name: Install VS Code Extension 
// Description: Downloads and installs a VS Code extension
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt for the extension ID 
const extensionId = await arg("Enter VS Code extension ID:")

// Construct the VS Code command to install the extension 
const command = `code --install-extension ${extensionId}`

// Display a terminal with the installation command
await term({
  command,
  cwd: home(),
  height: 140, 
  enter: "Exit",
  shortcuts: [], 
}) 
```

## Set a Timer

```typescript
// Name: Timer
// Description: Sets a timer for a specified duration 
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the timer duration in seconds 
let durationInSeconds = parseInt(await arg("Enter duration in seconds:"))

// Update the prompt every second with the remaining time 
let intervalId = setInterval(() => {
  durationInSeconds--;
  // Display the remaining time 
  setPlaceholder(`Time remaining: ${durationInSeconds}`)

  // Clear the interval when the timer reaches zero 
  if (durationInSeconds === 0) {
    clearInterval(intervalId)
    setPlaceholder(`Time's up!`) 
    beep() // Play a beep sound when the timer ends
  }
}, 1000)

// Prompt the user to stop the timer (this will block until the timer ends or is stopped)
await arg({
  placeholder: `Time remaining: ${durationInSeconds}`,
  enter: "Stop Timer",
}) 

clearInterval(intervalId);
console.log("Timer stopped.")
```

## Create a New Meeting in Microsoft Teams

```typescript
// Name: Schedule Teams Meeting
// Description: Creates a new Microsoft Teams meeting and copies the join link to the clipboard 
// Author: johnlindquist

import "@johnlindquist/kit"
import { Client } from "@microsoft/microsoft-graph-client"

// Get the Microsoft Graph API token from the environment
// https://docs.microsoft.com/en-us/graph/auth/
const graphToken = await env("GRAPH_TOKEN") 

// Initialize the Microsoft Graph client
const graphClient = Client.init({
  authProvider: (done) => { 
    done(null, graphToken) 
  },
});

// Prompt for meeting details 
const meetingSubject = await arg("Enter meeting subject:") 
const meetingStartTime = await arg(
  "Enter meeting start time (YYYY-MM-DDTHH:mm:ss):"
)
const meetingEndTime = await arg(
  "Enter meeting end time (YYYY-MM-DDTHH:mm:ss):"
)

// Create a new online meeting
const newMeeting = await graphClient
  .api("/me/onlineMeetings")
  .post({
    startDateTime: meetingStartTime,
    endDateTime: meetingEndTime,
    subject: meetingSubject, 
  })

// Copy the meeting join URL to the clipboard
await copy(newMeeting.joinUrl)

// Display confirmation message 
await div(md(`# Teams Meeting Created 

Join URL copied to clipboard: 

[${newMeeting.joinUrl}](${newMeeting.joinUrl})`)) 
```


## Convert Text to Speech with Different Voices

```typescript
// Name: Text to Speech with Voice Selection
// Description: Converts text to speech with selectable voices using OpenAI
// Author: johnlindquist

import "@johnlindquist/kit"
import { Configuration, OpenAIApi } from "openai"

// Get the OpenAI API key from the environment 
// https://beta.openai.com/account/api-keys
const openaiApiKey = await env("OPENAI_API_KEY"); 

// Initialize OpenAI API
const openai = new OpenAIApi(new Configuration({ apiKey: openaiApiKey }))

// Define a list of available voices
const voices = [
  "alloy",
  "echo", 
  "fable",
  "onyx",
  "nova",
  "shimmer",
];

// Prompt for text input
const inputText = await arg("Enter text to convert to speech:")

// Prompt for voice selection
const selectedVoice = await arg("Select a voice:", voices)

// Generate speech audio with the selected voice
const response = await openai.audio.speech.create({
  model: "tts-1",
  voice: selectedVoice, 
  input: inputText, 
}) 

// Save the audio data as an MP3 file
const audioFilePath = tmpPath("speech.mp3") 
const audioArrayBuffer = await response.arrayBuffer(); 
const audioBuffer = Buffer.from(audioArrayBuffer);
await writeFile(audioFilePath, audioBuffer);

// Play the generated speech
await playAudioFile(audioFilePath) 

console.log("Text converted to speech with selected voice and played successfully.")
```

## Create a New Trello Board

```typescript
// Name: Create Trello Board
// Description: Creates a new Trello board
// Author: johnlindquist

import "@johnlindquist/kit" 

// Get the Trello API key and token from the environment
// https://developer.atlassian.com/cloud/trello/guides/rest-api/authorization/ 
const trelloApiKey = await env("TRELLO_API_KEY")
const trelloToken = await env("TRELLO_TOKEN")

// Prompt for the board name
const boardName = await arg("Enter board name:") 

// Create a new Trello board 
await post( 
  `https://api.trello.com/1/boards/?key=${trelloApiKey}&token=${trelloToken}`,
  {
    name: boardName, 
    // defaultLists: false, // Set to true to create default lists (To Do, Doing, Done)
    // prefs_permissionLevel: "private", // Set board permission level (private, public, org)
  } 
) 

console.log(`Trello board "${boardName}" created successfully.`) 
```

## Convert Text to Emojis

```typescript
// Name: Emoji Converter
// Description: Converts text to emojis using the emojilib library
// Author: johnlindquist

import "@johnlindquist/kit"
import { emojilib } from "emojilib"

// Prompt for text input
const text = await arg("Enter text:")

// Convert text to emojis
const emojiText = text
  .split(" ") 
  .map(word => {
    // Find the emoji for the word (or return the word if not found) 
    const emoji = emojilib.lib[word.toLowerCase()] ? emojilib.lib[word.toLowerCase()].char : word;
    return emoji;
  })
  .join(" ")

// Display the emoji text in the editor 
await editor(emojiText) 
```

##  Check for and Install Missing Fonts

```typescript
// Name: Font Installer
// Description: Checks for and installs missing fonts 
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the font name
const fontName = await arg("Enter font name:") 

// Check if the font is already installed 
let fontInstalled = false
// ... (Implement logic to check if the font is installed)

if (fontInstalled) {
  // Display a message if the font is already installed
  await div(md(`# Font "${fontName}" is already installed.`))
} else {
  // Display a prompt asking if the user wants to install the font 
  let installFont = await arg(
    `Font "${fontName}" not found. Install it?`,
    ["yes", "no"]
  ) 

  if (installFont === "yes") {
    // Download and install the font (replace with your font installation logic) 
    // ...
    console.log(`Font "${fontName}" installed successfully.`) 
  }
} 
```

## Create a New Branch in Git

```typescript
// Name: Create Git Branch
// Description: Creates a new Git branch
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the branch name 
let branchName = await arg("Enter new branch name:")

// Execute the Git command to create the branch 
await $`git branch ${branchName}` 

console.log(`Branch ${branchName} created.`)
```

## Get the Current Bitcoin Price in Multiple Currencies

```typescript
// Name: Bitcoin Price (Multiple Currencies)
// Description: Displays the Bitcoin price in different currencies 
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the desired currencies (comma-separated)
const currencies = (await arg("Enter currencies (comma-separated, e.g., USD,EUR,GBP):"))
  .split(",") 
  .map(currency => currency.trim()) 

// Construct the query string for the CoinGecko API 
const queryString = currencies.join(",")

// Fetch Bitcoin price in the specified currencies from the CoinGecko API 
const response = await get(`https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=${queryString}`) 

// Create a markdown-formatted string for the Bitcoin prices
let output = `# Bitcoin Price:\n\n`
for (const currency of currencies) { 
  output += `* ${currency}: $${response.data.bitcoin[currency.toLowerCase()]}\n`
}

// Display the Bitcoin prices in a div 
await div(md(output.trim()))
```

##  Check and Update Python Package 

```typescript
// Name: Update Python Package
// Description: Checks for and updates a Python package using pip
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the package name
const packageName = await arg("Enter Python package name:")

// Check for updates using pip
let updateAvailable = false 
try {
  // Run pip to check for updates to the package
  await execa("pip", ["install", "--upgrade", packageName]) 
  updateAvailable = true
} catch (error) {
  // If pip throws an error, display a message in the terminal 
  console.error(error) 
} 

// If an update is available, notify the user 
if (updateAvailable) {
  await notify({
    title: "Package Updated",
    message: `Package "${packageName}" updated successfully.`,
  })
} else {
  // If no update is found, display a message in a div 
  await div(md(`# No updates found for "${packageName}".`))
}
```




## Get Directions Using Google Maps

```typescript
// Name: Get Directions (Google Maps)
// Description: Gets directions from current location to a destination using Google Maps
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the destination address
const destination = await arg("Enter destination:")

// Construct the Google Maps URL
const mapsUrl = `https://www.google.com/maps/dir/?api=1&destination=${encodeURIComponent(destination)}`

// Open the URL in the browser 
open(mapsUrl) 
```

## Check if a Website is Down

```typescript
// Name: Website Down Checker
// Description: Checks if a website is down for everyone or just you 
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the website URL
const websiteUrl = await arg("Enter website URL:") 

try {
  // Attempt to fetch the website
  const response = await fetch(websiteUrl) 
  // Check the status code
  if (response.ok) {
    // If the status is OK, the website is up
    await div(md(`# ${websiteUrl} is up!`)) 
  } else { 
    // If the status is not OK, the website might be down
    await div(md(`# ${websiteUrl} might be down. Status code: ${response.status}`)) 
  }
} catch (error) { 
  // If there is an error fetching the website, it's likely down 
  await div(md(`# ${websiteUrl} is likely down.\n\nError: ${error.message}`))
}
```

## Create a New Playlist on Spotify

```typescript
// Name: Create Spotify Playlist
// Description: Creates a new playlist on Spotify
// Author: johnlindquist 

import "@johnlindquist/kit"
import SpotifyWebApi from "spotify-web-api-node"; 

// Get the Spotify API client ID and secret from the environment
// https://developer.spotify.com/dashboard/applications
const spotifyClientId = await env("SPOTIFY_CLIENT_ID")
const spotifyClientSecret = await env("SPOTIFY_CLIENT_SECRET");

// Initialize Spotify API client
const spotifyApi = new SpotifyWebApi({
  clientId: spotifyClientId,
  clientSecret: spotifyClientSecret, 
  redirectUri: "http://localhost:8888/callback", // Replace with your redirect URI 
}) 
// Authorize with Spotify API (This may require user interaction) 
const authorizeUrl = spotifyApi.createAuthorizeURL(
  ["playlist-modify-private", "playlist-modify-public"],
  // Generate a random state parameter 
  Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15)
)
await open(authorizeUrl)

// Retrieve the authorization code from the URL (This part may require manual input or setting up a local server to handle the redirect)
const authorizationCode = await arg("Enter authorization code:");

// Get an access token
spotifyApi.authorizationCodeGrant(authorizationCode).then(
  (data) => {
    // Set the access token on the API object to use it in later calls
    spotifyApi.setAccessToken(data.body['access_token']);
    spotifyApi.setRefreshToken(data.body['refresh_token']);
  }, 
  (err) => { 
    console.log('Something went wrong!', err);
  }
)

// Prompt for the playlist name
const playlistName = await arg("Enter playlist name:");

// Get the user's Spotify ID (This requires a valid access token)
const { body: meData } = await spotifyApi.getMe() 

// Create the playlist 
await spotifyApi.createPlaylist(meData.id, playlistName, { public: false })
  .then(
    function(data) {
      console.log('Created playlist!');
    },
    function(err) {
      console.log('Something went wrong!', err); 
    } 
  );
```

##  Convert a Timestamp to a Readable Date and Time

```typescript
// Name: Timestamp Converter
// Description: Converts a Unix timestamp to a human-readable date and time 
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the Unix timestamp
const timestamp = parseInt(await arg("Enter Unix timestamp:"), 10)

// Convert the timestamp to a Date object
const date = new Date(timestamp * 1000); 

// Format and display the date and time 
await div(md(`# ${date.toLocaleString()}`))
```

## Create and Add a Task to a Reminders List

```typescript
// Name: Add Reminder
// Description: Creates a new reminder in the Reminders app
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the reminder title
const reminderTitle = await arg("Enter reminder title:")

// Create a new reminder using AppleScript 
await applescript(
  `tell application "Reminders" 
    make new reminder with properties {name: "${reminderTitle}"} 
  end tell`
)

console.log(`Reminder "${reminderTitle}" added.`)
```

## Download and Display GitHub Profile Picture

```typescript
// Name: Show GitHub Profile Picture
// Description: Displays the profile picture of a GitHub user
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the GitHub username
const username = await arg("Enter GitHub username:")

// Fetch the user's profile data from the GitHub API 
const { data: userData } = await get(
  `https://api.github.com/users/${username}`
);

// Extract the avatar URL 
const avatarUrl = userData.avatar_url; 

// Display the avatar image in a div prompt
await div({
  html: `<img src="${avatarUrl}" alt="${username}'s avatar" class="rounded-full h-48 w-48 mx-auto">`, 
  width: 256,
  height: 256, 
  enter: "", // Disable the Enter key
  shortcuts: [], // Disable default shortcuts 
});
```

##  Generate a Random Joke and Post it to Slack

```typescript
// Name: Slack Joke Bot 
// Description: Fetches a random joke and posts it to a Slack channel
// Author: johnlindquist 

import "@johnlindquist/kit" 

// Get the Slack webhook URL from the environment
// https://api.slack.com/messaging/webhooks 
const slackWebhookUrl = await env("SLACK_WEBHOOK_URL");

// Fetch a random joke from the JokeAPI
const response = await get("https://v2.jokeapi.dev/joke/Any?safe-mode"); 

// Extract the joke setup and delivery (if applicable) 
const { setup, delivery, joke } = response.data

// Construct the joke string 
const jokeText = setup ? `${setup}\n\n${delivery}` : joke

// Send the joke to Slack
await post(slackWebhookUrl, {
  text: jokeText, 
})

console.log("Joke sent to Slack."); 
```

## Search and Open a Wikipedia Article

```typescript
// Name: Wikipedia Search
// Description: Searches Wikipedia and opens the first result
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the search query
const query = await arg("Enter search query:") 

// Fetch search results from the Wikipedia API
const response = await get(
  `https://en.wikipedia.org/w/api.php?action=query&list=search&srsearch=${encodeURIComponent(
    query
  )}&format=json`
); 

// Extract the first search result's title
const firstResultTitle = response.data.query.search[0].title

// Construct the Wikipedia article URL
const wikipediaUrl = `https://en.wikipedia.org/wiki/${encodeURIComponent(firstResultTitle)}` 

// Open the Wikipedia article in the browser
open(wikipediaUrl) 
```




## Create and Send a Personalized Email with Gmail API

```typescript
// Name: Send Personalized Gmail
// Description: Sends a personalized email using the Gmail API
// Author: johnlindquist

import "@johnlindquist/kit"
import { google } from "googleapis";
import { Base64 } from "js-base64";

// Get the Gmail API credentials from the environment
// https://developers.google.com/gmail/api/quickstart/nodejs
const gmailCredentials = JSON.parse(await env("GMAIL_CREDENTIALS"))
// Authorize with the Gmail API
const auth = new google.auth.GoogleAuth({
  credentials: gmailCredentials, 
  scopes: ["https://www.googleapis.com/auth/gmail.send"],
}) 
const gmail = google.gmail({ version: "v1", auth });

// Prompt for the recipient's email address
const recipientEmail = await arg("Enter recipient's email address:"); 

// Prompt for the email subject
const subject = await arg("Enter email subject:");

// Prompt for the email body 
const body = await arg("Enter email body:")

// Create the email message
const message = [ 
  `To: ${recipientEmail}`,
  `Subject: ${subject}`, 
  ``, 
  body,
].join("\n"); 

// Encode the message in Base64 for sending via the Gmail API
const encodedMessage = Base64.encode(message);

// Send the email
await gmail.users.messages.send({
  userId: "me", 
  requestBody: {
    raw: encodedMessage,
  },
});

console.log(`Email sent to ${recipientEmail}.`);
```

## Convert Text to Audio with Google Cloud Text-to-Speech

```typescript
// Name: Text to Speech (Google Cloud)
// Description: Converts text to speech using Google Cloud Text-to-Speech
// Author: johnlindquist

import "@johnlindquist/kit"
import textToSpeech from "@google-cloud/text-to-speech" 

// Get the Google Cloud credentials from the environment
// https://cloud.google.com/docs/authentication/getting-started 
const googleCloudCredentials = JSON.parse(await env("GOOGLE_CLOUD_CREDENTIALS"))

// Creates a client
const client = new textToSpeech.TextToSpeechClient({
  credentials: googleCloudCredentials,
})

// Prompt for text input
const text = await arg("Enter text:") 

// Select the voice (replace with your desired voice name and language code) 
const voice = {
  languageCode: "en-US", 
  name: "en-US-Wavenet-F", 
}

// Select the audio encoding
const audioConfig = { 
  audioEncoding: "MP3" 
} 

// Construct the request 
const request = {
  input: { text: text }, 
  voice: voice, 
  audioConfig: audioConfig,
}

// Perform the text-to-speech request
const [response] = await client.synthesizeSpeech(request) 

// Write the audio content to a file
const audioFilePath = tmpPath("output.mp3")
await writeFile(audioFilePath, response.audioContent, "binary");

// Play the audio file 
await playAudioFile(audioFilePath) 
```

## Get a List of Commits for a Specific File

```typescript
// Name: Get File Commits 
// Description: Displays a list of commits for a file in the current Git repository 
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the file path
const filePath = await path({ 
  hint: "Select a file",
}) 

// Execute the Git command to retrieve commits for the file 
const { stdout } = await exec(`git log --pretty=format:"%h - %s (%ad)" --date=short -- "${filePath}"`)

// Display the commit history in the editor
await editor({
  value: stdout,
  language: "text", 
})
```

##  Generate a Random UUID

```typescript
// Name: Generate UUID
// Description: Generates a Universally Unique Identifier (UUID) 
// Author: johnlindquist

import "@johnlindquist/kit"

// Generate a UUID using the crypto module
const generatedUUID = crypto.randomUUID(); 

// Copy the generated UUID to the clipboard 
await copy(generatedUUID)

// Display the generated UUID in a div prompt 
await div(md(`# UUID: \n\n${generatedUUID}`))
```

##  Check for Outdated Global Python Packages

```typescript
// Name: Check for Global Python Updates
// Description: Checks for outdated globally installed Python packages
// Author: johnlindquist

import "@johnlindquist/kit" 

// Display a terminal with the pip list --outdated command to list outdated global packages
await term({ 
  command: "pip list --outdated", 
  shortcuts: [],
})
```

##  Create and Open a New Text File

```typescript
// Name: Create Text File
// Description: Creates a new text file and opens it in the default editor
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt for the file name 
const fileName = await arg("Enter file name:")

// Create the file with default content
await writeFile(fileName, "")

// Open the file in the default editor 
await open(fileName)
```

## Create and Add a Note to Evernote

```typescript
// Name: Create Evernote Note 
// Description: Creates a new note in Evernote 
// Author: johnlindquist

import "@johnlindquist/kit"
import Evernote from "evernote"; 

// Get the Evernote developer token from the environment
// https://dev.evernote.com/doc/articles/dev_tokens.php
const evernoteToken = await env("EVERNOTE_DEVELOPER_TOKEN"); 

// Prompt for the note title 
const noteTitle = await arg("Enter note title:")

// Prompt for the note content using the editor
const noteContent = await editor({
  placeholder: "Enter note content:", 
  language: "markdown",
})

// Initialize the Evernote client 
const client = new Evernote.Client({ token: evernoteToken }); 

// Create a new note object
const note = new Evernote.Types.Note(); 
note.title = noteTitle;

// Set the note content, wrapping it in HTML tags for Evernote compatibility
note.content = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd">
<en-note>${noteContent}</en-note>`; 

// Create the note in Evernote 
await client.noteStore.createNote(note);

console.log(`Note "${noteTitle}" created in Evernote.`)
```




## Download a File with Curl and Display Progress

```typescript
// Name: Download File with Curl
// Description: Downloads a file from a URL using Curl and displays the progress
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the download URL
const url = await arg("Enter URL to download:") 

// Construct the output file path
const outputPath = tmpPath(path.basename(url))

// Execute the Curl command to download the file with progress
await exec(`curl -o "${outputPath}" -# "${url}"`, { 
  // Pass the current working directory to the child process
  cwd: process.cwd(),
  // Display the output in the terminal
  stdio: "inherit", 
})

console.log(`File downloaded to: ${outputPath}`)
```

## Get Directions Using Waze

```typescript
// Name: Get Directions (Waze)
// Description: Gets directions from current location to a destination using Waze 
// Author: johnlindquist 

import "@johnlindquist/kit" 

// Prompt for the destination address
const destination = await arg("Enter destination:")

// Construct the Waze URL scheme
const wazeUrl = `waze://?q=${encodeURIComponent(destination)}&navigate=yes`

// Open the URL in Waze
open(wazeUrl) 
```

##  Create and Send a New Email with Mailgun

```typescript
// Name: Send Email with Mailgun 
// Description: Sends an email using the Mailgun API
// Author: johnlindquist 

import "@johnlindquist/kit"
import FormData from "form-data"

// Get the Mailgun API key and domain from the environment
// https://www.mailgun.com/cp/ 
const mailgunApiKey = await env("MAILGUN_API_KEY")
const mailgunDomain = await env("MAILGUN_DOMAIN") 

// Prompt for the recipient's email address
const recipientEmail = await arg("Enter recipient email address:") 

// Prompt for the email subject
const subject = await arg("Enter email subject:");

// Prompt for the email body 
const body = await arg("Enter email body:"); 

// Create a new FormData instance
const formData = new FormData()
formData.append("from", `Script Kit <postmaster@${mailgunDomain}>`) 
formData.append("to", recipientEmail) 
formData.append("subject", subject) 
formData.append("text", body)

// Send the email using the Mailgun API 
await fetch(
  `https://api.mailgun.net/v3/${mailgunDomain}/messages`,
  {
    method: "POST",
    headers: {
      Authorization: `Basic ${Buffer.from(`api:${mailgunApiKey}`).toString("base64")}`, 
    },
    body: formData as any,
  }
);

console.log(`Email sent to ${recipientEmail} using Mailgun.`)
```

## Get a List of Files in a Directory

```typescript
// Name: List Files in Directory
// Description: Lists files in a selected directory
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt for the directory path
const directoryPath = await path({
  hint: "Select a directory", 
  onlyDirs: true,
}) 

// Get the list of files in the directory 
const files = await readdir(directoryPath) 

// Display the files in the editor
await editor({
  value: files.join("\n"), 
  language: "text",
})
```

## Generate a Random Password and Save to a File

```typescript
// Name: Generate and Save Password
// Description: Generates a random password and saves it to a file 
// Author: johnlindquist

import "@johnlindquist/kit"
import { generate } from "generate-password"

// Prompt for the desired password length 
const passwordLength = parseInt(await arg("Enter password length:"))

// Generate a random password
const password = generate({ 
  length: passwordLength,
  numbers: true, 
  symbols: true, 
  uppercase: true, 
  lowercase: true, 
  excludeSimilarCharacters: true, 
}); 

// Prompt for the file path to save the password
const filePath = await path({
  hint: "Select a location to save the password",
})

// Write the password to the file
await writeFile(filePath, password) 

console.log(`Password saved to: ${filePath}`)
```

## Get the Definition of a Word from Merriam-Webster

```typescript
// Name: Define Word (Merriam-Webster)
// Description: Retrieves and displays the definition of a word from Merriam-Webster
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the Merriam-Webster API key from the environment
// https://dictionaryapi.com/ 
const merriamWebsterApiKey = await env("MERRIAM_WEBSTER_API_KEY")

// Prompt for the word 
const word = await arg("Enter a word:")

// Fetch the word definition from the Merriam-Webster API
const response = await get( 
  `https://www.dictionaryapi.com/api/v3/references/collegiate/json/${word}?key=${merriamWebsterApiKey}`
); 

// Extract and display the first definition
const definition = response.data[0].shortdef[0]

await div(md(`## Definition of "${word}":\n\n${definition}`)) 
```

## Search and Open a YouTube Video

```typescript
// Name: Search YouTube
// Description: Searches for a video on YouTube and opens the first result
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the search query
const query = await arg("Enter your search query:") 

// Construct the YouTube search URL 
const youtubeUrl = `https://www.youtube.com/results?search_query=${encodeURIComponent(query)}` 

// Open the YouTube search results in the browser
open(youtubeUrl)
```


## Get a List of Running Processes

```typescript
// Name: Process Viewer
// Description: Displays a list of currently running processes
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the list of running processes
const processes = await getProcesses()

// Create an array of choices from the processes, with process name and ID
let processChoices = processes.map(p => ({
  name: `${p.name} (PID: ${p.pid})`,
  value: p.pid,
  description: p.scriptPath,
}))

// Display the list of processes in a prompt
let selectedPid = await arg(
  {
    placeholder: "Select a process:",
    enter: "Terminate",
  },
  processChoices
)

// Ask the user to confirm termination
let shouldTerminate = await arg(
  `Terminate process ${selectedPid}? This action cannot be undone.`,
  [
    { name: "Yes, terminate", value: true },
    { name: "No, cancel", value: false },
  ]
)

// Terminate the process if the user confirms
if (shouldTerminate) {
  process.kill(selectedPid)
  await div(md(`# Process ${selectedPid} terminated.`))
}
```

## Check for and Install Missing System Updates

```typescript
// Name: Install System Updates
// Description: Checks for and installs available system updates
// Author: johnlindquist

import "@johnlindquist/kit"

// Display a terminal prompting the user to install updates
await term({
  command: "softwareupdate --install --all", // Install all available updates
  preview: md(`# Installing System Updates

This will install all available system updates. Make sure to save your work before proceeding.

Press Enter to continue or Escape to cancel.
`),
  shortcuts: [], // Disable default shortcuts
})
```

## Download and Extract a ZIP File

```typescript
// Name: Download and Extract ZIP
// Description: Downloads a ZIP file from a URL and extracts it
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the URL of the ZIP file
const url = await arg("Enter ZIP file URL:")

// Set the output directory for the extracted files
const outputDir = tmpPath()

// Download and extract the ZIP file
await download(url, outputDir, { extract: true })

console.log(`ZIP file downloaded and extracted to: ${outputDir}`)
```

##  Resize Images to a Specific Height

```typescript
// Name: Resize Images to Height
// Description: Resizes images in a directory to a specific height
// Author: johnlindquist

import "@johnlindquist/kit"
import { globby } from "globby"
import sharp from "sharp"

// Prompt for the directory containing images
const directoryPath = await path({
  hint: "Select directory containing images:",
  onlyDirs: true,
})

// Get all image files in the directory
const imageFiles = await globby([
  `${directoryPath}/*.jpg`, 
  `${directoryPath}/*.jpeg`,
  `${directoryPath}/*.png`,
], {
  expandDirectories: {
    extensions: ["jpg", "jpeg", "png"], 
  }, 
})

// Prompt for the new height 
const newHeight = parseInt(await arg("Enter new height in pixels:")) 

// Resize each image, maintaining aspect ratio
for (const file of imageFiles) {
  await sharp(file)
    .resize({ height: newHeight }) 
    .toFile(file)

  console.log(`Resized: ${file}`)
}

console.log("All images resized.")
```

##  Get a List of Trello Cards in a List

```typescript
// Name: List Trello Cards 
// Description: Retrieves and displays a list of cards in a Trello list
// Author: johnlindquist

import "@johnlindquist/kit" 

// Get the Trello API key and token from the environment 
// https://developer.atlassian.com/cloud/trello/guides/rest-api/authorization/
const trelloApiKey = await env("TRELLO_API_KEY") 
const trelloToken = await env("TRELLO_TOKEN") 

// Prompt for the list ID
const listId = await arg({
  placeholder: "Enter Trello list ID:",
}) 

// Get the cards from the Trello list 
const response = await get(`https://api.trello.com/1/lists/${listId}/cards?key=${trelloApiKey}&token=${trelloToken}`)

// Display the card names in the editor
await editor({
  value: response.data.map(card => card.name).join("\n"),
  language: "text",
}) 
```

## Get System CPU Usage

```typescript
// Name: CPU Usage
// Description: Displays the current CPU usage
// Author: johnlindquist

import "@johnlindquist/kit"
import os from "os"

// Get CPU usage information
const cpus = os.cpus()

// Calculate average CPU usage
let totalUsage = 0
for (const cpu of cpus) {
  for (const type in cpu.times) {
    totalUsage += cpu.times[type]
  }
} 
const averageUsage = (totalUsage / (cpus.length * Object.keys(cpus[0].times).length)) * 100

// Display CPU usage in a div 
await div(md(`# Current CPU Usage: ${averageUsage.toFixed(2)}%`))
```

##  Send a Message to a Discord Channel

```typescript
// Name: Send Discord Message
// Description: Sends a message to a Discord channel
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the Discord webhook URL from the environment
// https://discord.com/developers/docs/intro 
const discordWebhookUrl = await env("DISCORD_WEBHOOK_URL")

// Prompt for the message content 
const message = await arg("Enter your message:") 

// Send the message to the Discord channel
await post(
  discordWebhookUrl, 
  {
    content: message,
  }
)

console.log(`Message "${message}" sent to Discord.`);
```



## Resize and Convert Images in Bulk

```typescript
// Name: Bulk Image Converter and Resizer
// Description: Converts and resizes multiple images in a directory
// Author: johnlindquist

import "@johnlindquist/kit"
import { globby } from "globby"
import sharp from "sharp"

// Prompt for the directory containing images
const directoryPath = await path({
  hint: "Select directory containing images:",
  onlyDirs: true,
})

// Get all image files in the directory
const imageFiles = await globby([
  `${directoryPath}/*.jpg`,
  `${directoryPath}/*.jpeg`,
  `${directoryPath}/*.png`,
], {
  expandDirectories: {
    extensions: ["jpg", "jpeg", "png"],
  },
});

// Prompt for the desired output format 
const outputFormat = await arg("Enter desired output format (e.g., png, webp, jpg):")

// Prompt for the new width
const newWidth = parseInt(await arg("Enter new width in pixels:"));

// Resize and convert each image file
for (const file of imageFiles) {
  // Construct the output file path with the new extension
  const outputFilePath = file.replace(/\.[^/.]+$/, `.${outputFormat}`)
  
  // Resize and convert the image using Sharp
  await sharp(file) 
    .resize({ width: newWidth })
    .toFormat(outputFormat, { quality: 80 }) // Adjust quality as needed
    .toFile(outputFilePath);

  console.log(`Converted and resized: ${file} to ${outputFilePath}`)
}

console.log("All images converted and resized.") 
```

## Create a New Branch and Push to Remote

```typescript
// Name: Git New Branch and Push
// Description: Creates a new Git branch and pushes it to the remote
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the new branch name 
const branchName = await arg("Enter new branch name:")

// Execute the Git commands to create and push the branch
await $`git checkout -b ${branchName}` 
await $`git push -u origin ${branchName}`

console.log(`Created and pushed branch: ${branchName}`) 
```

## Check for Available Disk Space

```typescript
// Name: Check Disk Space
// Description: Displays available disk space information
// Author: johnlindquist

import "@johnlindquist/kit" 
import { checkDiskSpace } from "check-disk-space"

// Get disk space information for the root path 
const diskSpace = await checkDiskSpace("/") 

// Display disk space information in a div 
await div(md(`
# Disk Space: 

* Total: ${filesize(diskSpace.size)}
* Free: ${filesize(diskSpace.free)} 
`))
```

## Get a List of Files Changed in the Last Commit

```typescript
// Name: Get Last Commit Changes 
// Description: Lists files changed in the last Git commit 
// Author: johnlindquist 

import "@johnlindquist/kit"

// Execute the Git command to retrieve changed files from the last commit 
const { stdout: changedFiles } = await exec(
  "git diff-tree --no-commit-id --name-only -r HEAD"
) 

// Display the list of changed files in the editor 
await editor({
  value: changedFiles,
  language: "text",
})
```

## Download a File from Dropbox

```typescript
// Name: Download from Dropbox
// Description: Downloads a file from your Dropbox 
// Author: johnlindquist

import "@johnlindquist/kit"
import { Dropbox } from "dropbox"

// Get the Dropbox API token from the environment 
// https://www.dropbox.com/developers/apps 
const dropboxToken = await env("DROPBOX_TOKEN") 

// Initialize the Dropbox client 
const dbx = new Dropbox({ accessToken: dropboxToken });

// Prompt for the file path on Dropbox 
const filePath = await arg("Enter Dropbox file path:") 

// Download the file from Dropbox
const { result: fileData } = await dbx.filesDownload({ path: filePath })

// Construct the output file path
const outputPath = tmpPath(path.basename(filePath))

// Write the file data to the output path
await writeFile(outputPath, fileData.fileBinary, "binary")

console.log(`File downloaded from Dropbox: ${outputPath}`)
```

## Get the Current Time in Different Time Zones

```typescript
// Name: World Clock 
// Description: Displays the current time in different time zones 
// Author: johnlindquist

import "@johnlindquist/kit"
import { DateTime } from "luxon"

// Prompt for the desired time zones (comma-separated) 
const timeZonesString = await arg({
  placeholder: "Enter time zones (comma-separated, e.g., America/New_York,Europe/London,Asia/Tokyo):",
}); 
const timeZones = timeZonesString.split(",").map((timeZone) => timeZone.trim());

// Display the current time in each time zone
let output = "# Current Time in Different Time Zones:\n\n"; 
for (const timeZone of timeZones) {
  output += `* ${timeZone}: ${DateTime.now().setZone(timeZone).toLocaleString(DateTime.DATETIME_MED)}\n`
}

await div(md(output.trim()))
```

## Get a List of Your GitHub Repositories

```typescript
// Name: List GitHub Repositories
// Description: Displays a list of your GitHub repositories
// Author: johnlindquist

import "@johnlindquist/kit"
import { Octokit } from "@octokit/rest"

// Get the GitHub API token from the environment
// https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token 
const githubToken = await env("GITHUB_TOKEN")

// Initialize the GitHub API client 
const octokit = new Octokit({ auth: githubToken });

// Fetch the list of your repositories
const { data: repositories } = await octokit.repos.listForAuthenticatedUser();

// Create choices from the repositories
let repoChoices = repositories.map(repo => ({
  name: repo.name,
  description: repo.description,
  value: repo.html_url,
})) 

// Prompt for repo selection and open it in the browser
let repoUrl = await arg("Your repositories:", repoChoices); 
await open(repoUrl) 
```
## Convert Speech to Text Using Google Cloud Speech-to-Text

```typescript
// Name: Speech to Text (Google Cloud)
// Description: Converts speech to text using Google Cloud Speech-to-Text
// Author: johnlindquist

import "@johnlindquist/kit"
import speech from "@google-cloud/speech";

// Get Google Cloud credentials from the environment 
// https://cloud.google.com/docs/authentication/getting-started
const googleCloudCredentials = JSON.parse(await env("GOOGLE_CLOUD_CREDENTIALS"))

// Creates a client
const client = new speech.SpeechClient({
  credentials: googleCloudCredentials,
})

// Record audio using the microphone
const audioBuffer = await mic()

// Set audio file path
const audioFilePath = tmpPath("audio.raw");
await writeFile(audioFilePath, audioBuffer); 

// The audio file's encoding, sample rate in hertz, and language code
const audio = {
  uri: `file://${audioFilePath}`,
}
const config = {
  encoding: "LINEAR16",
  sampleRateHertz: 16000,
  languageCode: "en-US",
}
const request = {
  audio: audio,
  config: config,
} 

// Detects speech in the audio file
const [response] = await client.recognize(request)
const transcription = response.results
  .map(result => result.alternatives[0].transcript) 
  .join("\n")

await editor(transcription)
```

##  Generate a QR Code from a URL

```typescript
// Name: QR Code Generator (URL) 
// Description: Generates a QR code for a URL and displays it in a widget 
// Author: johnlindquist

import "@johnlindquist/kit"
import QRCode from "qrcode"

// Prompt for the URL
const url = await arg({ placeholder: "Enter a URL:" })

// Generate the QR code as a data URL 
const qrCodeDataUrl = await QRCode.toDataURL(url) 

// Display the QR code in a widget 
await widget(`
<div class="flex items-center justify-center h-full">
  <img src="${qrCodeDataUrl}" alt="QR Code" />
</div>
`, {
  width: 400,
  height: 400, 
  resizable: true,
})
```

## Create and Push a Git Tag 

```typescript
// Name: Create and Push Git Tag
// Description: Creates a new Git tag and pushes it to the remote repository
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the tag name
const tagName = await arg("Enter tag name:") 

// Execute Git commands to create and push the tag 
await $`git tag -a ${tagName} -m "${tagName}"` 
await $`git push origin ${tagName}`

console.log(`Tag ${tagName} created and pushed to remote.`)
```

## Compress a Directory

```typescript
// Name: Compress Directory
// Description: Compresses a directory into a ZIP archive
// Author: johnlindquist

import "@johnlindquist/kit"
import { create } from "archiver";
import { createWriteStream } from "fs" 

// Prompt for the directory to compress
const directoryPath = await path({ 
  hint: "Select a directory to compress",
  onlyDirs: true, 
}); 

// Create a ZIP archive 
const output = createWriteStream(`${directoryPath}.zip`) 
const archive = create("zip", {
  zlib: { level: 9 } // Set the compression level
});

// Pipe the archive data to the output stream
archive.pipe(output)

// Append the directory to the archive 
archive.directory(directoryPath, path.basename(directoryPath))

// Finalize the archive (this will also close the output stream)
await archive.finalize();

console.log(`Directory compressed to: ${directoryPath}.zip`)
```

## Get a List of Commits Between Two Branches

```typescript
// Name: Git Commits Between Branches 
// Description: Lists commits between two branches 
// Author: johnlindquist 

import "@johnlindquist/kit"

// Prompt for the base branch 
const baseBranch = await arg("Enter base branch:")

// Prompt for the target branch
const targetBranch = await arg("Enter target branch:") 

// Execute the Git command to retrieve commits between the branches
const { stdout: commits } = await exec(`git log --pretty=format:"%h - %s (%an)" ${baseBranch}..${targetBranch}`); 

// Display the list of commits in the editor
await editor({
  value: commits,
  language: "text", 
})
```

##  Find Large Files in a Directory

```typescript
// Name: Find Large Files 
// Description: Finds files larger than a specified size in a directory 
// Author: johnlindquist 

import "@johnlindquist/kit"
import { globby } from "globby"

// Prompt for the directory path
const directoryPath = await path({
  hint: "Select a directory",
  onlyDirs: true,
});

// Prompt for the minimum file size in MB
const minSizeInMb = parseInt(await arg("Enter minimum file size (MB):")) 

// Convert minimum size to bytes
const minSizeInBytes = minSizeInMb * 1024 * 1024 

// Find files larger than the minimum size
const largeFiles = await globby(directoryPath + "/**/*", {
  // Filter files by size 
  filter: async (path: PathLike) => (await stat(path as string)).size > minSizeInBytes, 
}); 

// Display the large files
if (largeFiles.length > 0) {
  await div(md(`# Large Files in ${directoryPath}:\n\n${largeFiles.join("\n")}`)) 
} else { 
  await div(md(`# No large files found in ${directoryPath}.`))
}
```

## Generate a Random Quote and Tweet It

```typescript
// Name: Tweet Random Quote
// Description: Fetches a random quote and tweets it
// Author: johnlindquist 

import "@johnlindquist/kit" 
import Twitter from "twitter-api-v2"

// Get the Twitter API keys from the environment
// https://developer.twitter.com/en/portal/dashboard 
const twitterConsumerKey = await env("TWITTER_CONSUMER_KEY")
const twitterConsumerSecret = await env("TWITTER_CONSUMER_SECRET") 
const twitterAccessTokenKey = await env("TWITTER_ACCESS_TOKEN_KEY")
const twitterAccessTokenSecret = await env("TWITTER_ACCESS_TOKEN_SECRET") 

// Initialize the Twitter API client
const twitterClient = new Twitter({
  appKey: twitterConsumerKey, 
  appSecret: twitterConsumerSecret,
  accessToken: twitterAccessTokenKey, 
  accessSecret: twitterAccessTokenSecret,
});

// Fetch a random quote from the Quotable API 
const response = await get("https://api.quotable.io/random"); 

// Extract the quote content and author 
const { content, author } = response.data 

// Construct the tweet
const tweet = `"${content}" - ${author}` 

// Send the tweet
await twitterClient.v2.tweet(tweet);

console.log(`Tweeted: ${tweet}`)
```




## Create a New Google Docs Document from Template

```typescript
// Name: Create Google Doc from Template
// Description: Creates a new Google Doc from a template file
// Author: johnlindquist

import "@johnlindquist/kit"
import { google } from "googleapis"

// Get the Google Docs API credentials from the environment
// https://developers.google.com/docs/api/quickstart/nodejs
const googleDocsCredentials = JSON.parse(await env("GOOGLE_DOCS_CREDENTIALS"));
// Authorize with the Google Docs API
const auth = new google.auth.GoogleAuth({
  credentials: googleDocsCredentials,
  scopes: ["https://www.googleapis.com/auth/documents"],
});
const docs = google.docs({ version: "v1", auth });

// Prompt for the template file path
const templatePath = await path({
  hint: "Select a Google Docs template file (.docx or .gdoc)", 
}) 

// Read the template file content 
const templateContent = await readFile(templatePath)

// Create a new Google Doc from the template 
const { data: newDoc } = await docs.documents.create({
  requestBody: {
    title: await arg("Enter document title:"),
  }, 
  media: {
    mimeType: templatePath.endsWith(".docx") ? "application/vnd.openxmlformats-officedocument.wordprocessingml.document" : "application/vnd.google-apps.document",
    body: templateContent, 
  },
});

// Open the newly created document in the browser 
await open(newDoc.documentId); 

console.log(`New Google Doc created from template: ${newDoc.documentId}`)
```

## Generate a Short Link with Firebase Dynamic Links

```typescript
// Name: Generate Firebase Dynamic Link
// Description: Generates a Firebase Dynamic Link for a long URL
// Author: johnlindquist

import "@johnlindquist/kit" 

// Get the Firebase API key from the environment
// https://firebase.google.com/docs/projects/api-keys
const firebaseApiKey = await env("FIREBASE_API_KEY")

// Prompt for the long URL
const longDynamicLink = await arg("Enter the long URL:");

// Construct the request body 
const requestBody = {
  longDynamicLink: longDynamicLink,
  suffix: {
    option: "SHORT", // Use a short Dynamic Link
  }, 
};

// Generate the short Dynamic Link using the Firebase API
const response = await post( 
  `https://firebasedynamiclinks.googleapis.com/v1/shortLinks?key=${firebaseApiKey}`,
  requestBody,
  {
    headers: {
      "Content-Type": "application/json",
    }, 
  }
);

// Extract and display the short Dynamic Link
const shortLink = response.data.shortLink

await div(md(`# Shortened Dynamic Link:

[${shortLink}](${shortLink})
`))
```

## Convert Text to Speech Using AWS Polly and Save to File

```typescript
// Name: Text to Speech with AWS Polly (Save to File)
// Description: Converts text to speech using AWS Polly and saves it to a file
// Author: johnlindquist

import "@johnlindquist/kit"
import AWS from "aws-sdk"

// Get the AWS credentials from the environment
// https://docs.aws.amazon.com/sdk-for-javascript/v2/developer-guide/setting-credentials-node.html
const awsAccessKeyId = await env("AWS_ACCESS_KEY_ID")
const awsSecretAccessKey = await env("AWS_SECRET_ACCESS_KEY")

// Configure AWS SDK 
AWS.config.update({
  accessKeyId: awsAccessKeyId,
  secretAccessKey: awsSecretAccessKey,
  region: "us-east-1", // Replace with your desired AWS region
})

// Create an instance of Amazon Polly
const polly = new AWS.Polly()

// Prompt for text input
const inputText = await arg("Enter text:");

// Define the parameters for text-to-speech conversion 
const params = {
  OutputFormat: "mp3", 
  Text: inputText,
  VoiceId: "Joanna", // Replace with your desired voice ID
};

// Convert the text to speech
polly.synthesizeSpeech(params, async (err, data) => {
  if (err) {
    console.error(err)
  } else {
    // Save the audio data to a file
    const audioFilePath = tmpPath(`speech-${Date.now()}.mp3`);
    const audioBuffer = data.AudioStream as Buffer;
    await writeFile(audioFilePath, audioBuffer);

    console.log(`Speech saved to file: ${audioFilePath}`) 
  } 
});
```

##  Check for and Install Missing Homebrew Packages

```typescript
// Name: Install Homebrew Packages
// Description: Checks for and installs missing Homebrew packages
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for a comma-separated list of package names 
const packageNamesString = await arg("Enter package names (comma-separated):") 
const packageNames = packageNamesString.split(",").map(name => name.trim())

// Check if each package is installed and install if missing
for (const packageName of packageNames) {
  // Check if the package is already installed
  if (await isBin(packageName)) {
    await div(md(`# Package "${packageName}" is already installed.`))
  } else {
    // Install the package using Homebrew 
    await term({ 
      command: `brew install ${packageName}`,
      cwd: home(), 
      height: 140,
      enter: "Exit", 
      shortcuts: [],
    })
  }
}
```

##  Get the Latest Release of a GitHub Repository

```typescript
// Name: Get Latest GitHub Release
// Description: Fetches and displays information about the latest release of a GitHub repository 
// Author: johnlindquist

import "@johnlindquist/kit"
import { Octokit } from "@octokit/rest"

// Get the GitHub API token from the environment
// https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token
const githubToken = await env("GITHUB_TOKEN") 

// Initialize GitHub API client 
const octokit = new Octokit({ auth: githubToken });

// Prompt for the repository name
const repoName = await arg("Enter repository name (e.g., 'johnlindquist/kit'):")

// Split the repository name into owner and repo
const [owner, repo] = repoName.split("/")

// Fetch the latest release information
const { data: latestRelease } = await octokit.repos.getLatestRelease({
  owner, 
  repo,
}); 

// Display information about the latest release
await div(md(`
# Latest Release of ${repoName}: 

* Tag: ${latestRelease.tag_name} 
* Name: ${latestRelease.name}
* Published: ${latestRelease.published_at} 
* Download URL: ${latestRelease.html_url} 
`));
```

## Create a New Asana Project

```typescript
// Name: Create Asana Project
// Description: Creates a new project in an Asana workspace
// Author: johnlindquist

import "@johnlindquist/kit" 

// Get the Asana API token from the environment 
// https://developers.asana.com/docs/personal-access-token
const asanaToken = await env("ASANA_TOKEN")

// Prompt for the workspace ID 
const workspaceId = await arg("Enter Asana workspace ID:");

// Prompt for the project name
const projectName = await arg("Enter project name:"); 

// Create the project in Asana
await post( 
  `https://app.asana.com/api/1.0/projects`, 
  { 
    data: {
      workspace: workspaceId, 
      name: projectName,
    }, 
  }, 
  { 
    headers: {
      Authorization: `Bearer ${asanaToken}`, 
    },
  }
)

console.log(`Project "${projectName}" created successfully in Asana.`)
```

##  Download File from URL with Progress Bar

```typescript
// Name: Download File with Progress Bar
// Description: Downloads a file from a URL and displays a progress bar
// Author: johnlindquist

import "@johnlindquist/kit"
import cliProgress from "cli-progress";

// Prompt for the URL to download
const url = await arg("Enter URL to download:") 

// Create a new progress bar
const progressBar = new cliProgress.SingleBar({}, cliProgress.Presets.shades_classic); 

// Download the file using Axios, with progress updates 
await download(url, tmpPath(), {
  onDownloadProgress: (progress) => {
    // Update the progress bar with the current percentage 
    progressBar.update(progress.percent * 100); 
  },
})
  .then(async () => {
    // Stop the progress bar
    progressBar.stop();
    // Display a success message
    await div(md(`# File downloaded successfully!`)); 
  })
  .catch(async (error) => {
    // Stop the progress bar
    progressBar.stop(); 
    // Display an error message
    await div(md(`# Download failed: ${error.message}`)); 
  })
```


## Get the Current Weather for Multiple Locations

```typescript
// Name: Multi-Location Weather
// Description: Gets the current weather for multiple locations 
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the OpenWeatherMap API key from the environment
// https://openweathermap.org/api
const openWeatherMapApiKey = await env("OPENWEATHERMAP_API_KEY") 

// Prompt for a comma-separated list of locations
const locationsString = await arg(
  "Enter locations (comma-separated):"
) 
const locations = locationsString.split(",").map(location => location.trim())

// Create an array to store the weather information
const weatherData = []

// Fetch weather data for each location 
for (const location of locations) {
  const response = await get( 
    `https://api.openweathermap.org/data/2.5/weather?q=${location}&appid=${openWeatherMapApiKey}&units=metric` 
  )
  weatherData.push(response.data)
}

// Display the weather information for each location
let weatherOutput = "";
for (const data of weatherData) {
  const { name, main, weather } = data 
  weatherOutput += md(`
## Weather in ${name}: 

* Temperature: ${main.temp}Â°C
* Feels like: ${main.feels_like}Â°C 
* Condition: ${weather[0].description}
  `)
}
await div(weatherOutput)
```

## Send a Message to Multiple Telegram Chats

```typescript
// Name: Send Telegram Messages 
// Description: Sends a message to multiple Telegram chats
// Author: johnlindquist 

import "@johnlindquist/kit"

// Get the Telegram bot token from the environment
// https://core.telegram.org/bots#6-botfather 
const telegramBotToken = await env("TELEGRAM_BOT_TOKEN");

// Prompt for a comma-separated list of chat IDs
const chatIdsString = await arg(
  "Enter chat IDs (comma-separated):"
); 
const chatIds = chatIdsString.split(",").map(id => id.trim());

// Prompt for the message content
const message = await arg("Enter your message:"); 

// Send the message to each Telegram chat
for (const chatId of chatIds) { 
  await get(`https://api.telegram.org/bot${telegramBotToken}/sendMessage`, {
    params: {
      chat_id: chatId, 
      text: message, 
    }, 
  });

  console.log(`Message "${message}" sent to Telegram chat ${chatId}.`)
}
```

## Get a List of Your Open GitHub Pull Requests

```typescript
// Name: List Open Pull Requests
// Description: Lists your open pull requests on GitHub 
// Author: johnlindquist

import "@johnlindquist/kit"
import { Octokit } from "@octokit/rest"

// Get the GitHub API token from the environment
// https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token
const githubToken = await env("GITHUB_TOKEN");

// Initialize GitHub API client
const octokit = new Octokit({ auth: githubToken }); 

// Fetch a list of your open pull requests
const pullRequests = await octokit.pulls.list({
  state: "open",
  per_page: 100, 
})

// Create choices for each pull request, including repository name and PR title
const prChoices = pullRequests.data.map(pr => ({
  name: `${pr.base.repo.full_name}: ${pr.title}`,
  value: pr.html_url,
  description: pr.body,
}))

// Prompt for PR selection and open in browser
let prUrl = await arg("Your open pull requests:", prChoices); 
await open(prUrl)
```

##  Upload a File to Google Drive

```typescript
// Name: Upload to Google Drive
// Description: Uploads a file to your Google Drive
// Author: johnlindquist

import "@johnlindquist/kit" 
import { google } from "googleapis"; 

// Get Google Drive API credentials from the environment
// https://developers.google.com/drive/api/quickstart/nodejs
const googleDriveCredentials = JSON.parse(await env("GOOGLE_DRIVE_CREDENTIALS")); 
// Authorize with Google Drive API
const auth = new google.auth.GoogleAuth({
  credentials: googleDriveCredentials, 
  scopes: ["https://www.googleapis.com/auth/drive.file"], 
});
const drive = google.drive({ version: "v3", auth }); 

// Prompt for the file path
const filePath = await path({
  hint: "Select a file to upload",
});

// Read the file content 
const fileContent = await readFile(filePath); 

// Upload the file to Google Drive 
await drive.files.create({
  requestBody: {
    name: path.basename(filePath), // Use the original file name
    // parents: [folderId], // Specify a folder ID to upload to a specific folder 
  }, 
  media: {
    mimeType: "application/octet-stream",
    body: fileContent, 
  },
});

console.log(`File "${filePath}" uploaded to Google Drive.`)
```

##  Remove Duplicate Lines from Text

```typescript
// Name: Remove Duplicate Lines
// Description: Removes duplicate lines from text
// Author: johnlindquist 

import "@johnlindquist/kit"

// Get the text from the clipboard 
const text = await paste() 

// Split the text into lines, remove duplicates, and rejoin 
const uniqueLines = [...new Set(text.split("\n"))].join("\n"); 

// Copy the updated text back to the clipboard 
await copy(uniqueLines);

console.log(`Removed duplicate lines from clipboard.`) 
```

## Convert Markdown to HTML and Display in Widget

```typescript
// Name: Markdown Preview
// Description: Converts Markdown to HTML and displays it in a widget
// Author: johnlindquist

import "@johnlindquist/kit"
import { marked } from "marked"

// Get Markdown from the clipboard
const markdown = await paste();

// Convert Markdown to HTML 
const html = marked.parse(markdown) 

// Display the HTML in a widget
await widget(html, {
  width: 800,
  height: 600, 
  resizable: true,
})
```

##  Clean Up Temporary Files and Empty Trash

```typescript
// Name: Clean Up and Empty Trash
// Description: Cleans up temporary files and empties the trash
// Author: johnlindquist

import "@johnlindquist/kit"
import { tmpdir } from "os" 

// Get the temporary directory path
const tempDir = tmpdir(); 

// Clean up the temporary directory
await trash(tempDir, { glob: true })

// Empty the trash (macOS only) 
if (isMac) {
  await trash(home(".Trash/*"))
} 

console.log(`Cleaned up temporary files and emptied the trash.`) 
```


## Get a List of Commits with Details

```typescript
// Name: Detailed Git Log
// Description: Displays a detailed log of Git commits
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the number of commits to display
const commitCount = parseInt(
  await arg("Enter the number of commits to display:"),
  10
)

// Execute the Git command to retrieve a detailed log of commits
const { stdout: gitLog } = await exec(`git log -n ${commitCount} --pretty=format:"%h - %s (%an, %ad)"`)

// Display the Git log in the editor 
await editor({ 
  value: gitLog,
  language: "text",
})
```

##  Create a New Google Calendar Event with Attendees

```typescript
// Name: Schedule Google Calendar Event with Attendees
// Description: Creates a new Google Calendar event with attendees
// Author: johnlindquist

import "@johnlindquist/kit"
import { google } from "googleapis";

// Get the Google Calendar API credentials from the environment
// https://developers.google.com/calendar/api/quickstart/nodejs
const googleCalendarCredentials = JSON.parse(await env("GOOGLE_CALENDAR_CREDENTIALS"));
// Authorize with the Google Calendar API 
const auth = new google.auth.GoogleAuth({
  credentials: googleCalendarCredentials,
  scopes: ["https://www.googleapis.com/auth/calendar"], 
}); 
const calendar = google.calendar({ version: "v3", auth });

// Prompt for event details
const eventSummary = await arg("Enter event summary:");
const eventStartTime = await arg("Enter event start time (YYYY-MM-DDTHH:mm:ss):");
const eventEndTime = await arg("Enter event end time (YYYY-MM-DDTHH:mm:ss):");
const attendeeEmails = (await arg("Enter attendee email addresses (comma-separated):"))
  .split(",")
  .map(email => ({ email: email.trim() }))

// Create the event object 
const event = {
  summary: eventSummary,
  start: {
    dateTime: eventStartTime,
  },
  end: {
    dateTime: eventEndTime, 
  }, 
  attendees: attendeeEmails, // Include the list of attendees
} 

// Insert the event into the user's primary calendar
await calendar.events.insert({
  calendarId: "primary",
  requestBody: event,
});

console.log("Event created successfully on your Google Calendar.")
```

## Send a Direct Message on Twitter

```typescript
// Name: Send Twitter Direct Message
// Description: Sends a direct message to a Twitter user
// Author: johnlindquist

import "@johnlindquist/kit"
import Twitter from "twitter-api-v2" 

// Get the Twitter API keys from the environment 
// https://developer.twitter.com/en/portal/dashboard
const twitterConsumerKey = await env("TWITTER_CONSUMER_KEY")
const twitterConsumerSecret = await env("TWITTER_CONSUMER_SECRET") 
const twitterAccessTokenKey = await env("TWITTER_ACCESS_TOKEN_KEY") 
const twitterAccessTokenSecret = await env("TWITTER_ACCESS_TOKEN_SECRET")

// Initialize the Twitter API client
const twitterClient = new Twitter({
  appKey: twitterConsumerKey,
  appSecret: twitterConsumerSecret,
  accessToken: twitterAccessTokenKey,
  accessSecret: twitterAccessTokenSecret,
}) 

// Prompt for the recipient's Twitter username 
const recipientUsername = await arg("Enter recipient's Twitter username:") 

// Prompt for the message content
const message = await arg("Enter your message:") 

// Send the direct message 
await twitterClient.v1.sendDm({ 
  recipient_id: (await twitterClient.v2.userByUsername(recipientUsername)).data.id,
  text: message, 
});

console.log(`Direct message sent to ${recipientUsername} on Twitter.`)
```

## Get a List of Open Issues in a GitHub Repository

```typescript
// Name: List Open GitHub Issues
// Description: Lists open issues in a specified GitHub repository
// Author: johnlindquist 

import "@johnlindquist/kit" 
import { Octokit } from "@octokit/rest" 

// Get the GitHub API token from the environment
// https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token
const githubToken = await env("GITHUB_TOKEN") 

// Initialize GitHub API client 
const octokit = new Octokit({ auth: githubToken }); 

// Prompt for the repository owner and name
const repoOwner = await arg("Enter repository owner:")
const repoName = await arg("Enter repository name:") 

// Fetch the list of open issues for the specified repository
const { data: issues } = await octokit.issues.listForRepo({
  owner: repoOwner,
  repo: repoName, 
  state: "open",
}) 

// Create choices for each issue, including the issue number and title
const issueChoices = issues.map(issue => ({ 
  name: `#${issue.number} - ${issue.title}`,
  value: issue.html_url, 
  description: issue.body,
}))

// Prompt for issue selection and open in browser
let issueUrl = await arg("Open issues:", issueChoices); 
await open(issueUrl);
```

## Rename Files in Bulk

```typescript
// Name: Bulk File Renamer 
// Description: Renames multiple files in a directory 
// Author: johnlindquist

import "@johnlindquist/kit"
import { globby } from "globby";

// Prompt for the directory path
const directoryPath = await path({ 
  hint: "Select a directory containing files to rename", 
  onlyDirs: true,
})

// Get a list of files in the directory
const files = await globby([
  `${directoryPath}/*`, 
  `!${directoryPath}/*.{js,ts,json}` // Exclude script files 
], {
  expandDirectories: true,
})

// Prompt for the current and new file name patterns
const currentPattern = await arg({
  placeholder: "Enter current file name pattern (e.g., 'image-*'):",
}) 
const newPattern = await arg("Enter new file name pattern (e.g., 'photo-*'):");

// Rename files based on the provided patterns
for (const file of files) {
  // Construct the new file path using the replacement pattern 
  const newFilePath = file.replace(currentPattern, newPattern)

  // Rename the file
  await mv(file, newFilePath)

  console.log(`Renamed: ${file} to ${newFilePath}`)
} 

console.log("All files renamed successfully.") 
```

## Get and Set System Brightness

```typescript
// Name: Brightness Controller
// Description: Gets and sets the system brightness
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the current brightness level (macOS only)
let currentBrightness = 0
if (isMac) {
  const { stdout } = await exec("brightness -l") 
  currentBrightness = parseFloat(stdout.match(/brightness: ([0-9.]+)/)[1]) 
}

// Prompt for the new brightness level (0 to 1)
const newBrightness = parseFloat(
  await arg({ 
    placeholder: `Enter brightness level (current: ${currentBrightness.toFixed(2)}):`,
    hint: "Enter a value between 0 and 1",
  }) 
); 

// Set the brightness level (macOS only)
if (isMac) { 
  await exec(`brightness ${newBrightness}`)
}

console.log(`Brightness set to ${newBrightness}.`) 
```

## Delete a Specific File from Git History

```typescript
// Name: Delete File from Git History
// Description: Deletes a file from Git history (use with CAUTION!)
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt for the file path to remove from Git history 
const filePath = await path()

// Display a warning message about the potential risks of deleting from Git history 
await div(md(`## ðŸš¨ Warning: Deleting from Git History 

Deleting a file from Git history will permanently remove it from all commits. Make sure you have a backup of the file before proceeding. This action cannot be undone.
`))

// Prompt for confirmation
const confirmDelete = await arg("Confirm deletion? Type 'yes' to proceed:", ["yes"])

// Proceed with deletion if confirmed 
if (confirmDelete === "yes") {
  // Execute BFG command to remove the file from Git history 
  await term({
    command: `bfg --delete-files ${filePath} --no-blob-protection`, 
    cwd: process.cwd(),
    height: 140, 
    enter: "Exit",
    shortcuts: [],
  })

  // Force push to update the remote repository
  await term({
    command: "git push --force",
    cwd: process.cwd(),
    height: 140,
    enter: "Exit",
    shortcuts: [],
  });
} 
```


## Create a New Asana Task with Due Date

```typescript
// Name: Create Asana Task with Due Date
// Description: Creates a new task in Asana with a due date
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the Asana API token from the environment
// https://developers.asana.com/docs/personal-access-token
const asanaToken = await env("ASANA_TOKEN")

// Prompt for the workspace ID 
const workspaceId = await arg("Enter Asana workspace ID:")

// Prompt for the project ID
const projectId = await arg("Enter Asana project ID:")

// Prompt for the task name 
const taskName = await arg("Enter task name:")

// Prompt for the due date (YYYY-MM-DD)
const dueDate = await arg("Enter due date (YYYY-MM-DD):")

// Create the task in Asana
await post(
  `https://app.asana.com/api/1.0/tasks`, 
  {
    data: {
      workspace: workspaceId,
      projects: [projectId],
      name: taskName,
      due_on: dueDate, // Set the due date for the task
    },
  },
  {
    headers: {
      Authorization: `Bearer ${asanaToken}`, 
    }, 
  }
) 

console.log(`Task "${taskName}" with due date ${dueDate} created successfully in Asana.`) 
```

## Convert Text to Speech with Amazon Polly and Play in Browser

```typescript
// Name: Text to Speech (Amazon Polly) - Browser Playback
// Description: Converts text to speech using Amazon Polly and plays it in the browser
// Author: johnlindquist 

import "@johnlindquist/kit"
import AWS from "aws-sdk"

// Get the AWS credentials from the environment 
// https://docs.aws.amazon.com/sdk-for-javascript/v2/developer-guide/setting-credentials-node.html
const awsAccessKeyId = await env("AWS_ACCESS_KEY_ID") 
const awsSecretAccessKey = await env("AWS_SECRET_ACCESS_KEY")

// Configure AWS SDK
AWS.config.update({
  accessKeyId: awsAccessKeyId, 
  secretAccessKey: awsSecretAccessKey, 
  region: "us-east-1", // Replace with your desired AWS region
}); 

// Create an instance of Amazon Polly
const polly = new AWS.Polly();

// Prompt for text input
const inputText = await arg("Enter text:"); 

// Define the parameters for text-to-speech conversion 
const params = {
  OutputFormat: "mp3",
  Text: inputText,
  VoiceId: "Joanna", // Replace with your desired voice ID 
}

// Convert the text to speech 
polly.synthesizeSpeech(params, async (err, data) => { 
  if (err) {
    console.error(err); 
  } else { 
    // Save the audio data to a temporary file
    const audioFilePath = tmpPath("speech.mp3")
    const audioBuffer = data.AudioStream as Buffer; 
    await writeFile(audioFilePath, audioBuffer) 

    // Display the audio in a widget 
    await widget(`
    <div class="flex items-center justify-center h-full">
      <audio controls autoplay>
        <source src="file://${audioFilePath}" type="audio/mpeg"> 
      </audio> 
    </div>
    `, {
      width: 400, 
      height: 100,
      resizable: true,
    })
  }
});
```

##  Get System Battery Status

```typescript
// Name: Battery Status
// Description: Displays the system battery status 
// Author: johnlindquist

import "@johnlindquist/kit"
import { getBattery } from "powercfg"

// Get battery information 
const battery = await getBattery(); 

// Display the battery information in a div
await div(md(`
# Battery Status:

* ${battery.isCharging ? "Charging" : "Not Charging"} 
* Level: ${battery.percent}% 
* Remaining Time: ${battery.remainingTime ? formatDistanceToNow(new Date(Date.now() + battery.remainingTime * 1000), { addSuffix: true }) : "N/A"} 
`))
```

##  Create a New GitHub Gist with Description

```typescript
// Name: Create Gist with Description
// Description: Creates a new GitHub Gist with a description
// Author: johnlindquist

import "@johnlindquist/kit" 
import { Octokit } from "@octokit/rest"

// Get the GitHub API token from the environment
// https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token
const githubToken = await env("GITHUB_TOKEN"); 

// Initialize GitHub API client
const octokit = new Octokit({ auth: githubToken })

// Prompt for the file name
const fileName = await arg("Enter file name:"); 

// Prompt for the file content 
const fileContent = await editor({
  placeholder: "Enter file content:"
});

// Prompt for the Gist description 
const description = await arg({
  placeholder: "Enter a description for the Gist:"
})

// Create the Gist on GitHub 
const { data: gist } = await octokit.gists.create({ 
  files: {
    [fileName]: { 
      content: fileContent,
    },
  }, 
  public: true,
  description, // Include the provided description
}); 

// Open the created Gist in the browser 
await open(gist.html_url)

console.log(`Gist created and opened in browser: ${gist.html_url}`)
```

## Get a List of Files Modified in a Git Branch

```typescript
// Name: List Modified Files in Branch
// Description: Lists files modified in a specific Git branch
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the branch name
const branchName = await arg("Enter branch name:");

// Execute the Git command to retrieve modified files in the branch
const { stdout: modifiedFiles } = await exec(`git diff --name-only ${branchName}`); 

// Display the list of modified files in the editor
await editor({
  value: modifiedFiles,
  language: "text",
}) 
```

## Resize an Image to a Specific Width and Height

```typescript
// Name: Resize Image (Specific Dimensions)
// Description: Resizes an image to a specific width and height
// Author: johnlindquist

import "@johnlindquist/kit"
import sharp from "sharp"

// Prompt for the image path
let imagePath = await path({
  hint: "Select an image file" 
}) 

// Prompt for the new width
let newWidth = await arg("Enter new width in pixels:")

// Prompt for the new height 
let newHeight = await arg("Enter new height in pixels:")

// Resize the image using sharp
const resizedImage = await sharp(imagePath)
  .resize(parseInt(newWidth), parseInt(newHeight), { 
    // Use 'fit: fill' to resize to exact dimensions, potentially cropping the image
    fit: "fill" 
  })
  .toBuffer(); 

// Overwrite the original file with the resized image 
await writeFile(imagePath, resizedImage);

console.log(`Image resized to ${newWidth}x${newHeight} pixels.`);
```

## Create a New Event in Outlook Calendar

```typescript
// Name: Create Outlook Calendar Event
// Description: Creates a new event in Outlook Calendar
// Author: johnlindquist

import "@johnlindquist/kit"
// (The npm package is "@microsoft/microsoft-graph-client") 

import { Client } from "@microsoft/microsoft-graph-client"

// Get the Microsoft Graph API token from the environment 
// https://docs.microsoft.com/en-us/graph/auth/
const graphToken = await env("GRAPH_TOKEN") 

// Initialize the Microsoft Graph client 
const graphClient = Client.init({
  authProvider: (done) => { 
    done(null, graphToken) 
  },
}) 

// Prompt for event details
const eventSubject = await arg("Enter event subject:"); 
const eventStartTime = await arg( 
  "Enter event start time (YYYY-MM-DDTHH:mm:ss):"
)
const eventEndTime = await arg(
  "Enter event end time (YYYY-MM-DDTHH:mm:ss):"
) 

// Create a new event in Outlook Calendar 
await graphClient 
  .api("/me/events")
  .post({
    subject: eventSubject,
    start: {
      dateTime: eventStartTime, 
      timeZone: "UTC", // Specify the time zone
    }, 
    end: {
      dateTime: eventEndTime,
      timeZone: "UTC", // Specify the time zone 
    },
  }); 

console.log(`Event "${eventSubject}" created successfully in Outlook Calendar.`);
```


## Get a List of Top Reddit Posts

```typescript
// Name: Top Reddit Posts
// Description: Fetches and displays the top posts from a subreddit
// Author: johnlindquist

import "@johnlindquist/kit"
import snoowrap from "snoowrap"

// Get the Reddit API credentials from the environment 
// https://www.reddit.com/prefs/apps 
const redditClientId = await env("REDDIT_CLIENT_ID") 
const redditClientSecret = await env("REDDIT_CLIENT_SECRET") 
const redditUsername = await env("REDDIT_USERNAME") 
const redditPassword = await env("REDDIT_PASSWORD")

// Prompt for the subreddit name
const subredditName = await arg("Enter subreddit name:") 

// Initialize the Reddit API client
const reddit = new snoowrap({
  userAgent: "Script Kit Reddit Example",
  clientId: redditClientId,
  clientSecret: redditClientSecret,
  username: redditUsername,
  password: redditPassword, 
});

// Fetch the top posts from the subreddit
const topPosts = await reddit.getSubreddit(subredditName).getTop({ time: "day", limit: 10 })

// Create an array of choices from the top posts
const postChoices = topPosts.map(post => ({
  name: post.title,
  value: post.url, 
  description: `${post.ups} upvotes - ${post.num_comments} comments`, 
}));

// Prompt for post selection and open in browser
let postUrl = await arg("Top posts:", postChoices);
await open(postUrl)
```

##  Generate a Random UUID and Store it in the Clipboard

```typescript
// Name: Copy UUID
// Description: Generates a UUID and copies it to the clipboard 
// Author: johnlindquist

import "@johnlindquist/kit"

// Generate a UUID using the crypto module
const generatedUUID = crypto.randomUUID();

// Copy the generated UUID to the clipboard 
await copy(generatedUUID)

// Display a notification indicating the UUID has been copied 
await notify({
  title: "UUID Copied",
  message: "The generated UUID has been copied to the clipboard." 
}) 
```

## Convert Text to Speech with Microsoft Azure

```typescript
// Name: Text to Speech (Azure) 
// Description: Converts text to speech using Microsoft Azure Cognitive Services 
// Author: johnlindquist 

import "@johnlindquist/kit"
import sdk from "microsoft-cognitiveservices-speech-sdk"; 

// Get the Azure Cognitive Services Speech key and region from the environment 
// https://docs.microsoft.com/en-us/azure/cognitive-services/speech-service/get-started
const azureSpeechKey = await env("AZURE_SPEECH_KEY")
const azureSpeechRegion = await env("AZURE_SPEECH_REGION")

// Prompt for text input 
const inputText = await arg("Enter text:");

// Configure speech synthesis 
const speechConfig = sdk.SpeechConfig.fromSubscription(
  azureSpeechKey,
  azureSpeechRegion 
); 
speechConfig.speechSynthesisVoiceName = "en-US-JennyNeural"; // Set the desired voice 

// Create an audio output stream
const audioStream = sdk.AudioOutputStream.createPullStream();

// Create a speech synthesizer
const synthesizer = new sdk.SpeechSynthesizer(
  speechConfig,
  audioStream
);

// Synthesize speech and handle result
synthesizer.speakTextAsync(
  inputText, 
  async result => {
    if (result.reason === sdk.ResultReason.SynthesizingAudioCompleted) { 
      // Get the audio data from the stream
      const audioData = await audioStream.readToEnd();

      // Save the audio data as a WAV file
      const audioFilePath = tmpPath("speech.wav") 
      await writeFile(audioFilePath, audioData)

      // Play the generated speech 
      await playAudioFile(audioFilePath);
      console.log(`Speech synthesized and saved to ${audioFilePath}.`) 
    } else {
      console.error(`Speech synthesis failed: ${result.errorDetails}`); 
    }

    // Dispose of the synthesizer and audio stream 
    synthesizer.close();
    audioStream.close(); 
  },
  error => {
    console.error(`Speech synthesis canceled: ${error}`); 
    synthesizer.close(); 
    audioStream.close();
  } 
);
```

##  Compare Two Files for Differences

```typescript
// Name: Compare Files
// Description: Compares two files for differences
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the first file path
const filePath1 = await path({
  hint: "Select the first file", 
}); 

// Prompt for the second file path
const filePath2 = await path({
  hint: "Select the second file",
}); 

// Execute the 'diff' command to compare the files and capture the output 
const { stdout: diffOutput } = await exec(`diff "${filePath1}" "${filePath2}"`)

// Display the differences in the editor 
await editor({
  value: diffOutput,
  language: "diff",
})
```

##  Get Information About a Domain Name

```typescript
// Name: Domain Info
// Description: Retrieves and displays domain name information
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the domain name
const domainName = await arg("Enter domain name (e.g., example.com):") 

// Fetch domain information using the WHOIS API 
const response = await get(`https://api.whoisxmlapi.com/whoisserver/WhoisService?apiKey=${await env("WHOISXMLAPI_KEY")}&domainName=${domainName}&outputFormat=JSON`); 

// Extract and display the domain information 
const domainInfo = response.data;
await editor(JSON.stringify(domainInfo, null, 2)); 
```

##  Check and Update Ruby Gems

```typescript
// Name: Update Ruby Gems
// Description: Checks for and updates outdated Ruby gems
// Author: johnlindquist 

import "@johnlindquist/kit"

// Display a terminal with the `bundle outdated` command (if a Gemfile exists)
// or the `gem outdated` command to list outdated gems 
let command = "gem outdated" // Default to using `gem outdated`
if (await isFile("Gemfile")) {
  command = "bundle outdated"; 
}

await term({
  command,
  shortcuts: [],
}); 
```

## Get Real-time Cryptocurrency Prices

```typescript
// Name: Crypto Price Tracker
// Description: Tracks and displays real-time cryptocurrency prices
// Author: johnlindquist 

import "@johnlindquist/kit"

// Prompt for cryptocurrency symbols (comma-separated)
const symbolsString = await arg({
  placeholder: "Enter cryptocurrency symbols (comma-separated, e.g., BTC,ETH,BNB):",
})
const symbols = symbolsString.split(",").map(symbol => symbol.trim().toUpperCase());

// Create a widget to display the prices
const cryptoWidget = await widget(
  `
  <div class="grid grid-cols-1 gap-4 p-4">
    <template v-for="symbol in symbols">
      <div class="p-2 bg-gray-800 rounded">
        <h3 class="text-lg font-bold">{{ symbol }}</h3>
        <p class="text-gray-400">Price: ${{ prices[symbol] || "..." }}</p>
      </div>
    </template>
  </div>
  `,
  {
    width: 300,
    height: symbols.length * 60 + 16, // Adjust height based on the number of symbols
    resizable: true,
    state: {
      symbols,
      prices: {},
    },
  }
)

// Fetch prices every 5 seconds and update the widget state
setInterval(async () => {
  const response = await get(`https://api.binance.com/api/v3/ticker/price?symbols=[${symbols.map(s => `"${s}USDT"`).join(",")}]`);
  const prices = response.data.reduce((acc, {symbol, price}) => {
    // Extract symbol without "USDT" suffix
    const baseSymbol = symbol.slice(0, -4);
    acc[baseSymbol] = parseFloat(price).toFixed(2);
    return acc;
  }, {});
  cryptoWidget.setState({ prices })
}, 5000);
```


## Create a Time-Tracking Entry in Clockify

```typescript
// Name: Start Clockify Timer
// Description: Starts a new time entry in Clockify 
// Author: johnlindquist 

import "@johnlindquist/kit"

// Get the Clockify API key from the environment
// https://clockify.me/user/settings
const clockifyApiKey = await env("CLOCKIFY_API_KEY")

// Prompt for the workspace ID 
const workspaceId = await arg("Enter Clockify Workspace ID:")

// Prompt for the project ID
const projectId = await arg("Enter Clockify Project ID:") 

// Prompt for the task description 
const description = await arg("Enter task description:") 

// Start a new time entry in Clockify
await fetch(
  `https://api.clockify.me/api/v1/workspaces/${workspaceId}/time-entries`,
  { 
    method: "POST",
    headers: {
      "Content-Type": "application/json", 
      "X-Api-Key": clockifyApiKey,
    }, 
    body: JSON.stringify({
      start: new Date().toISOString(),
      projectId: projectId,
      description: description, 
    }),
  }
) 
  .then(() => {
    console.log(`Clockify timer started for "${description}".`);
  })
  .catch(err => { 
    console.error(`Error starting Clockify timer: ${err}`);
  });
```

##  Get a List of Files in a GitHub Repository

```typescript
// Name: List GitHub Repo Files
// Description: Lists files in a specified GitHub repository
// Author: johnlindquist

import "@johnlindquist/kit"
import { Octokit } from "@octokit/rest"

// Get the GitHub API token from the environment 
// https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token
const githubToken = await env("GITHUB_TOKEN") 

// Initialize GitHub API client 
const octokit = new Octokit({ auth: githubToken })

// Prompt for the repository information
const repoOwner = await arg("Enter repository owner:") 
const repoName = await arg("Enter repository name:") 

// Prompt for the branch name
const branchName = await arg({
  placeholder: "Enter branch name (leave blank for default branch):", 
  hint: "Press Enter to use the default branch."
}) 

// Fetch the list of files for the specified repository and branch 
const { data: repoContent } = await octokit.repos.getContent({
  owner: repoOwner,
  repo: repoName,
  ref: branchName || "", // Use empty string for default branch
  path: "", // Get files in the root directory 
});

// Create choices for each file
let fileChoices = repoContent.map(file => ({ 
  name: file.name,
  value: file.download_url, // Use the download URL as the value
  description: `Type: ${file.type}`,
}));

// Prompt for file selection and open in browser 
let fileUrl = await arg("Files in repository:", fileChoices);
await open(fileUrl)
```

## Create a New Google Meet

```typescript
// Name: Create Google Meet
// Description: Creates a new Google Meet and copies the meeting link
// Author: johnlindquist

import "@johnlindquist/kit"
import { google } from "googleapis" 

// Get the Google Meet API credentials from the environment 
// https://developers.google.com/calendar/api/quickstart/nodejs
const googleMeetCredentials = JSON.parse(await env("GOOGLE_MEET_CREDENTIALS"))
// Authorize with the Google Meet API
const auth = new google.auth.GoogleAuth({
  credentials: googleMeetCredentials,
  scopes: ["https://www.googleapis.com/auth/calendar"],
});
const calendar = google.calendar({ version: "v3", auth })

// Create a new Google Meet
const { data: newMeeting } = await calendar.events.insert({
  calendarId: "primary",
  conferenceDataVersion: 1,
  requestBody: {
    summary: "Quick Meet",
    conferenceData: {
      createRequest: {
        requestId: Math.random().toString(), // Generate a unique request ID
        conferenceSolutionKey: { type: "hangoutsMeet" }, 
      }, 
    },
  },
}) 

// Copy the meeting link to the clipboard
await copy(newMeeting.hangoutLink) 

// Display a confirmation message and the meeting link 
await div(md(`
# Google Meet Created

Join the meeting:

[${newMeeting.hangoutLink}](${newMeeting.hangoutLink})
`))
```

## Compress a Folder to a TAR Archive

```typescript
// Name: Compress to TAR
// Description: Compresses a directory into a TAR archive
// Author: johnlindquist

import "@johnlindquist/kit"
import { create } from "archiver"
import { createWriteStream } from "fs"; 

// Prompt for the directory to compress
const directoryPath = await path({ 
  hint: "Select a directory to compress", 
  onlyDirs: true, 
});

// Create a TAR archive
const output = createWriteStream(`${directoryPath}.tar`)
const archive = create("tar", {
  gzip: true, // Enable gzip compression
  zlib: { level: 9 } // Set the compression level
}); 

// Pipe the archive data to the output stream
archive.pipe(output)

// Append the directory to the archive
archive.directory(directoryPath, path.basename(directoryPath))

// Finalize the archive (this will also close the output stream) 
await archive.finalize()

console.log(`Directory compressed to: ${directoryPath}.tar`)
```

## Run a Speed Test and Display Results

```typescript
// Name: Internet Speed Test
// Description: Runs a speed test and displays the results
// Author: johnlindquist

import "@johnlindquist/kit"
import { speedTest } from "speedtest-net";

// Run the speed test
const speed = await speedTest({ acceptLicense: true, acceptGdpr: true })

// Display the results in a div 
await div(md(`
# Speed Test Results:

* Download: ${speed.download.human} 
* Upload: ${speed.upload.human}
* Ping: ${speed.ping.latency}ms
* Server: ${speed.server.host}
`))
```

## Create a New Shortcut with Keyboard Maestro

```typescript
// Name: Create Keyboard Maestro Shortcut
// Description: Creates a new shortcut in Keyboard Maestro
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the shortcut name 
const shortcutName = await arg("Enter shortcut name:");

// Create a new Keyboard Maestro macro using AppleScript 
await applescript(`
tell application "Keyboard Maestro Engine" 
  make new macro with name "${shortcutName}"
end tell 
`)

console.log(`Shortcut "${shortcutName}" created in Keyboard Maestro.`)
```

##  Convert a Video to Different Formats in Bulk

```typescript
// Name: Bulk Video Converter
// Description: Converts multiple video files to different formats using FFmpeg
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the directory containing video files 
const directoryPath = await path({
  hint: "Select directory containing videos:", 
  onlyDirs: true,
})

// Get all video files in the directory
const videoFiles = await globby([ 
  `${directoryPath}/*.mp4`, 
  `${directoryPath}/*.mov`,
  `${directoryPath}/*.avi`, 
], {
  expandDirectories: {
    extensions: ["mp4", "mov", "avi"],
  }, 
}); 

// Prompt for the desired output format
const outputFormat = await arg("Enter desired output format (e.g., mp4, avi, webm):")

// Convert each video file to the specified format 
for (const file of videoFiles) { 
  // Construct the output file path
  const outputPath = file.replace(/\.[^/.]+$/, `.${outputFormat}`) 

  // Execute the FFmpeg command to convert the video 
  await execa(
    "ffmpeg", 
    ["-i", file, outputPath],
    {
      stdio: "inherit", // Display FFmpeg output in the terminal 
    }
  );

  console.log(`Converted: ${file} to ${outputPath}`) 
}

console.log("All videos converted.")
```




## Create and Send a Telegram Poll

```typescript
// Name: Create Telegram Poll
// Description: Creates a new poll in a Telegram chat
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the Telegram bot token from the environment
// https://core.telegram.org/bots#6-botfather
const telegramBotToken = await env("TELEGRAM_BOT_TOKEN")

// Prompt for the chat ID
const chatId = await arg("Enter Telegram chat ID:")

// Prompt for the poll question
const question = await arg("Enter poll question:")

// Prompt for the poll options (comma-separated) 
const optionsString = await arg(
  "Enter poll options (comma-separated):"
)
const options = optionsString.split(",").map(option => option.trim()) 

// Send the poll to the Telegram chat
await get(`https://api.telegram.org/bot${telegramBotToken}/sendPoll`, {
  params: {
    chat_id: chatId,
    question: question,
    options: JSON.stringify(options), // Pass the options as a JSON string
  }, 
})

console.log(`Poll "${question}" sent to Telegram chat ${chatId}.`)
```

## Download a File from Google Drive

```typescript
// Name: Download from Google Drive
// Description: Downloads a file from your Google Drive 
// Author: johnlindquist

import "@johnlindquist/kit"
import { google } from "googleapis"

// Get the Google Drive API credentials from the environment
// https://developers.google.com/drive/api/quickstart/nodejs
const googleDriveCredentials = JSON.parse(
  await env("GOOGLE_DRIVE_CREDENTIALS") 
)
// Authorize with the Google Drive API
const auth = new google.auth.GoogleAuth({
  credentials: googleDriveCredentials,
  scopes: ["https://www.googleapis.com/auth/drive.readonly"], 
})
const drive = google.drive({ version: "v3", auth }) 

// Prompt for the file ID 
const fileId = await arg("Enter Google Drive file ID:") 

// Download the file from Google Drive
const response = await drive.files.get(
  { 
    fileId: fileId,
    alt: "media", 
  },
  { responseType: "stream" } 
); 

// Construct the output file path 
const outputPath = tmpPath(response.data.headers["content-disposition"].split("filename=")[1].replace(/"/g, "")) 

// Create a write stream to save the downloaded file
const writer = createWriteStream(outputPath)

// Pipe the response data to the writer
response.data.pipe(writer); 

// Wait for the download to finish
await new Promise((resolve, reject) => { 
  writer.on("finish", resolve); 
  writer.on("error", reject) 
});

console.log(`File downloaded from Google Drive: ${outputPath}`);
```

##  Create a New Jira Ticket with a Summary and Description

```typescript
// Name: Create Jira Ticket 
// Description: Creates a new Jira ticket
// Author: johnlindquist 

import "@johnlindquist/kit"

// Get the Jira API token and project key from the environment
// https://developer.atlassian.com/cloud/jira/platform/basic-auth-for-rest-apis/ 
const jiraEmail = await env("JIRA_EMAIL") 
const jiraToken = await env("JIRA_TOKEN");
const jiraProjectKey = await env("JIRA_PROJECT_KEY") 

// Prompt for the issue summary
const issueSummary = await arg("Enter issue summary:") 

// Prompt for the issue description using the editor 
const issueDescription = await editor({ 
  placeholder: "Enter issue description:", 
})

// Create the issue in Jira
await post(
  `https://your-jira-domain.atlassian.net/rest/api/3/issue`, 
  {
    fields: {
      project: {
        key: jiraProjectKey,
      },
      summary: issueSummary, 
      description: issueDescription, 
      issuetype: { 
        name: "Task", // Set the issue type 
      },
    }, 
  }, 
  {
    headers: { 
      Authorization: `Basic ${Buffer.from(`${jiraEmail}:${jiraToken}`).toString("base64")}`,
      "Content-Type": "application/json",
    },
  }
)

console.log(`Jira issue "${issueSummary}" created successfully.`)
```

##  Generate a Random Password with Specific Criteria

```typescript
// Name: Generate Password (Custom)
// Description: Generates a random password with custom criteria 
// Author: johnlindquist 

import "@johnlindquist/kit" 
import { generate } from "generate-password" 

// Prompt for password length
const passwordLength = parseInt(await arg("Enter desired password length:")) 

// Prompt for whether to include numbers
const includeNumbers = await arg("Include numbers?", ["yes", "no"]) === "yes" 

// Prompt for whether to include symbols 
const includeSymbols = await arg("Include symbols?", ["yes", "no"]) === "yes" 

// Generate a random password with the specified criteria
const password = generate({
  length: passwordLength, 
  numbers: includeNumbers,
  symbols: includeSymbols,
  uppercase: true, 
  lowercase: true,
  excludeSimilarCharacters: true,
}); 

// Copy the generated password to the clipboard
await copy(password) 

console.log("Password generated and copied to clipboard.")
```

## Check for and Install Missing Python Packages

```typescript
// Name: Install Python Packages 
// Description: Checks for and installs missing Python packages using pip
// Author: johnlindquist 

import "@johnlindquist/kit" 

// Prompt for the package names (comma-separated) 
const packageNamesString = await arg("Enter package names (comma-separated):") 
const packageNames = packageNamesString.split(",").map(name => name.trim())

// Check if each package is installed and install if missing 
for (const packageName of packageNames) {
  try {
    // Attempt to import the package
    await import(packageName); 
    await div(md(`# Package "${packageName}" is already installed.`))
  } catch (error) {
    // If the package is not found, install it using pip
    await term({
      command: `pip install ${packageName}`, 
      cwd: home(),
      height: 140,
      enter: "Exit", 
      shortcuts: [], 
    })
  }
}
```

## Upload a File to an FTP Server 

```typescript
// Name: Upload to FTP
// Description: Uploads a file to an FTP server
// Author: johnlindquist

import "@johnlindquist/kit" 
import { Client } from "basic-ftp"

// Prompt for FTP server details
const host = await arg("Enter FTP host:") 
const username = await arg("Enter FTP username:") 
const password = await arg({
  placeholder: "Enter FTP password:",
  secret: true,
});

// Prompt for the file path
const filePath = await path({
  hint: "Select a file to upload", 
})

// Read the file content
const fileContent = await readFile(filePath)

// Initialize the FTP client 
const client = new Client()

try {
  // Connect to the FTP server
  await client.access({
    host,
    user: username,
    password,
  })

  // Upload the file to the FTP server
  await client.uploadFrom(fileContent, path.basename(filePath)) 

  console.log(`File "${filePath}" uploaded to FTP server.`); 
} catch (error) { 
  console.error("FTP upload error:", error) 
} finally { 
  // Close the FTP connection 
  client.close()
}
```

## Convert a Series of Images to a PDF

```typescript
// Name: Images to PDF 
// Description: Combines a series of images into a single PDF file 
// Author: johnlindquist 

import "@johnlindquist/kit"
import PDFDocument from "pdfkit"

// Prompt for the image file paths
const imageFilePaths = await arg({
  placeholder: "Select image files to combine into PDF", 
  multiple: true,
}, async () => {
  // Get the selected files from Finder
  const selectedFiles = await getSelectedFile()
  // Split file paths 
  return selectedFiles ? selectedFiles.split("\n") : [] 
})

// Create a new PDF document
const doc = new PDFDocument() 

// Set the output file path for the PDF
const outputPath = await path({ 
  hint: "Select a location to save the PDF", 
})

// Pipe the PDF document to a write stream
const stream = createWriteStream(outputPath) 
doc.pipe(stream) 

// Add each image to the PDF document 
for (const imagePath of imageFilePaths) {
  doc.image(imagePath, {
    // Scale the image to fit the page width 
    fit: [doc.page.width, doc.page.height], 
  })
  doc.addPage() // Add a new page for each image
}

// Finalize the PDF document (this will also close the stream)
doc.end();

console.log(`Images combined into PDF: ${outputPath}`);
```


## Resize Images and Add Watermark

```typescript
// Name: Resize and Watermark Images
// Description: Resizes and adds a watermark to images in a directory
// Author: johnlindquist

import "@johnlindquist/kit"
import { globby } from "globby";
import sharp from "sharp";

// Prompt for the directory containing images
const directoryPath = await path({
  hint: "Select directory containing images:",
  onlyDirs: true, 
})

// Get all image files in the directory 
const imageFiles = await globby([
  `${directoryPath}/*.jpg`,
  `${directoryPath}/*.jpeg`,
  `${directoryPath}/*.png`,
], {
  expandDirectories: {
    extensions: ["jpg", "jpeg", "png"], 
  }, 
})

// Prompt for the watermark text 
const watermarkText = await arg("Enter watermark text:")

// Prompt for the new image width
const newWidth = parseInt(await arg("Enter new image width:")) 

// Load the watermark font (replace with your desired font) 
const font = await Jimp.loadFont(Jimp.FONT_SANS_32_BLACK)

// Resize and add watermark to each image file
for (const file of imageFiles) {
  // Read the image using Sharp
  const image = sharp(file)

  // Get image metadata to calculate watermark position
  const { width, height } = await image.metadata()

  // Create a Jimp image for the watermark
  let watermark = new Jimp(width, height, "#00000000") // Transparent background
  watermark.print(
    font, 
    10, // X position
    height - 40, // Y position (adjust as needed) 
    watermarkText,
  )
  const watermarkBuffer = await watermark.getBufferAsync(Jimp.MIME_PNG)

  // Resize the image and composite the watermark
  const resizedImage = await image
    .resize(newWidth)
    .composite([{ input: watermarkBuffer, gravity: "southeast" }])
    .toBuffer()

  // Overwrite the original file with the watermarked image 
  await writeFile(file, resizedImage) 

  console.log(`Resized and watermarked: ${file}`);
} 

console.log("All images resized and watermarked.")
```

## Convert a Website to PDF and Save to Dropbox

```typescript
// Name: Save Webpage to Dropbox as PDF 
// Description: Converts a website to a PDF file using Puppeteer and saves it to Dropbox
// Author: johnlindquist

import "@johnlindquist/kit" 
import puppeteer from "puppeteer"
import { Dropbox } from "dropbox" 

// Get the Dropbox API token from the environment
// https://www.dropbox.com/developers/apps 
const dropboxToken = await env("DROPBOX_TOKEN") 

// Prompt for the website URL 
const websiteUrl = await arg({
  placeholder: "Enter website URL:", 
});

// Launch a headless Chrome instance 
const browser = await puppeteer.launch()
const page = await browser.newPage() 

// Go to the specified URL 
await page.goto(websiteUrl, { waitUntil: "networkidle2" })

// Generate the PDF 
const pdfBuffer = await page.pdf({ format: "A4" }) 

// Close the browser
await browser.close(); 

// Initialize the Dropbox client 
const dbx = new Dropbox({ accessToken: dropboxToken }) 

// Construct the file name 
const fileName = `${new URL(websiteUrl).hostname}.pdf`

// Upload the PDF to Dropbox
await dbx.filesUpload({
  path: `/${fileName}`, 
  contents: pdfBuffer,
  mode: { ".tag": "overwrite" }, // Overwrite if the file exists
});

console.log(`Website converted to PDF and saved to Dropbox: ${fileName}`)
```

## Create a New GitHub Issue with Labels

```typescript
// Name: Create GitHub Issue with Labels
// Description: Creates a new issue in a GitHub repository with labels
// Author: johnlindquist

import "@johnlindquist/kit"
import { Octokit } from "@octokit/rest"

// Get the GitHub API token from the environment
// https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token
const githubToken = await env("GITHUB_TOKEN")

// Initialize GitHub API client
const octokit = new Octokit({ auth: githubToken })

// Prompt for repository information
const repoOwner = await arg("Enter repository owner:")
const repoName = await arg("Enter repository name:")

// Prompt for issue details
const issueTitle = await arg("Enter issue title:")
const issueBody = await editor({
  placeholder: "Enter issue body:", 
}) 

// Prompt for labels (comma-separated)
const labelsString = await arg({
  placeholder: "Enter labels (comma-separated):", 
}) 
const labels = labelsString.split(",").map(label => label.trim()); 

// Create the issue on GitHub
await octokit.issues.create({ 
  owner: repoOwner,
  repo: repoName,
  title: issueTitle,
  body: issueBody,
  labels: labels, // Add the labels to the issue
}); 

console.log(`Issue "${issueTitle}" with labels ${labels.join(", ")} created successfully in ${repoOwner}/${repoName}.`) 
```

## Convert Text to Speech Using a Specific Voice from AWS Polly

```typescript
// Name: Text to Speech with AWS Polly (Specific Voice)
// Description: Converts text to speech using a specific voice from AWS Polly
// Author: johnlindquist 

import "@johnlindquist/kit"
import AWS from "aws-sdk"

// Get the AWS credentials from the environment
// https://docs.aws.amazon.com/sdk-for-javascript/v2/developer-guide/setting-credentials-node.html
const awsAccessKeyId = await env("AWS_ACCESS_KEY_ID") 
const awsSecretAccessKey = await env("AWS_SECRET_ACCESS_KEY")

// Configure AWS SDK 
AWS.config.update({
  accessKeyId: awsAccessKeyId, 
  secretAccessKey: awsSecretAccessKey,
  region: "us-east-1", // Replace with your desired AWS region
});

// Create an instance of Amazon Polly
const polly = new AWS.Polly();

// Prompt for text input
const inputText = await arg("Enter text:")

// Prompt for the voice ID 
const voiceId = await arg({
  placeholder: "Enter AWS Polly voice ID:",
  hint: "You can find a list of available voices at https://docs.aws.amazon.com/polly/latest/dg/voicelist.html", 
})

// Define the parameters for text-to-speech conversion 
const params = {
  OutputFormat: "mp3",
  Text: inputText,
  VoiceId: voiceId,
}

// Convert the text to speech 
polly.synthesizeSpeech(params, async (err, data) => {
  if (err) {
    console.error(err)
  } else {
    // Save the audio data as an MP3 file
    const audioFilePath = tmpPath("speech.mp3")
    const audioBuffer = data.AudioStream as Buffer;
    await writeFile(audioFilePath, audioBuffer)

    // Play the generated speech 
    await playAudioFile(audioFilePath) 
  }
});
```

##  Generate a Shortened URL with Custom Slug 

```typescript
// Name: Shorten URL with Custom Slug
// Description: Generates a shortened URL with a custom slug using Short.io
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the Short.io API key from the environment
// https://app.short.io/settings/integrations/api-key 
const shortIoApiKey = await env("SHORT_IO_API_KEY")

// Prompt for the original URL to shorten
const originalUrl = await arg("Enter URL to shorten:") 

// Prompt for the desired custom slug
const customSlug = await arg("Enter desired custom slug:")

// Shorten the URL using the Short.io API, specifying the custom slug
const { data: shortLinkData } = await post(
  "https://api.short.io/links", 
  {
    originalURL: originalUrl, 
    domain: "j.mp", // Or your custom Short.io domain
    path: customSlug, // Set the custom slug
  },
  { 
    headers: {
      Authorization: shortIoApiKey, 
      "Content-Type": "application/json",
    },
  }
);

// Extract the shortened URL 
const shortenedUrl = shortLinkData.shortURL 

// Display the shortened URL
await div(md(`# Shortened URL with Custom Slug: \n\n[${shortenedUrl}](${shortenedUrl})`)) 
```

## Create a New Notion Database

```typescript
// Name: Create Notion Database
// Description: Creates a new database in Notion 
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the Notion API token from the environment
// https://developers.notion.com/docs/getting-started 
const notionToken = await env("NOTION_TOKEN") 

// Prompt for the parent page ID 
const parentPageId = await arg({
  placeholder: "Enter Notion parent page ID:"
}) 

// Prompt for the database title
const databaseTitle = await arg("Enter database title:") 

// Create a new database in Notion
await post(
  `https://api.notion.com/v1/databases`,
  {
    parent: {
      type: "page_id",
      page_id: parentPageId, 
    },
    title: [
      {
        type: "text",
        text: {
          content: databaseTitle, 
        }, 
      },
    ],
    properties: {
      // Define the properties for the database (replace with your desired properties) 
      Name: {
        title: {},
      }, 
    }, 
  }, 
  {
    headers: {
      Authorization: `Bearer ${notionToken}`,
      "Notion-Version": "2022-06-28", // Specify Notion API version
      "Content-Type": "application/json", 
    },
  }
)

console.log(`Database "${databaseTitle}" created successfully in Notion.`) 
```

##  Set a Custom Reminder with a Due Date and Time

```typescript
// Name: Set Reminder with Due Date
// Description: Creates a reminder with a specific due date and time 
// Author: johnlindquist 

import "@johnlindquist/kit" 

// Prompt for the reminder title 
const reminderTitle = await arg("Enter reminder title:")

// Prompt for the due date and time (YYYY-MM-DD HH:mm) 
const dueDateTime = await arg("Enter due date and time (YYYY-MM-DD HH:mm):")

// Parse the date and time string
const [dueDate, dueTime] = dueDateTime.split(" ")

// Create a new reminder with due date and time using AppleScript
await applescript(` 
tell application "Reminders"
  set newReminder to make new reminder with properties {name: "${reminderTitle}"}
  tell newReminder 
    set due date to date "${dueDate}" & " at " & time "${dueTime}" 
  end tell
end tell
`)

console.log(`Reminder "${reminderTitle}" added with due date and time.`) 
```




## Create a New Asana Task in a Specific Section

```typescript
// Name: Create Asana Task (with Section)
// Description: Creates a new task in a specific section of an Asana project 
// Author: johnlindquist

import "@johnlindquist/kit" 

// Get the Asana API token from the environment 
// https://developers.asana.com/docs/personal-access-token
const asanaToken = await env("ASANA_TOKEN") 

// Prompt for the project ID
const projectId = await arg("Enter Asana project ID:") 

// Fetch the sections of the project from Asana
const sectionsResponse = await get(
  `https://app.asana.com/api/1.0/projects/${projectId}/sections`,
  { 
    headers: {
      Authorization: `Bearer ${asanaToken}`,
    },
  }
) 

// Prompt the user to select a section from the list
const sectionId = await arg(
  "Select a section:",
  sectionsResponse.data.data.map(section => ({
    name: section.name,
    value: section.gid, // Use the section's GID as the value 
  })) 
) 

// Prompt for the task name
const taskName = await arg("Enter task name:") 

// Create the task in the selected section 
await post( 
  `https://app.asana.com/api/1.0/tasks`, 
  {
    data: { 
      projects: [projectId],
      name: taskName, 
      memberships: [{ section: sectionId }], // Assign the task to the selected section 
    },
  }, 
  {
    headers: { 
      Authorization: `Bearer ${asanaToken}`, 
    }, 
  }
); 

console.log(`Task "${taskName}" created successfully in section ${sectionId} of Asana project ${projectId}.`)
```

## Create and Share a Public GitHub Repository

```typescript
// Name: Create Public GitHub Repo 
// Description: Creates a new public GitHub repository 
// Author: johnlindquist

import "@johnlindquist/kit"
import { Octokit } from "@octokit/rest" 

// Get the GitHub API token from the environment 
// https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token 
const githubToken = await env("GITHUB_TOKEN")

// Initialize GitHub API client
const octokit = new Octokit({ auth: githubToken })

// Prompt for the repository name 
const repoName = await arg("Enter repository name:") 

// Prompt for the repository description 
const repoDescription = await arg("Enter repository description:") 

// Create a new public GitHub repository
await octokit.repos.createForAuthenticatedUser({ 
  name: repoName, 
  description: repoDescription,
  private: false, // Make the repository public 
})

console.log(`Public repository ${repoName} created successfully.`) 
```

## Convert Text to Speech and Play Audio with Different Playback Rates

```typescript
// Name: Text to Speech with Playback Rate
// Description: Converts text to speech and allows adjusting the playback rate
// Author: johnlindquist 

import "@johnlindquist/kit"
import { Configuration, OpenAIApi } from "openai";

// Get the OpenAI API key from the environment 
// https://beta.openai.com/account/api-keys 
const openaiApiKey = await env("OPENAI_API_KEY") 

// Initialize OpenAI API
const openai = new OpenAIApi(new Configuration({ apiKey: openaiApiKey }))

// Prompt for text input 
const inputText = await arg("Enter text to convert to speech:")

// Generate speech audio 
const response = await openai.audio.speech.create({ 
  model: "tts-1",
  voice: "alloy", 
  input: inputText,
}); 

// Save the audio data as an MP3 file
const audioFilePath = tmpPath("speech.mp3")
const audioArrayBuffer = await response.arrayBuffer();
const audioBuffer = Buffer.from(audioArrayBuffer)
await writeFile(audioFilePath, audioBuffer);

// Prompt for playback rate 
const playbackRate = parseFloat(await arg("Enter playback rate (e.g., 1.0, 1.5, 2.0):")) 

// Play the generated speech with the selected playback rate
await playAudioFile(audioFilePath, { playbackRate })
```

## Get a List of Your Starred GitHub Repositories

```typescript
// Name: List Starred Repositories
// Description: Lists your starred repositories on GitHub
// Author: johnlindquist

import "@johnlindquist/kit" 
import { Octokit } from "@octokit/rest"

// Get the GitHub API token from the environment 
// https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token 
const githubToken = await env("GITHUB_TOKEN") 

// Initialize GitHub API client
const octokit = new Octokit({ auth: githubToken }); 

// Fetch the list of your starred repositories
const starredRepos = await octokit.activity.listReposStarredByAuthenticatedUser({
  per_page: 100, // Set the number of repos per page 
})

// Create choices from the starred repositories
let repoChoices = starredRepos.data.map(repo => ({
  name: repo.name, 
  description: repo.description, 
  value: repo.html_url, 
})) 

// Prompt for selection and open the repository in the browser
let repoUrl = await arg("Starred repositories:", repoChoices);
await open(repoUrl)
```

## Create a New Trello List

```typescript
// Name: Create Trello List
// Description: Creates a new list on a Trello board
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the Trello API key and token from the environment 
// https://developer.atlassian.com/cloud/trello/guides/rest-api/authorization/
const trelloApiKey = await env("TRELLO_API_KEY")
const trelloToken = await env("TRELLO_TOKEN") 

// Prompt for the board ID
const boardId = await arg({ 
  placeholder: "Enter Trello board ID:",
}); 

// Prompt for the new list's name
const listName = await arg("Enter list name:")

// Create the list on the specified Trello board
await post(
  `https://api.trello.com/1/lists?key=${trelloApiKey}&token=${trelloToken}`,
  {
    name: listName,
    idBoard: boardId, 
    pos: "bottom", // Add the list to the bottom of the board 
  }
) 

console.log(`List "${listName}" created successfully on Trello board ${boardId}.`); 
```

##  Get System Memory Usage

```typescript
// Name: Memory Usage
// Description: Displays system memory usage information
// Author: johnlindquist

import "@johnlindquist/kit"
import os from "os"

// Get system memory information
const totalMemory = os.totalmem() 
const freeMemory = os.freemem()

// Calculate used memory
const usedMemory = totalMemory - freeMemory; 

// Calculate memory usage percentage
const memoryUsagePercentage = (usedMemory / totalMemory) * 100;

// Display memory usage information in a div
await div(md(`
# Memory Usage:

* Total: ${filesize(totalMemory)}
* Used: ${filesize(usedMemory)} (${memoryUsagePercentage.toFixed(2)}%) 
* Free: ${filesize(freeMemory)}
`))
```

##  Send a Message to a Discord Channel with a File Attachment

```typescript
// Name: Send Discord Message with Attachment
// Description: Sends a message with a file attachment to a Discord channel
// Author: johnlindquist

import "@johnlindquist/kit"
import FormData from "form-data"

// Get the Discord webhook URL from the environment
// https://discord.com/developers/docs/intro 
const discordWebhookUrl = await env("DISCORD_WEBHOOK_URL") 

// Prompt for the file path
const filePath = await path({
  hint: "Select a file to attach", 
})

// Read the file content 
const fileContent = await readFile(filePath)

// Create a new FormData instance 
const formData = new FormData() 
formData.append("file", fileContent, { filename: path.basename(filePath) }) 
formData.append(
  "content",
  await arg("Enter your message:")
) 

// Send the message with attachment to the Discord channel 
await fetch(
  discordWebhookUrl, 
  { 
    method: "POST", 
    body: formData as any, 
  } 
);

console.log(`Message with attachment "${filePath}" sent to Discord.`);
```



## Check for and Install Missing macOS System Updates

```typescript
// Name: Install macOS Updates
// Description: Checks for and installs macOS system updates
// Author: johnlindquist

import "@johnlindquist/kit"

// Display a terminal prompting the user to install updates
await term({
  command: "softwareupdate --install --all", // Install all available updates
  preview: md(`# Installing macOS Updates

This will install all available macOS updates. Make sure to save your work before proceeding.

Press Enter to continue or Escape to cancel.
`),
  shortcuts: [], // Disable default shortcuts
})
```

## Create a New Branch in Git and Edit a Specific File

```typescript
// Name: Create Branch and Edit File
// Description: Creates a new Git branch and opens a specified file for editing 
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt for the new branch name
const branchName = await arg("Enter new branch name:")

// Prompt for the file path to edit 
const filePath = await path({
  hint: "Select a file to edit",
})

// Create the new branch and switch to it
await $`git checkout -b ${branchName}`

// Open the selected file in the editor 
await edit(filePath)
```

## Get the Latest News from Hacker News

```typescript
// Name: Hacker News Headlines
// Description: Fetches and displays the latest headlines from Hacker News
// Author: johnlindquist

import "@johnlindquist/kit"

// Fetch top story IDs from Hacker News API
const topStoryIds = await get("https://hacker-news.firebaseio.com/v0/topstories.json")
  .then(res => res.data)

// Fetch details for the top 5 stories
let topStories = []
for (let i = 0; i < 5; i++) {
  const storyId = topStoryIds[i]
  const story = await get(`https://hacker-news.firebaseio.com/v0/item/${storyId}.json`)
    .then(res => res.data)
  topStories.push(story)
}

// Create an array of choices for the top stories
const storyChoices = topStories.map(story => ({
  name: story.title, 
  value: story.url,
  description: `${story.score} points by ${story.by}`, 
})) 

// Prompt the user to select a story to open in the browser
let storyUrl = await arg("Top Hacker News stories:", storyChoices)
await open(storyUrl)
```

## Resize and Crop an Image

```typescript
// Name: Resize and Crop Image
// Description: Resizes and crops an image to specific dimensions
// Author: johnlindquist

import "@johnlindquist/kit"
import sharp from "sharp"

// Prompt for the image path
const imagePath = await path({
  hint: "Select an image file", 
})

// Prompt for the new width 
const width = parseInt(await arg("Enter new width:"))

// Prompt for the new height
const height = parseInt(await arg("Enter new height:")) 

// Resize and crop the image using Sharp 
await sharp(imagePath) 
  .resize(width, height, {
    // Use "fit: cover" to resize and crop to the exact dimensions 
    fit: "cover",
  })
  .toFile(imagePath); 

console.log(`Image resized and cropped to ${width}x${height}.`)
```

##  Delete a Local Git Branch

```typescript
// Name: Delete Git Branch 
// Description: Deletes a local Git branch
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the branch name to delete
const branchName = await arg("Enter the name of the branch to delete:");

// Delete the local branch
await $`git branch -D ${branchName}`

console.log(`Local branch ${branchName} deleted.`)
```

## Get the Current Weather Conditions and Forecast for a Location

```typescript
// Name: Weather and Forecast
// Description: Displays the current weather and forecast for a given location
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the OpenWeatherMap API key from the environment
// https://openweathermap.org/api
const openWeatherMapApiKey = await env("OPENWEATHERMAP_API_KEY")

// Prompt for the location
let location = await arg("Enter location:");

// Fetch current weather data from the API
const currentWeatherResponse = await get(
  `https://api.openweathermap.org/data/2.5/weather?q=${location}&appid=${openWeatherMapApiKey}&units=metric` 
)

const { coord } = currentWeatherResponse.data

// Fetch the forecast for the location using the coordinates
const forecastResponse = await get(
  `https://api.openweathermap.org/data/2.5/onecall?lat=${coord.lat}&lon=${coord.lon}&appid=${openWeatherMapApiKey}&exclude=current,minutely,hourly,alerts&units=metric` 
)

// Extract relevant data from the forecast response
const forecastData = forecastResponse.data.daily

// Create an array of forecast items for the next 5 days
let forecastChoices = forecastData.slice(0, 5).map((day, index) => ({
  name: `Day ${index + 1}: ${new Date(day.dt * 1000).toLocaleDateString()}`, 
  // Include relevant weather information for the day in the choice
  description: `Temperature: ${day.temp.day}Â°C, Feels like: ${day.feels_like.day}Â°C, Condition: ${day.weather[0].description}`, 
  value: day,
})) 

// Display the choices to the user 
let selectedForecast = await arg(
  {
    placeholder: "Select a day to view details:",
  },
  forecastChoices
)

// Display detailed forecast information in a div
await div(md(`
## Detailed Forecast for ${new Date(selectedForecast.dt * 1000).toLocaleDateString()}:

* Temperature:
    * Day: ${selectedForecast.temp.day}Â°C
    * Night: ${selectedForecast.temp.night}Â°C
    * High: ${selectedForecast.temp.max}Â°C
    * Low: ${selectedForecast.temp.min}Â°C 
* Feels like: 
    * Day: ${selectedForecast.feels_like.day}Â°C
    * Night: ${selectedForecast.feels_like.night}Â°C 
* Condition: ${selectedForecast.weather[0].description}
* Humidity: ${selectedForecast.humidity}%
* Wind Speed: ${selectedForecast.wind_speed} m/s 
* UV Index: ${selectedForecast.uvi}
`))
```

##  Check if a Port is Open

```typescript
// Name: Check Port Availability
// Description: Checks if a specific port is open on your system 
// Author: johnlindquist

import "@johnlindquist/kit"
import { checkPortStatus } from "tcp-port-scanner"; 

// Prompt for the port number to check 
const port = parseInt(await arg("Enter port number:"), 10) 

// Check the port status 
const isOpen = await checkPortStatus(port, "127.0.0.1"); 

// Display the result in a div 
await div(md(`# Port ${port} is ${isOpen ? "open" : "closed"} on your system.`))
```




## Download and Install a Homebrew Cask

```typescript
// Name: Install Homebrew Cask
// Description: Downloads and installs a Homebrew cask
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the cask name 
const caskName = await arg("Enter cask name:"); 

// Install the cask using Homebrew
await term({ 
  command: `brew install --cask ${caskName}`, 
  cwd: home(), 
  height: 140,
  enter: "Exit", 
  shortcuts: [],
})
```

## Create a New Google Calendar Event with Video Conference

```typescript
// Name: Schedule Google Meet Event
// Description: Creates a new Google Calendar event with a Google Meet video conference
// Author: johnlindquist

import "@johnlindquist/kit"
import { google } from "googleapis"; 

// Get the Google Calendar API credentials from the environment
// https://developers.google.com/calendar/api/quickstart/nodejs
const googleCalendarCredentials = JSON.parse(
  await env("GOOGLE_CALENDAR_CREDENTIALS") 
)
// Authorize with the Google Calendar API
const auth = new google.auth.GoogleAuth({ 
  credentials: googleCalendarCredentials, 
  scopes: ["https://www.googleapis.com/auth/calendar"],
}) 
const calendar = google.calendar({ version: "v3", auth })

// Prompt for event details 
const eventSummary = await arg("Enter event summary:")
const eventStartTime = await arg(
  "Enter event start time (YYYY-MM-DDTHH:mm:ss):"
) 
const eventEndTime = await arg( 
  "Enter event end time (YYYY-MM-DDTHH:mm:ss):"
)

// Create the event object with a Google Meet conference
const event = {
  summary: eventSummary, 
  start: {
    dateTime: eventStartTime,
  }, 
  end: {
    dateTime: eventEndTime,
  }, 
  conferenceData: { 
    createRequest: {
      requestId: Math.random().toString(), // Generate a unique request ID 
      conferenceSolutionKey: { type: "hangoutsMeet" }, 
    },
  },
}

// Insert the event into the user's primary calendar
await calendar.events.insert({ 
  calendarId: "primary", 
  conferenceDataVersion: 1, 
  requestBody: event, 
}) 

// Display the meeting link in a div
await div(md(`# Google Meet event created!

Join the meeting:

[${event.hangoutLink}](${event.hangoutLink}) 
`))
```

## Check for and Remove Unused Docker Images

```typescript
// Name: Docker Image Cleanup 
// Description: Checks for and removes unused Docker images
// Author: johnlindquist 

import "@johnlindquist/kit"

// Execute the Docker command to list unused images 
const { stdout: unusedImages } = await exec("docker images --filter \"dangling=true\" -q");

// Check if there are any unused images
if (unusedImages.trim().length > 0) { 
  // Display a message and ask for confirmation before removing the images 
  let removeImages = await arg(
    {
      placeholder: "Unused Docker images found. Remove them?",
    }, 
    ["yes", "no"]
  );

  if (removeImages === "yes") { 
    // Remove unused Docker images
    await term({ 
      command: `docker rmi ${unusedImages}`, 
      cwd: home(), 
      height: 140,
      enter: "Exit",
      shortcuts: [], 
    }); 
  }
} else {
  // Display a message if no unused images are found 
  await div(md(`# No unused Docker images found.`))
}
```

## Convert a Series of Images to a GIF

```typescript
// Name: Images to GIF
// Description: Converts a series of images to a GIF using FFmpeg
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt for the directory containing images
const directoryPath = await path({
  hint: "Select directory containing images:", 
  onlyDirs: true,
}); 

// Prompt for the desired output file name for the GIF 
const outputFileName = await arg("Enter output file name for GIF:")

// Construct the full output path
const outputPath = path.join(directoryPath, `${outputFileName}.gif`)

// Execute FFmpeg command to create a GIF from the images 
await execa("ffmpeg", [
  "-framerate", 
  "10", // Set the desired frame rate for the GIF
  "-i",
  `${directoryPath}/image%d.png`, // Pattern to match image files
  "-vf", 
  "scale=320:-1:flags=lanczos", // Adjust scaling as needed
  outputPath,
], { 
  stdio: "inherit" // Display FFmpeg output in the terminal
});

// Reveal the generated GIF in Finder 
await revealFile(outputPath) 
```

## Generate a Random Password and Display its Strength

```typescript
// Name: Password Strength Checker 
// Description: Generates a random password and displays its strength 
// Author: johnlindquist 

import "@johnlindquist/kit" 
import { generate } from "generate-password"
import zxcvbn from "zxcvbn"

// Function to display password strength
async function displayPasswordStrength(password: string) {
  // Calculate password strength using zxcvbn
  const strength = zxcvbn(password)

  // Create a color-coded strength indicator based on the score 
  let strengthColor = ""
  if (strength.score <= 1) {
    strengthColor = "text-red-500"
  } else if (strength.score === 2) {
    strengthColor = "text-yellow-500"
  } else if (strength.score === 3) { 
    strengthColor = "text-green-500"
  } else {
    strengthColor = "text-blue-500" 
  } 

  // Display the strength score and feedback
  await div(
    md(`
    # Password Strength: <span class="${strengthColor} font-bold">${strength.score} / 4</span>
    
    ## Feedback: ${strength.feedback.warning} 

    ${strength.feedback.suggestions.map(s => `- ${s}`).join("\n")}
    `)
  ) 
}

// Generate a random password 
const password = generate({
  length: 12,
  numbers: true,
  symbols: true, 
  uppercase: true, 
  lowercase: true,
  excludeSimilarCharacters: true, 
}); 

// Display the generated password and its strength 
await displayPasswordStrength(password)
```

## Get a List of Installed Applications

```typescript
// Name: List Installed Apps 
// Description: Lists all installed applications on your system (macOS only)
// Author: johnlindquist 

import "@johnlindquist/kit"

// Get a list of installed applications on macOS 
const applications = await applescript( 
  `set appPaths to paragraphs of (do shell script "mdfind 'kMDItemKind == Application'")
  set appNames to {} 
  repeat with appPath in appPaths
    set appName to name of (info for (POSIX file appPath as text)) 
    set end of appNames to appName
  end repeat 
  return appNames as text` 
)

// Display the application names in the editor 
await editor({
  value: applications, 
  language: "text",
})
```

## Create a Time-Tracking Entry with a Description and Project in Toggl Track

```typescript
// Name: Start Toggl Timer for Project
// Description: Starts a new time entry in Toggl Track for a selected project 
// Author: johnlindquist 

import "@johnlindquist/kit" 
import { Toggl } from "toggl-api" 

// Get the Toggl Track API token from the environment 
// https://track.toggl.com/profile
const togglApiKey = await env("TOGGL_API_KEY")

// Initialize the Toggl Track client 
const toggl = new Toggl({ apiToken: togglApiKey })

// Get a list of workspaces
const workspaces = await new Promise(resolve =>
  toggl.getWorkspaces((err, workspaces) => {
    if (err) {
      console.error(`Error fetching workspaces: ${err}`)
      resolve([])
    }
    resolve(workspaces)
  })
)

// Prompt the user to select a workspace
let workspaceId = await arg(
  "Select workspace:",
  workspaces.map(w => ({ name: w.name, value: w.id }))
)

// Get projects for the selected workspace
const projects = await new Promise(resolve =>
  toggl.getWorkspaceProjects(workspaceId, (err, projects) => {
    if (err) {
      console.error(`Error fetching projects: ${err}`)
      resolve([])
    }
    resolve(projects)
  })
)

// Prompt for the project ID 
const projectId = await arg(
  "Select a project:",
  projects.map(p => ({ name: p.name, value: p.id }))
)

// Prompt for the task description
const description = await arg("Enter task description:") 

// Start a new time entry for the selected project 
toggl.startTimeEntry(
  { description: description, pid: projectId },
  (err, data) => {
    if (err) {
      console.error("Error starting time entry:", err) 
    } else {
      console.log("Time entry started:", data) 
    }
  }
)
```


## Create a Pull Request on Bitbucket

```typescript
// Name: Create Bitbucket Pull Request
// Description: Creates a new pull request on Bitbucket
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the Bitbucket workspace and repository slug from the environment
// https://developer.atlassian.com/bitbucket/api/2/reference/meta/authentication
const bitbucketWorkspace = await env("BITBUCKET_WORKSPACE") 
const bitbucketRepoSlug = await env("BITBUCKET_REPO_SLUG") 

// Prompt for the pull request details
const sourceBranch = await arg("Enter source branch name:") 
const destinationBranch = await arg("Enter destination branch name:") 
const title = await arg("Enter pull request title:") 
const description = await editor({
  placeholder: "Enter pull request description:", 
})

// Create the pull request on Bitbucket using the API
await post(
  `https://api.bitbucket.org/2.0/repositories/${bitbucketWorkspace}/${bitbucketRepoSlug}/pullrequests`,
  { 
    title, 
    description, 
    source: {
      branch: { 
        name: sourceBranch,
      }, 
    },
    destination: {
      branch: {
        name: destinationBranch, 
      }, 
    }, 
  },
  {
    headers: {
      Authorization: `Bearer ${await env("BITBUCKET_APP_PASSWORD")}`, 
    },
  }
)
  .then(() => {
    console.log(`Pull request "${title}" created successfully on Bitbucket.`);
  })
  .catch(err => {
    console.error(`Error creating Bitbucket pull request: ${err}`)
  })
```

##  Get Current Weather and Send it to Slack

```typescript
// Name: Weather to Slack
// Description: Fetches current weather and sends it to a Slack channel
// Author: johnlindquist 

import "@johnlindquist/kit"

// Get the OpenWeatherMap API key from the environment
// https://openweathermap.org/api
const openWeatherMapApiKey = await env("OPENWEATHERMAP_API_KEY")

// Get the Slack webhook URL from the environment 
// https://api.slack.com/messaging/webhooks
const slackWebhookUrl = await env("SLACK_WEBHOOK_URL") 

// Prompt for the location
let location = await arg("Enter location:") 

// Fetch weather data from the API 
const response = await get(
  `https://api.openweathermap.org/data/2.5/weather?q=${location}&appid=${openWeatherMapApiKey}&units=metric`
)

// Extract relevant weather information
const { name, main, weather } = response.data 

// Construct the message to send to Slack 
const slackMessage = `The current weather in ${name} is ${main.temp}Â°C, feels like ${main.feels_like}Â°C, with ${weather[0].description}.`

// Send the weather information to Slack 
await post(slackWebhookUrl, { text: slackMessage });

console.log(`Weather information sent to Slack channel.`)
```

##  Check for and Install Missing Fonts from Google Fonts

```typescript
// Name: Google Font Installer 
// Description: Checks if a font from Google Fonts is installed and installs it if missing 
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the font name 
const fontName = await arg("Enter font name (e.g., 'Roboto', 'Open Sans'):"); 

// Construct the Google Fonts URL for the font
const fontUrl = `https://fonts.googleapis.com/css2?family=${encodeURIComponent(fontName)}`

// Fetch the font CSS file from Google Fonts 
const response = await get(fontUrl)

// Check if the font is installed by searching for its name in the CSS content
let fontInstalled = response.data.includes(`font-family: '${fontName}'`)

// Prompt the user to install the font if it's not found
if (!fontInstalled) { 
  let installFont = await arg(
    `Font "${fontName}" not found. Install it?`, 
    ["yes", "no"]
  ) 

  if (installFont === "yes") {
    // Download the font files (replace with actual download logic) 
    // ... 

    // Install the downloaded font files (replace with actual installation logic) 
    // ... 

    console.log(`Font "${fontName}" installed successfully.`)
  }
} else {
  await div(md(`# Font "${fontName}" is already installed.`)); 
} 
```

## Generate a Random Quote and Post it to a Discord Channel

```typescript
// Name: Discord Quote Bot
// Description: Fetches a random quote and posts it to a Discord channel
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the Discord webhook URL from the environment
// https://discord.com/developers/docs/intro 
const discordWebhookUrl = await env("DISCORD_WEBHOOK_URL"); 

// Fetch a random quote from the Quotable API
const quoteResponse = await get("https://api.quotable.io/random");

// Extract the quote content and author
const { content, author } = quoteResponse.data 

// Construct the message to send to Discord
const discordMessage = `> ${content}\n\n- ${author}`

// Send the quote to the Discord channel
await post(
  discordWebhookUrl, 
  { 
    content: discordMessage,
  } 
);

console.log(`Quote sent to Discord: "${content}" - ${author}`); 
```

## Create a New Trello Card with a Checklist

```typescript
// Name: Create Trello Card with Checklist
// Description: Creates a new card on a Trello board with a checklist
// Author: johnlindquist 

import "@johnlindquist/kit"

// Get the Trello API key and token from the environment
// https://developer.atlassian.com/cloud/trello/guides/rest-api/authorization/
const trelloApiKey = await env("TRELLO_API_KEY") 
const trelloToken = await env("TRELLO_TOKEN") 

// Prompt for the board ID 
const boardId = await arg({ 
  placeholder: "Enter Trello board ID:",
}) 

// Prompt for the list ID 
const listId = await arg({ 
  placeholder: "Enter Trello list ID:",
})

// Prompt for the card name
const cardName = await arg("Enter card name:") 

// Prompt for checklist items (comma-separated)
const checklistItemsString = await arg(
  "Enter checklist items (comma-separated):"
); 
const checklistItems = checklistItemsString.split(",").map(item => item.trim()); 

// Create the card on Trello
const { data: cardData } = await post( 
  `https://api.trello.com/1/cards?key=${trelloApiKey}&token=${trelloToken}`,
  { 
    idList: listId,
    name: cardName, 
  }
) 

// Create the checklist on the new card
const checklistResponse = await post( 
  `https://api.trello.com/1/checklists?key=${trelloApiKey}&token=${trelloToken}`, 
  {
    idCard: cardData.id, 
    name: "Checklist",
  } 
)

// Add items to the checklist
const checklistId = checklistResponse.data.id
for (const item of checklistItems) { 
  await post( 
    `https://api.trello.com/1/checklists/${checklistId}/checkItems?key=${trelloApiKey}&token=${trelloToken}`, 
    {
      name: item, 
    } 
  );
}

console.log(`Trello card "${cardName}" created with checklist.`)
```

## Get System Network Information

```typescript
// Name: Network Info
// Description: Displays system network information
// Author: johnlindquist

import "@johnlindquist/kit"
import { networkInterfaces } from "os"

// Get network interfaces
const interfaces = networkInterfaces();

// Iterate through interfaces and display information
let networkInfo = "# Network Interfaces:\n\n";
for (const interfaceName in interfaces) { 
  const addresses = interfaces[interfaceName]
  networkInfo += `## ${interfaceName}:\n` 
  for (const address of addresses) { 
    networkInfo += `* ${address.family}: ${address.address} (${address.mac})\n`;
  }
}

// Display the network information in a div 
await div(md(networkInfo.trim()))
```

##  Send a Scheduled Tweet 

```typescript
// Name: Schedule Tweet
// Description: Schedules a tweet for a specific date and time
// Author: johnlindquist 

import "@johnlindquist/kit" 
import Twitter from "twitter-api-v2"

// Get the Twitter API keys from the environment 
// https://developer.twitter.com/en/portal/dashboard
const twitterConsumerKey = await env("TWITTER_CONSUMER_KEY") 
const twitterConsumerSecret = await env("TWITTER_CONSUMER_SECRET") 
const twitterAccessTokenKey = await env("TWITTER_ACCESS_TOKEN_KEY")
const twitterAccessTokenSecret = await env("TWITTER_ACCESS_TOKEN_SECRET")

// Initialize the Twitter API client
const twitterClient = new Twitter({
  appKey: twitterConsumerKey, 
  appSecret: twitterConsumerSecret,
  accessToken: twitterAccessTokenKey,
  accessSecret: twitterAccessTokenSecret,
}); 

// Prompt for the tweet content
const tweetContent = await arg("Enter your tweet:")

// Prompt for the scheduled date and time (YYYY-MM-DD HH:mm)
const scheduledDateTime = await arg(
  "Enter scheduled date and time (YYYY-MM-DD HH:mm):" 
); 

// Parse the date and time string
const [scheduledDate, scheduledTime] = scheduledDateTime.split(" "); 

// Create a Date object for the scheduled time 
const scheduledDateObject = new Date(`${scheduledDate}T${scheduledTime}`); 

// Schedule the tweet using the Twitter API (not yet possible with the Twitter API v2)
// ... (You'll need to implement logic for scheduling the tweet, possibly using a third-party library or service) 

console.log(`Tweet "${tweetContent}" scheduled for ${scheduledDateTime}.`); 
```


## Create and Upload a File to Google Drive

```typescript
// Name: Create and Upload to Google Drive
// Description: Creates a new file and uploads it to your Google Drive
// Author: johnlindquist

import "@johnlindquist/kit"
import { google } from "googleapis"

// Get Google Drive API credentials from the environment
// https://developers.google.com/drive/api/quickstart/nodejs
const googleDriveCredentials = JSON.parse(
  await env("GOOGLE_DRIVE_CREDENTIALS")
)
// Authorize with Google Drive API
const auth = new google.auth.GoogleAuth({
  credentials: googleDriveCredentials,
  scopes: ["https://www.googleapis.com/auth/drive.file"],
})
const drive = google.drive({ version: "v3", auth })

// Prompt for the new file name
const fileName = await arg("Enter new file name:")

// Prompt for the file content using the editor
const fileContent = await editor({
  placeholder: "Enter file content:",
})

// Upload the file to Google Drive
await drive.files.create(
  {
    requestBody: {
      name: fileName, // Use the provided file name
      // parents: [folderId], // Optionally specify a folder ID to upload to a specific folder
    },
    media: {
      mimeType: "text/plain", // Set the appropriate MIME type based on the file content
      body: fileContent,
    },
  }
)

console.log(`File "${fileName}" created and uploaded to Google Drive.`)
```

## Resize an Image and Upload to Imgur

```typescript
// Name: Resize and Upload to Imgur
// Description: Resizes an image and uploads it to Imgur
// Author: johnlindquist

import "@johnlindquist/kit" 
import FormData from "form-data"
import sharp from "sharp"

// Get the Imgur Client ID from the environment
// https://apidocs.imgur.com/#authorization-and-oauth
const imgurClientId = await env("IMGUR_CLIENT_ID") 

// Prompt for the image path
const imagePath = await path({
  hint: "Select an image file",
})

// Prompt for the new width 
const newWidth = parseInt(await arg("Enter new width in pixels:"))

// Resize the image using Sharp
const resizedImageBuffer = await sharp(imagePath)
  .resize({ width: newWidth })
  .toBuffer()

// Create a FormData instance to upload the image 
const formData = new FormData()
formData.append("image", resizedImageBuffer, { filename: path.basename(imagePath) })

// Upload the resized image to Imgur 
const response = await fetch("https://api.imgur.com/3/image", {
  method: "POST",
  headers: { 
    Authorization: `Client-ID ${imgurClientId}`,
  }, 
  body: formData as any, 
});

// Extract and display the image link from the response
const { data: imgurData } = await response.json();
const imageUrl = imgurData.link;

await div(md(`# Uploaded Image to Imgur:\n\n[Image Link](${imageUrl})`))
```

##  Send a Direct Message on Slack

```typescript
// Name: Send Slack Direct Message
// Description: Sends a direct message to a Slack user 
// Author: johnlindquist

import "@johnlindquist/kit" 

// Get the Slack user ID and bot token from the environment
// https://api.slack.com/methods/chat.postMessage
const slackBotToken = await env("SLACK_BOT_TOKEN") 
const slackUserId = await arg("Enter Slack user ID:")

// Prompt for the message content 
const message = await arg("Enter your message:") 

// Send the direct message to the Slack user
await post( 
  "https://slack.com/api/chat.postMessage",
  {
    channel: slackUserId,
    text: message, 
  },
  { 
    headers: {
      Authorization: `Bearer ${slackBotToken}`,
      "Content-Type": "application/json",
    },
  }
); 

console.log(`Direct message sent to ${slackUserId} on Slack.`) 
```

## Create a New GitHub Repository with a README File

```typescript
// Name: Create GitHub Repo with README
// Description: Creates a new GitHub repository with a README file
// Author: johnlindquist

import "@johnlindquist/kit"
import { Octokit } from "@octokit/rest" 

// Get the GitHub API token from the environment 
// https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token 
const githubToken = await env("GITHUB_TOKEN"); 

// Initialize GitHub API client
const octokit = new Octokit({ auth: githubToken }) 

// Prompt for the repository name
const repoName = await arg("Enter repository name:") 

// Prompt for the repository description 
const repoDescription = await arg("Enter repository description:")

// Prompt for the README content
const readmeContent = await editor({ 
  placeholder: "Enter README content (Markdown format):",
  language: "markdown", 
}); 

// Create the repository on GitHub with the README file 
await octokit.repos.createForAuthenticatedUser({
  name: repoName,
  description: repoDescription,
  private: false,
  auto_init: true, // Initialize with a README
}) 
.then(async (response) => {
  // Get the default branch name
  const defaultBranch = response.data.default_branch

  // Create or update the README file on the default branch 
  await octokit.repos.createOrUpdateFileContents({ 
    owner: response.data.owner.login, 
    repo: repoName,
    path: "README.md",
    message: "Initial commit",
    content: Buffer.from(readmeContent).toString("base64"),
    branch: defaultBranch, 
  }) 
})

console.log(`Public repository ${repoName} created with README.md.`)
```

## Convert Text to Speech with ElevenLabs

```typescript
// Name: Text to Speech (ElevenLabs)
// Description: Converts text to speech using the ElevenLabs API
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the ElevenLabs API key from the environment
// https://elevenlabs.io/
const elevenLabsApiKey = await env("ELEVENLABS_API_KEY")
// Get the ElevenLabs voice ID from the environment
const elevenLabsVoiceId = await env("ELEVENLABS_VOICE_ID")

// Prompt for text input 
const inputText = await arg("Enter text to convert to speech:") 

// Convert text to speech using ElevenLabs API
const response = await post(
  `https://api.elevenlabs.io/v1/text-to-speech/${elevenLabsVoiceId}`, 
  {
    text: inputText,
    voice_settings: {
      stability: 0.75, // Adjust stability and similarity_boost as needed 
      similarity_boost: 0.75, 
    },
  }, 
  {
    headers: {
      "xi-api-key": elevenLabsApiKey,
      "Content-Type": "application/json", 
      Accept: "audio/mpeg",
    },
    responseType: "arraybuffer", // Receive the response as an ArrayBuffer
  }
)

// Save the audio data as an MP3 file 
const audioFilePath = tmpPath("speech.mp3"); 
const audioBuffer = Buffer.from(response.data)
await writeFile(audioFilePath, audioBuffer)

// Play the generated speech 
await playAudioFile(audioFilePath)

console.log("Text converted to speech using ElevenLabs and played successfully.") 
```

## Remove All Comments from a JavaScript File

```typescript
// Name: Remove JS Comments 
// Description: Removes all comments from a JavaScript file
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the JavaScript file path
const filePath = await path({
  hint: "Select a JavaScript file",
}) 

// Read the file contents 
const fileContent = await readFile(filePath, "utf-8") 

// Remove all comments from the JavaScript code using a regular expression 
const codeWithoutComments = fileContent.replace(/\/\*[\s\S]*?\*\/|\/\/.*/g, "") 

// Overwrite the original file with the updated content
await writeFile(filePath, codeWithoutComments)

console.log(`Removed comments from "${filePath}".`) 
```

##  Check for and Install Missing Brew Casks

```typescript
// Name: Install Brew Casks
// Description: Checks for and installs missing Homebrew casks
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt for a comma-separated list of cask names 
const caskNamesString = await arg("Enter cask names (comma-separated):")
const caskNames = caskNamesString.split(",").map(name => name.trim()); 

// Check if each cask is installed and install if missing 
for (const caskName of caskNames) { 
  // Check if the cask is already installed
  if (await isBin(caskName)) { 
    await div(md(`# Cask "${caskName}" is already installed.`)) 
  } else {
    // Install the cask using Homebrew 
    await term({
      command: `brew install --cask ${caskName}`, 
      cwd: home(), 
      height: 140, 
      enter: "Exit", 
      shortcuts: [], 
    });
  } 
}
```





## Generate a Sitemap for a WordPress Website

```typescript
// Name: WordPress Sitemap Generator
// Description: Generates a sitemap for a WordPress website using the XML-Sitemap npm package
// Author: johnlindquist

import "@johnlindquist/kit"
import { SitemapStream, streamToPromise } from "sitemap" 
import { parse } from "path"
import { load } from "cheerio";

// Prompt for the website URL
const websiteUrl = await arg("Enter website URL:");

// Fetch the website's homepage
const response = await get(websiteUrl);

// Load the HTML content with Cheerio
const $ = load(response.data);

// Find the sitemap URL from the <link> tag 
let sitemapUrl = $("link[rel='sitemap']").attr("href");

if (!sitemapUrl) {
  // Handle cases where the sitemap URL is not found 
  console.warn("Sitemap URL not found in the homepage. Please provide it manually.");
  sitemapUrl = await arg("Enter sitemap URL:"); 
} 

// Fetch the sitemap XML content 
const sitemapResponse = await get(sitemapUrl);

// Parse the XML content and extract URLs
const sitemapXml = sitemapResponse.data;
const $sitemap = load(sitemapXml, { xmlMode: true });
const urls = $sitemap("urlset url loc").map((i, el) => $(el).text()).get()

// Create a SitemapStream instance 
const sitemap = new SitemapStream({ hostname: websiteUrl });

// Write each URL to the sitemap stream
urls.forEach(url => {
  sitemap.write({ url });
})

// End the sitemap stream 
sitemap.end()

// Convert the stream to a promise 
const sitemapXmlString = await streamToPromise(sitemap)

// Prompt for the output file path
const outputPath = await path({
  startPath: home("Desktop"), // Suggest saving to the Desktop
  hint: "Select a location to save the sitemap",
})

// Write the sitemap XML to the selected file
writeFile(outputPath, sitemapXmlString);

console.log(`Sitemap generated and saved to ${outputPath}`)
```

## Extract Text from Images in a Directory

```typescript
// Name: Extract Text from Images 
// Description: Extracts text from images in a directory using Tesseract.js
// Author: johnlindquist

import "@johnlindquist/kit"
import Tesseract from "tesseract.js"
import { globby } from "globby"; 

// Prompt for the directory path
const directoryPath = await path({
  hint: "Select a directory containing images:", 
  onlyDirs: true, 
}); 

// Get all image files in the directory
const imageFiles = await globby([
  `${directoryPath}/*.jpg`, 
  `${directoryPath}/*.jpeg`, 
  `${directoryPath}/*.png`, 
], {
  expandDirectories: { 
    extensions: ["jpg", "jpeg", "png"], 
  },
})

// Extract text from each image 
for (const imagePath of imageFiles) {
  // Recognize text from the image
  const { data: { text } } = await Tesseract.recognize(imagePath, "eng");

  // Create a text file with the extracted text
  const outputPath = imagePath.replace(/\.[^/.]+$/, ".txt");
  await writeFile(outputPath, text); 

  console.log(`Text extracted from "${imagePath}" and saved to "${outputPath}".`) 
}
```

##  Check for Updates to a Specific NPM Package

```typescript
// Name: Check for NPM Package Updates
// Description: Checks for available updates for a specific NPM package
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the package name
const packageName = await arg("Enter package name:"); 

// Check if the package is installed locally 
const isInstalledLocally = await execa("npm", ["list", packageName])
  .then(() => true) 
  .catch(() => false)

if (isInstalledLocally) {
  // Display a terminal with the `npm outdated` command for the specific package 
  await term({
    command: `npm outdated ${packageName}`,
    shortcuts: [],
  })
} else {
  await div(md(`# Package "${packageName}" is not installed locally.`))
}
```

##  Add a Task to a Specific Asana Project

```typescript
// Name: Add Task to Asana Project
// Description: Adds a task to a specific Asana project
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the Asana API token from the environment
// https://developers.asana.com/docs/personal-access-token
const asanaToken = await env("ASANA_TOKEN")

// Prompt for the workspace ID
const workspaceId = await arg("Enter Asana workspace ID:");

// Fetch projects for the selected workspace from Asana
const projectsResponse = await get(
  `https://app.asana.com/api/1.0/workspaces/${workspaceId}/projects`, 
  {
    headers: {
      Authorization: `Bearer ${asanaToken}`,
    },
  } 
)

// Prompt for the project ID
const projectId = await arg(
  {
    placeholder: "Select a project:",
  }, 
  projectsResponse.data.data.map(project => ({ 
    name: project.name, 
    value: project.gid,
  }))
);

// Prompt for the task name
const taskName = await arg("Enter task name:")

// Create the task in the selected project
await post(
  `https://app.asana.com/api/1.0/tasks`,
  { 
    data: {
      workspace: workspaceId, 
      projects: [projectId], 
      name: taskName, 
    },
  },
  { 
    headers: {
      Authorization: `Bearer ${asanaToken}`,
    },
  }
); 

console.log(`Task "${taskName}" created successfully in Asana project ${projectId}.`)
```

## Create a New Google Calendar Event from a Template File

```typescript
// Name: Create Google Calendar Event from Template File
// Description: Creates a new Google Calendar event from a template file 
// Author: johnlindquist

import "@johnlindquist/kit"
import { google } from "googleapis"

// Get the Google Calendar API credentials from the environment 
// https://developers.google.com/calendar/api/quickstart/nodejs
const googleCalendarCredentials = JSON.parse(await env("GOOGLE_CALENDAR_CREDENTIALS"));
// Authorize with the Google Calendar API
const auth = new google.auth.GoogleAuth({
  credentials: googleCalendarCredentials, 
  scopes: ["https://www.googleapis.com/auth/calendar"],
});
const calendar = google.calendar({ version: "v3", auth });

// Prompt for the event template file path 
const templateFilePath = await path({
  hint: "Select a event template file", 
});

// Read the event template from the file
const eventTemplate = await readFile(templateFilePath, "utf8"); 

// Prompt the user to fill in the template
let eventDetails = await template(eventTemplate); 

// Parse the event details from the template
let { summary, start, end } = eventDetails
  .split("\n")
  .map(line => line.split(": ")[1])
  .reduce((acc, curr, index) => {
    const keys = ["summary", "start", "end"] 
    acc[keys[index]] = curr 
    return acc
  }, {});

// Create the event object 
const event = {
  summary,
  start: {
    dateTime: start, 
  }, 
  end: {
    dateTime: end,
  }, 
};

// Insert the event into the user's primary calendar
await calendar.events.insert({ 
  calendarId: "primary", 
  requestBody: event,
}) 

console.log(`Event created successfully on your Google Calendar.`)
```

## Check and Update Python Package with Specific Version

```typescript
// Name: Update Python Package to Version
// Description: Checks for and updates a Python package to a specific version
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt for the package name 
const packageName = await arg("Enter Python package name:");

// Prompt for the desired version 
const packageVersion = await arg("Enter the desired version:");

// Check if the package is already installed 
const isInstalled = await isBin(packageName) 

if (isInstalled) {
  // Update the package to the specified version using pip
  await term({
    command: `pip install --upgrade ${packageName}==${packageVersion}`,
    cwd: home(), 
    height: 140,
    enter: "Exit",
    shortcuts: [],
  })

  // Display a success notification 
  await notify({
    title: "Package Updated", 
    message: `Package "${packageName}" updated to version ${packageVersion}.`
  })
} else { 
  // If the package is not installed, display a message 
  await div(md(`# Package "${packageName}" is not installed.`)) 
}
```

## Convert a Series of Images to a Video

```typescript
// Name: Images to Video
// Description: Converts a series of images into a video using FFmpeg 
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt for the directory containing the images 
const directoryPath = await path({ 
  hint: "Select directory containing images:",
  onlyDirs: true,
}); 

// Prompt for the desired output file name for the video
const outputFileName = await arg("Enter output file name for the video:")

// Prompt for the desired frame rate for the video
const frameRate = await arg("Enter frame rate (e.g., 25):");

// Construct the output file path
const outputPath = path.join(directoryPath, `${outputFileName}.mp4`) 

// Execute FFmpeg command to create a video from the images 
await execa("ffmpeg", [ 
  "-framerate",
  frameRate, // Set the frame rate
  "-i",
  `${directoryPath}/image%d.png`, // Pattern to match image files 
  "-c:v", 
  "libx264", // Use libx264 video codec 
  "-pix_fmt",
  "yuv420p", // Set pixel format for compatibility 
  outputPath, 
], {
  stdio: "inherit", // Display FFmpeg output in the terminal
}) 

// Reveal the generated video in Finder
await revealFile(outputPath)
```


## Upload a File to an SFTP Server

```typescript 
// Name: Upload File to SFTP
// Description: Uploads a file to a remote SFTP server 
// Author: johnlindquist

import "@johnlindquist/kit"
import { connect } from "ssh2"

// Prompt for SFTP server details
const host = await arg("Enter SFTP host:")
const username = await arg("Enter SFTP username:")
const password = await arg({ 
  placeholder: "Enter SFTP password:",
  secret: true,
}); 

// Prompt for the local file path
const localFilePath = await path({
  hint: "Select a file to upload",
})

// Prompt for the remote file path 
const remoteFilePath = await arg("Enter remote file path:") 

// Read the file content
const fileContent = await readFile(localFilePath) 

// Connect to the SFTP server 
const sftp = new Promise<any>((resolve, reject) => {
  const connection = new connect() 
  connection.on("ready", () => { 
    connection.sftp((err, sftp) => {
      if (err) {
        reject(err);
      } else {
        resolve(sftp)
      } 
    })
  }).connect({
    host, 
    port: 22, // Default SFTP port 
    username,
    password,
  })
});

// Upload the file using SFTP
(await sftp)
  .fastPut(localFilePath, remoteFilePath)
  .then(() => { 
    console.log(`File "${localFilePath}" uploaded to SFTP server as "${remoteFilePath}".`);
  })
  .catch(error => {
    console.error(`Error uploading file to SFTP server: ${error}`) 
  })
```

## Get a List of Followers on Twitter

```typescript
// Name: List Twitter Followers
// Description: Fetches and displays a list of your followers on Twitter 
// Author: johnlindquist 

import "@johnlindquist/kit"
import Twitter from "twitter-api-v2"; 

// Get the Twitter API keys from the environment 
// https://developer.twitter.com/en/portal/dashboard
const twitterConsumerKey = await env("TWITTER_CONSUMER_KEY");
const twitterConsumerSecret = await env("TWITTER_CONSUMER_SECRET");
const twitterAccessTokenKey = await env("TWITTER_ACCESS_TOKEN_KEY");
const twitterAccessTokenSecret = await env("TWITTER_ACCESS_TOKEN_SECRET"); 

// Initialize the Twitter API client 
const twitterClient = new Twitter({
  appKey: twitterConsumerKey, 
  appSecret: twitterConsumerSecret,
  accessToken: twitterAccessTokenKey, 
  accessSecret: twitterAccessTokenSecret, 
})

// Fetch your followers 
const { data: followers } = await twitterClient.v2.followers("your_user_id"); 

// Create choices for each follower
let followerChoices = followers.map(follower => ({ 
  name: follower.name, 
  description: `@${follower.username}`, 
  value: follower.id,
  img: follower.profile_image_url,
}));

// Prompt for follower selection and copy their ID to clipboard
let followerId = await arg("Your followers:", followerChoices)
await copy(followerId)
```

## Generate a Random Kanye West Quote

```typescript
// Name: Kanye Quote 
// Description: Retrieves and displays a random Kanye West quote 
// Author: johnlindquist

import "@johnlindquist/kit"

// Fetch a random Kanye West quote from the Kanye.rest API
const response = await get("https://api.kanye.rest/") 

// Extract and display the quote 
const { quote } = response.data; 

await div(md(`# ${quote}`));
```

##  Get Information About Your Spotify Account

```typescript
// Name: My Spotify 
// Description: Displays information about your Spotify account
// Author: johnlindquist

import "@johnlindquist/kit"
import SpotifyWebApi from "spotify-web-api-node" 

// Get the Spotify API client ID and secret from the environment
// https://developer.spotify.com/dashboard/applications
const spotifyClientId = await env("SPOTIFY_CLIENT_ID")
const spotifyClientSecret = await env("SPOTIFY_CLIENT_SECRET") 

// Initialize the Spotify API client 
const spotifyApi = new SpotifyWebApi({
  clientId: spotifyClientId,
  clientSecret: spotifyClientSecret,
  redirectUri: "http://localhost:8888/callback", // Replace with your redirect URI
}) 
// Authorize with Spotify API (This may require user interaction)
const authorizeUrl = spotifyApi.createAuthorizeURL( 
  ["user-read-private", "user-read-email"], 
  // Generate a random state parameter
  Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15)
)
await open(authorizeUrl)

// Retrieve the authorization code from the URL (This part may require manual input or setting up a local server to handle the redirect)
const authorizationCode = await arg("Enter authorization code:")

// Get an access token 
spotifyApi.authorizationCodeGrant(authorizationCode).then( 
  (data) => { 
    // Set the access token on the API object to use it in later calls
    spotifyApi.setAccessToken(data.body['access_token']);
    spotifyApi.setRefreshToken(data.body['refresh_token']);
  },
  (err) => {
    console.log('Something went wrong!', err); 
  }
); 

// Get user profile information
const { body: meData } = await spotifyApi.getMe();

// Display user information 
await div(md(`
## Your Spotify Profile:

* Display Name: ${meData.display_name} 
* Email: ${meData.email}
* Country: ${meData.country}
* Followers: ${meData.followers.total} 
* Product: ${meData.product}
`))
```

## Create a New Branch in Git from a Specific Commit

```typescript
// Name: Create Git Branch from Commit
// Description: Creates a new branch from a specific commit
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the commit hash
const commitHash = await arg("Enter commit hash:");

// Prompt for the new branch name
const branchName = await arg("Enter new branch name:")

// Create a new branch from the specified commit 
await $`git checkout -b ${branchName} ${commitHash}` 

console.log(`New branch "${branchName}" created from commit ${commitHash}.`)
```

## Generate a Random Joke and Post it to Twitter

```typescript
// Name: Tweet a Joke
// Description: Generates a random joke and tweets it
// Author: johnlindquist 

import "@johnlindquist/kit" 
import Twitter from "twitter-api-v2"

// Get the Twitter API keys from the environment
// https://developer.twitter.com/en/portal/dashboard
const twitterConsumerKey = await env("TWITTER_CONSUMER_KEY")
const twitterConsumerSecret = await env("TWITTER_CONSUMER_SECRET")
const twitterAccessTokenKey = await env("TWITTER_ACCESS_TOKEN_KEY") 
const twitterAccessTokenSecret = await env("TWITTER_ACCESS_TOKEN_SECRET")

// Initialize the Twitter API client 
const twitterClient = new Twitter({ 
  appKey: twitterConsumerKey, 
  appSecret: twitterConsumerSecret, 
  accessToken: twitterAccessTokenKey, 
  accessSecret: twitterAccessTokenSecret,
}); 

// Fetch a random joke from the JokeAPI 
const response = await get("https://v2.jokeapi.dev/joke/Any?safe-mode") 

// Extract the joke setup and delivery (if applicable) 
const { setup, delivery, joke } = response.data 

// Construct the joke string
const jokeText = setup ? `${setup}\n\n${delivery}` : joke 

// Send the tweet
await twitterClient.v2.tweet(jokeText); 

console.log(`Tweeted a joke: "${jokeText}"`) 
```

## Download a File from a URL and Verify its Checksum

```typescript
// Name: Download File and Verify Checksum
// Description: Downloads a file and verifies its checksum 
// Author: johnlindquist

import "@johnlindquist/kit"
import { createHash } from "crypto"

// Prompt for the file URL and its expected checksum
const fileUrl = await arg("Enter file URL:")
const expectedChecksum = await arg("Enter expected checksum:") 

// Download the file
const fileBuffer = await download(fileUrl) 

// Calculate the SHA-256 checksum of the downloaded file 
const hash = createHash("sha256") 
hash.update(fileBuffer)
const calculatedChecksum = hash.digest("hex") 

// Verify the checksum 
if (calculatedChecksum === expectedChecksum) {
  // If the checksums match, display a success message 
  await div(md(`# Checksum Verified! 

The downloaded file's checksum matches the expected checksum.`)) 
} else {
  // If the checksums don't match, display a warning message
  await div(
    md(`
# Checksum Mismatch! 

The downloaded file's checksum does not match the expected checksum. The file may be corrupted or tampered with.

**Expected Checksum:** ${expectedChecksum}
**Calculated Checksum:** ${calculatedChecksum}
`) 
  )
}
```




## Get a List of Upcoming Events from a Google Calendar

```typescript
// Name: List Upcoming Google Calendar Events
// Description: Lists upcoming events from a selected Google Calendar
// Author: johnlindquist

import "@johnlindquist/kit" 
import { google } from "googleapis"; 

// Get the Google Calendar API credentials from the environment
// https://developers.google.com/calendar/api/quickstart/nodejs
const googleCalendarCredentials = JSON.parse(await env("GOOGLE_CALENDAR_CREDENTIALS")) 
// Authorize with the Google Calendar API
const auth = new google.auth.GoogleAuth({
  credentials: googleCalendarCredentials,
  scopes: ["https://www.googleapis.com/auth/calendar.readonly"], // Use readonly scope 
});
const calendar = google.calendar({ version: "v3", auth })

// Fetch the user's calendar list
const { data: calendarList } = await calendar.calendarList.list();

// Prompt the user to select a calendar from the list
const selectedCalendarId = await arg("Select a calendar:", calendarList.items.map(calendar => ({
  name: calendar.summary,
  value: calendar.id, 
})));

// Get upcoming events for the selected calendar for the next 7 days
const now = new Date();
const nextWeek = new Date()
nextWeek.setDate(now.getDate() + 7)

const res = await calendar.events.list({
  calendarId: selectedCalendarId, 
  timeMin: now.toISOString(),
  timeMax: nextWeek.toISOString(),
  maxResults: 10, // Limit to 10 upcoming events
  singleEvents: true,
  orderBy: "startTime", 
});

const events = res.data.items 

if (events.length) {
  // Create a list of upcoming events to display
  const eventChoices = events.map(event => ({
    name: event.summary, 
    value: event,
    description: `Starts at ${new Date(event.start.dateTime).toLocaleString()}`,
  })) 

  // Prompt the user to select an event 
  const selectedEvent = await arg("Upcoming events:", eventChoices)

  // Display the selected event's details
  await div(
    md(`
# ${selectedEvent.summary}

**Start:** ${new Date(selectedEvent.start.dateTime).toLocaleString()}
**End:** ${new Date(selectedEvent.end.dateTime).toLocaleString()} 
${selectedEvent.description ? `\n\n**Description:** ${selectedEvent.description}` : ""}
${selectedEvent.location ? `\n\n**Location:** ${selectedEvent.location}` : ""}
`) 
  )
} else { 
  // Display a message if no events are found 
  await div(md("# No upcoming events found."))
} 
```

##  Add a Watermark to a PDF File

```typescript
// Name: Add PDF Watermark 
// Description: Adds a watermark to a PDF file using PDFKit
// Author: johnlindquist

import "@johnlindquist/kit" 
import PDFDocument from "pdfkit"

// Prompt for the PDF file path 
const pdfFilePath = await path({ 
  hint: "Select a PDF file to add a watermark to", 
})

// Prompt for the watermark text
const watermarkText = await arg("Enter watermark text:"); 

// Create a new PDF document 
const doc = new PDFDocument()

// Set the output file path for the watermarked PDF 
const outputPath = pdfFilePath.replace(/\.pdf$/i, "-watermarked.pdf"); 

// Pipe the PDF document to a write stream 
const stream = createWriteStream(outputPath);
doc.pipe(stream);

// Load the existing PDF as a buffer
const existingPdfBuffer = await readFile(pdfFilePath); 

// Embed the existing PDF into the new document
doc.addPage().file(existingPdfBuffer, { 
  x: 0,
  y: 0,
  width: doc.page.width, 
  height: doc.page.height,
});

// Add the watermark text to the document
doc.fontSize(30)
  .fillColor("red", 0.5) // Set the font size and color with transparency 
  .text(watermarkText, 50, 50, { 
    align: "center",
    width: doc.page.width - 100, 
  });

// Finalize the PDF document (this will also close the stream)
doc.end(); 

console.log(`Watermarked PDF saved to: ${outputPath}`)
```

##  Get a List of Installed Applications (Windows)

```typescript
// Name: List Installed Apps (Windows)
// Description: Lists all installed applications on your system (Windows only)
// Author: johnlindquist

import "@johnlindquist/kit"

// Execute a command to list installed applications on Windows 
const { stdout: appList } = await exec(
  "Get-ItemProperty HKLM:\\Software\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate | Format-Table -AutoSize" 
)

// Display the application information in the editor 
await editor({
  value: appList,
  language: "text", 
})
```

##  Get a List of Files in a Google Drive Folder

```typescript
// Name: List Google Drive Files 
// Description: Lists files in a specified Google Drive folder
// Author: johnlindquist 

import "@johnlindquist/kit" 
import { google } from "googleapis"

// Get the Google Drive API credentials from the environment
// https://developers.google.com/drive/api/quickstart/nodejs
const googleDriveCredentials = JSON.parse(
  await env("GOOGLE_DRIVE_CREDENTIALS") 
);
// Authorize with the Google Drive API
const auth = new google.auth.GoogleAuth({
  credentials: googleDriveCredentials,
  scopes: ["https://www.googleapis.com/auth/drive.readonly"], 
}) 
const drive = google.drive({ version: "v3", auth });

// Prompt for the folder ID
const folderId = await arg("Enter Google Drive folder ID:");

// List files in the specified folder
const response = await drive.files.list({
  q: `'${folderId}' in parents`, // Query to find files within the specified folder
  pageSize: 1000, // Adjust page size as needed 
  fields: "nextPageToken, files(id, name, mimeType)", 
});

// Extract and display file information
let fileChoices = response.data.files.map(file => ({
  name: file.name, 
  value: file.id,
  description: file.mimeType, 
}))

// Prompt user to choose file and reveal in Finder
let fileId = await arg("Files in folder:", fileChoices);
await revealFile(fileId);
```

## Convert a Video File to a GIF Using FFmpeg

```typescript
// Name: Convert Video to GIF (FFmpeg)
// Description: Converts a video to a GIF using FFmpeg
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt for the input video file path
const videoPath = await path({ 
  hint: "Select a video file to convert",
}) 

// Prompt for the start time (in seconds)
const startTime = parseFloat(await arg("Enter start time (seconds):"))

// Prompt for the duration (in seconds) 
const duration = parseFloat(await arg("Enter duration (seconds):")); 

// Define the output file path for the GIF
const outputPath = videoPath.replace(/\.[^/.]+$/, ".gif"); 

// Execute the FFmpeg command to convert the video to a GIF
await execa(
  "ffmpeg", 
  [
    "-ss", 
    `${startTime}`, // Start time
    "-t", 
    `${duration}`,   // Duration
    "-i", 
    videoPath,
    "-vf", 
    "fps=10,scale=320:-1:flags=lanczos", // Adjust frame rate and size as needed
    "-loop", 
    "0",
    outputPath, 
  ],
  {
    stdio: "inherit", // Display FFmpeg output in the terminal
  } 
); 

// Reveal the generated GIF in Finder 
await revealFile(outputPath); 
```

## Create a New Zoom Meeting with Password

```typescript
// Name: Schedule Zoom Meeting with Password
// Description: Creates a new Zoom meeting with a password and copies the join link 
// Author: johnlindquist 

import "@johnlindquist/kit"
import { Zoom } from "@zoomus/websdk" 

// Get the Zoom API key and secret from the environment 
// https://marketplace.zoom.com/docs/guides/build/jwt-app 
const zoomApiKey = await env("ZOOM_API_KEY");
const zoomApiSecret = await env("ZOOM_API_SECRET");

// Initialize the Zoom client
const zoom = new Zoom({
  apiKey: zoomApiKey,
  apiSecret: zoomApiSecret, 
})

// Prompt for meeting details 
const meetingTopic = await arg("Enter meeting topic:") 
const meetingDuration = parseInt(await arg("Enter meeting duration (minutes):"), 10); 
const meetingPassword = await arg("Enter meeting password:");

// Create the Zoom meeting with a password
const { join_url } = await zoom.meetings.create({
  topic: meetingTopic, 
  type: 1, // Instant meeting
  duration: meetingDuration, 
  password: meetingPassword, // Set the meeting password 
}); 

// Copy the meeting join URL to the clipboard 
await copy(join_url);

// Display confirmation message 
await div(md(`# Zoom Meeting Created 

The join link has been copied to your clipboard:

[${join_url}](${join_url})

Password: ${meetingPassword} 
`))
```

## Get System Information and Save to File

```typescript
// Name: Save System Info
// Description: Retrieves system information and saves it to a file 
// Author: johnlindquist 

import "@johnlindquist/kit"
import os from "os"

// Get system information
const platform = os.platform();
const hostname = os.hostname(); 
const cpu = os.cpus()[0].model;
const memory = os.totalmem(); 
const uptime = os.uptime();

// Format the system information 
const systemInfo = `
Platform: ${platform} 
Hostname: ${hostname}
CPU: ${cpu} 
Memory: ${filesize(memory)}
Uptime: ${formatDistanceToNow(new Date(Date.now() - uptime * 1000), { addSuffix: true })}
`;

// Prompt for the file path to save the system information 
const outputPath = await path({
  startPath: home("Desktop"), // Suggest saving to the Desktop 
  hint: "Select a location to save the system information" 
}) 

// Write the system information to the file
await writeFile(outputPath, systemInfo) 

console.log(`System information saved to: ${outputPath}`) 
```




## Get a List of Files Changed in a Git Pull Request

```typescript
// Name: Get Pull Request Changes
// Description: Lists files changed in a specific GitHub pull request 
// Author: johnlindquist

import "@johnlindquist/kit" 
import { Octokit } from "@octokit/rest"

// Get the GitHub API token from the environment
// https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token
const githubToken = await env("GITHUB_TOKEN")

// Initialize GitHub API client
const octokit = new Octokit({ auth: githubToken })

// Prompt for the repository information
const repoOwner = await arg("Enter repository owner:")
const repoName = await arg("Enter repository name:")
const pullRequestNumber = await arg("Enter pull request number:")

// Fetch the pull request data
const { data: pullRequest } = await octokit.pulls.get({ 
  owner: repoOwner,
  repo: repoName,
  pull_number: parseInt(pullRequestNumber, 10), 
}) 

// Fetch the list of files changed in the pull request
const { data: files } = await octokit.pulls.listFiles({
  owner: repoOwner,
  repo: repoName, 
  pull_number: parseInt(pullRequestNumber, 10), 
}) 

// Create choices from the file names 
const fileChoices = files.map(file => ({ 
  name: file.filename, 
  value: file.filename, 
  // Add a preview to display the file's diff in the editor 
  preview: async () => {
    const { data: fileContent } = await octokit.repos.getContent({ 
      owner: repoOwner,
      repo: repoName, 
      path: file.filename,
      ref: pullRequest.head.sha, // Retrieve content from the pull request's branch
    }) 
    return `\`\`\`diff 
${Base64.decode(fileContent.content)}
\`\`\``
  }
})) 

// Prompt the user to select a file and open its diff in the editor
let selectedFile = await arg("Files changed in this Pull Request:", fileChoices); 
await editor({
  value: fileChoices.find(f => f.value === selectedFile).preview,
  language: "diff", 
}) 
```

## Get Random Advice and Tweet it

```typescript 
// Name: Tweet Random Advice 
// Description: Retrieves a random piece of advice and tweets it 
// Author: johnlindquist 

import "@johnlindquist/kit" 
import Twitter from "twitter-api-v2"

// Get the Twitter API keys from the environment
// https://developer.twitter.com/en/portal/dashboard
const twitterConsumerKey = await env("TWITTER_CONSUMER_KEY")
const twitterConsumerSecret = await env("TWITTER_CONSUMER_SECRET") 
const twitterAccessTokenKey = await env("TWITTER_ACCESS_TOKEN_KEY")
const twitterAccessTokenSecret = await env("TWITTER_ACCESS_TOKEN_SECRET")

// Initialize the Twitter API client 
const twitterClient = new Twitter({
  appKey: twitterConsumerKey, 
  appSecret: twitterConsumerSecret,
  accessToken: twitterAccessTokenKey, 
  accessSecret: twitterAccessTokenSecret,
}) 

// Fetch a random advice slip from the Advice Slip API
const adviceResponse = await get("https://api.adviceslip.com/advice") 

// Extract the advice text
const advice = adviceResponse.data.slip.advice

// Send the tweet 
await twitterClient.v2.tweet(advice)

console.log(`Tweeted: ${advice}`)
```

## Send a File via Bluetooth

```typescript
// Name: Send File via Bluetooth
// Description: Sends a file to a nearby device via Bluetooth (macOS only)
// Author: johnlindquist 

import "@johnlindquist/kit"

// Prompt for the file path 
const filePath = await path({
  hint: "Select a file to send",
});

// Get the target device's Bluetooth address 
const deviceAddress = await arg("Enter Bluetooth device address:") 

// Transfer the file using the `bluetooth-send` command
await term({
  command: `bluetooth-send --address=${deviceAddress} "${filePath}"`,
  cwd: home(),
  height: 140, 
  enter: "Exit",
  shortcuts: [],
})
```

## Get a List of Files in a ZIP Archive

```typescript
// Name: List ZIP Contents
// Description: Lists the contents of a ZIP archive
// Author: johnlindquist

import "@johnlindquist/kit"
import { unzip } from "zlib" 
import { promisify } from "util" 

const unzipAsync = promisify(unzip)

// Prompt for the ZIP file path
const zipFilePath = await path({
  hint: "Select a ZIP file",
});

// Read the ZIP file contents
const zipBuffer = await readFile(zipFilePath)

// Extract the list of files from the ZIP archive
let fileList = ""
try {
  const unzippedData = await unzipAsync(zipBuffer);
  fileList = unzippedData.toString().trim(); 
} catch (error) {
  // Handle any errors during extraction
  console.error("Error extracting ZIP file:", error)
}

// Display the list of files in the editor
await editor({
  value: fileList,
  language: "text",
});
```

##  Get the Latest Commit Message

```typescript
// Name: Get Latest Commit Message
// Description: Displays the message of the latest Git commit
// Author: johnlindquist

import "@johnlindquist/kit" 

// Execute the Git command to retrieve the latest commit message 
const { stdout: commitMessage } = await exec("git log -1 --pretty=%B")

// Display the commit message in a div prompt
await div(md(`# Latest Commit Message:

${commitMessage}`))
```

## Create a New Google Sheets Spreadsheet from Template

```typescript
// Name: Create Google Spreadsheet from Template
// Description: Creates a new Google Spreadsheet from a template file
// Author: johnlindquist

import "@johnlindquist/kit"
import { google } from "googleapis";

// Get the Google Sheets API credentials from the environment
// https://developers.google.com/sheets/api/quickstart/nodejs
const googleSheetsCredentials = JSON.parse(
  await env("GOOGLE_SHEETS_CREDENTIALS") 
)
// Authorize with the Google Sheets API
const auth = new google.auth.GoogleAuth({
  credentials: googleSheetsCredentials,
  scopes: ["https://www.googleapis.com/auth/drive"],
})
const drive = google.drive({ version: "v3", auth });
const sheets = google.sheets({ version: "v4", auth })

// Prompt for the template file path
const templatePath = await path({
  hint: "Select a Google Sheets template file (.xlsx, .xls, or .csv)",
})

// Read the template file content
const templateContent = await readFile(templatePath)

// Upload the template to Google Drive 
const { data: driveFile } = await drive.files.create({
  requestBody: {
    name: `${path.parse(templatePath).name}.xlsx`, // Ensure the file name has the correct extension
    mimeType:
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", // Set the appropriate MIME type
  },
  media: {
    mimeType: "application/octet-stream",
    body: templateContent,
  },
})

// Copy the template file on Google Drive to create a new spreadsheet
const { data: spreadsheet } = await drive.files.copy({
  fileId: driveFile.id, 
  requestBody: {
    name: await arg("Enter new spreadsheet name:"), // Prompt for the new spreadsheet title
    mimeType: "application/vnd.google-apps.spreadsheet" // Set the MIME type for a spreadsheet
  },
});

// Delete the temporary template file on Google Drive 
await drive.files.delete({ fileId: driveFile.id })

// Open the newly created spreadsheet in the browser
await open(spreadsheet.spreadsheetUrl) 

console.log(`Spreadsheet created: ${spreadsheet.spreadsheetUrl}`)
```

## Generate a Random Kanye West Quote and Tweet It

```typescript
// Name: Tweet Kanye Quote
// Description: Fetches a random Kanye West quote and tweets it
// Author: johnlindquist

import "@johnlindquist/kit"
import Twitter from "twitter-api-v2"

// Get the Twitter API keys from the environment
// https://developer.twitter.com/en/portal/dashboard
const twitterConsumerKey = await env("TWITTER_CONSUMER_KEY") 
const twitterConsumerSecret = await env("TWITTER_CONSUMER_SECRET") 
const twitterAccessTokenKey = await env("TWITTER_ACCESS_TOKEN_KEY") 
const twitterAccessTokenSecret = await env("TWITTER_ACCESS_TOKEN_SECRET") 

// Initialize the Twitter API client
const twitterClient = new Twitter({
  appKey: twitterConsumerKey,
  appSecret: twitterConsumerSecret, 
  accessToken: twitterAccessTokenKey, 
  accessSecret: twitterAccessTokenSecret, 
})

// Fetch a random Kanye West quote from the Kanye.rest API
const response = await get("https://api.kanye.rest/");

// Extract the quote
const { quote } = response.data 

// Send the tweet
await twitterClient.v2.tweet(quote)

console.log(`Tweeted: ${quote}`)
```




## Upload a File to AWS S3 with Progress Bar

```typescript
// Name: Upload to S3 with Progress
// Description: Uploads a file to Amazon S3 with a progress bar
// Author: johnlindquist

import "@johnlindquist/kit" 
import AWS from "aws-sdk";
import cliProgress from "cli-progress"

// Get AWS credentials from the environment
// https://docs.aws.amazon.com/sdk-for-javascript/v2/developer-guide/setting-credentials-node.html
const awsAccessKeyId = await env("AWS_ACCESS_KEY_ID")
const awsSecretAccessKey = await env("AWS_SECRET_ACCESS_KEY") 

// Configure AWS SDK 
AWS.config.update({
  accessKeyId: awsAccessKeyId,
  secretAccessKey: awsSecretAccessKey,
  region: "us-east-1", // Replace with your desired AWS region 
})

// Create an instance of Amazon S3
const s3 = new AWS.S3();

// Prompt for the bucket name
const bucketName = await arg("Enter bucket name:");

// Prompt for the file path
const filePath = await path({ 
  hint: "Select a file to upload",
})

// Create a new progress bar
const progressBar = new cliProgress.SingleBar({}, cliProgress.Presets.shades_classic); 

// Read the file contents
const fileContent = await readFile(filePath);

// Upload the file to S3 with progress updates 
s3.upload(
  { 
    Bucket: bucketName,
    Key: path.basename(filePath),
    Body: fileContent,
  }, 
  (err, data) => {
    if (err) {
      console.error("Error uploading file:", err) 
      // Stop the progress bar if there's an error
      progressBar.stop() 
    } else { 
      console.log("File uploaded successfully:", data.Location);
    }
  } 
)
  .on("httpUploadProgress", (progress) => {
    // Update the progress bar 
    progressBar.update(progress.loaded)
  }) 
  .promise() // Convert the request to a promise
  .then(() => {
    // Stop the progress bar after the upload is complete
    progressBar.stop()
  }); 
```

## Get a List of Your Spotify Playlists

```typescript
// Name: List Spotify Playlists 
// Description: Lists your playlists on Spotify
// Author: johnlindquist 

import "@johnlindquist/kit"
import SpotifyWebApi from "spotify-web-api-node"

// Get the Spotify API client ID and secret from the environment 
// https://developer.spotify.com/dashboard/applications
const spotifyClientId = await env("SPOTIFY_CLIENT_ID")
const spotifyClientSecret = await env("SPOTIFY_CLIENT_SECRET") 

// Initialize the Spotify API client
const spotifyApi = new SpotifyWebApi({
  clientId: spotifyClientId,
  clientSecret: spotifyClientSecret,
  redirectUri: "http://localhost:8888/callback", // Replace with your redirect URI 
})
// Authorize with Spotify API (This may require user interaction)
const authorizeUrl = spotifyApi.createAuthorizeURL(
  ["playlist-read-private", "playlist-read-collaborative"], 
  // Generate a random state parameter 
  Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15)
) 
await open(authorizeUrl)

// Retrieve the authorization code from the URL (This part may require manual input or setting up a local server to handle the redirect) 
const authorizationCode = await arg("Enter authorization code:")

// Get an access token
spotifyApi.authorizationCodeGrant(authorizationCode).then(
  (data) => {
    // Set the access token on the API object to use it in later calls
    spotifyApi.setAccessToken(data.body['access_token'])
    spotifyApi.setRefreshToken(data.body['refresh_token']) 
  },
  (err) => {
    console.log("Something went wrong!", err) 
  } 
) 

// Get user's playlists 
const { body: playlistData } = await spotifyApi.getUserPlaylists()

// Display a list of playlists
const playlistChoices = playlistData.items.map(playlist => ({ 
  name: playlist.name,
  description: `By ${playlist.owner.display_name}`, 
  value: playlist,
}))

const selectedPlaylist = await arg("Your playlists:", playlistChoices)

// Display details about the selected playlist 
await div(md(`
# ${selectedPlaylist.name} by ${selectedPlaylist.owner.display_name} 

* Public: ${selectedPlaylist.public ? "Yes" : "No"}
* Collaborative: ${selectedPlaylist.collaborative ? "Yes" : "No"}
* Tracks: ${selectedPlaylist.tracks.total}
* URL: ${selectedPlaylist.external_urls.spotify} 
`))
```

##  Generate a Random Number within a Range

```typescript
// Name: Random Number Generator
// Description: Generates a random number within a specified range
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt for the minimum and maximum values of the range
const minValue = parseInt(await arg("Enter minimum value:"), 10) 
const maxValue = parseInt(await arg("Enter maximum value:"), 10) 

// Generate a random number within the range
const randomNumber = Math.floor(Math.random() * (maxValue - minValue + 1)) + minValue

// Display the generated random number 
await div(md(`# Random Number: ${randomNumber}`)) 
```

## Create and Print a PDF Document

```typescript
// Name: Create and Print PDF 
// Description: Creates a PDF document and prints it 
// Author: johnlindquist

import "@johnlindquist/kit"
import PDFDocument from "pdfkit"

// Create a new PDF document 
const doc = new PDFDocument()

// Add content to the PDF document
doc
  .fontSize(25)
  .text("Hello, world!", 100, 100); 

// Prompt for a file path to save the PDF
const outputPath = await path({
  hint: "Select a location to save the PDF:",
})

// Pipe the PDF document to a write stream 
const stream = fs.createWriteStream(outputPath) 
doc.pipe(stream) 

// Finalize the PDF document (this will also close the stream)
doc.end(); 

// Print the generated PDF file
await exec(`lp "${outputPath}"`) 

console.log(`PDF document created and printed.`);
```

##  Get the Latest Tweet from a User

```typescript
// Name: Get Latest Tweet
// Description: Retrieves and displays the latest tweet from a Twitter user 
// Author: johnlindquist

import "@johnlindquist/kit"
import Twitter from "twitter-api-v2";

// Get the Twitter API keys from the environment
// https://developer.twitter.com/en/portal/dashboard
const twitterConsumerKey = await env("TWITTER_CONSUMER_KEY");
const twitterConsumerSecret = await env("TWITTER_CONSUMER_SECRET");
const twitterAccessTokenKey = await env("TWITTER_ACCESS_TOKEN_KEY");
const twitterAccessTokenSecret = await env("TWITTER_ACCESS_TOKEN_SECRET");

// Initialize the Twitter API client
const twitterClient = new Twitter({
  appKey: twitterConsumerKey, 
  appSecret: twitterConsumerSecret,
  accessToken: twitterAccessTokenKey, 
  accessSecret: twitterAccessTokenSecret,
})

// Prompt for the Twitter username
const username = await arg("Enter Twitter username:");

// Fetch the user's latest tweet 
const { data: userTimeline } = await twitterClient.v2.userTimeline(
  (await twitterClient.v2.userByUsername(username)).data.id, // Get the user's ID from their username
  { 
    max_results: 1, // Limit to only the latest tweet
    "tweet.fields": "created_at", // Include the tweet's creation timestamp
  }
)

// Extract and display the latest tweet
const latestTweet = userTimeline[0] 
const tweetContent = latestTweet.text
const tweetDate = new Date(latestTweet.created_at).toLocaleString()

await div(md(`
# Latest Tweet from @${username}:

${tweetContent} 

*Tweeted on ${tweetDate}*
`))
```

##  Create a New Asana Task from a Template

```typescript 
// Name: Create Asana Task from Template
// Description: Creates a new task in Asana based on a template
// Author: johnlindquist 

import "@johnlindquist/kit"

// Get the Asana API token from the environment 
// https://developers.asana.com/docs/personal-access-token
const asanaToken = await env("ASANA_TOKEN") 

// Prompt for the template task ID
const templateTaskId = await arg("Enter Asana template task ID:");

// Prompt for the project ID where the new task will be created 
const projectId = await arg("Enter Asana project ID:");

// Fetch the details of the template task from Asana
const templateTaskResponse = await get(
  `https://app.asana.com/api/1.0/tasks/${templateTaskId}`,
  { 
    headers: {
      Authorization: `Bearer ${asanaToken}`, 
    },
  }
)

const { data: templateTask } = templateTaskResponse.data;

// Duplicate the template task and assign it to the specified project
await post(
  `https://app.asana.com/api/1.0/tasks/${templateTaskId}/duplicate`,
  {
    data: { 
      name: await arg(
        `Enter task name (original: "${templateTask.name}"):`
      ), // Allow customizing the task name
      projects: [projectId], // Set the target project
    },
  },
  {
    headers: {
      Authorization: `Bearer ${asanaToken}`, 
    }, 
  }
)
  .then((res) => {
    console.log(
      `Task "${templateTask.name}" duplicated and added to project ${projectId}.` 
    )
    console.log(res)
  }) 
  .catch((err) => {
    console.error(`Error duplicating Asana task: ${err}`)
  }) 
```

##  Check and Update Dependencies in a package.json File

```typescript
// Name: Update Dependencies
// Description: Checks for and updates outdated dependencies in a package.json file 
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the project directory path
const directoryPath = await path({ 
  hint: "Select your project directory", 
  onlyDirs: true, 
}) 

// Execute the 'npm outdated' command to check for outdated dependencies
const { stdout: outdatedPackages } = await exec("npm outdated", { cwd: directoryPath }) 

// Check if there are any outdated packages
if (outdatedPackages) {
  // Display a list of outdated packages and prompt the user to update them
  let updatePackages = await arg(
    {
      placeholder: "Outdated packages found. Update?",
      // Display the outdated packages in the panel
      panel: md(outdatedPackages),
    },
    ["yes", "no"]
  ) 

  if (updatePackages === "yes") {
    // Update the packages using npm 
    await term({
      command: "npm update", 
      cwd: directoryPath,
      height: 140,
      enter: "Exit", 
      shortcuts: [],
    }); 
  } 
} else {
  // Display a message if no updates are found
  await div(md(`# All NPM packages are up to date.`))
} 
```

## Create a New Zoom Meeting with a Specific Start Time

```typescript
// Name: Schedule Zoom Meeting (Specific Time)
// Description: Creates a new Zoom meeting with a specific start time
// Author: johnlindquist

import "@johnlindquist/kit" 
import { Zoom } from "@zoomus/websdk"

// Get the Zoom API key and secret from the environment 
// https://marketplace.zoom.com/docs/guides/build/jwt-app
const zoomApiKey = await env("ZOOM_API_KEY") 
const zoomApiSecret = await env("ZOOM_API_SECRET") 

// Initialize the Zoom client
const zoom = new Zoom({
  apiKey: zoomApiKey,
  apiSecret: zoomApiSecret, 
})

// Prompt for meeting details
const meetingTopic = await arg("Enter meeting topic:")
const meetingStartTime = await arg("Enter meeting start time (YYYY-MM-DDTHH:mm:ss):");
const meetingDuration = parseInt(await arg("Enter meeting duration (minutes):"), 10) 

// Create the Zoom meeting with the specified start time 
const { join_url } = await zoom.meetings.create({
  topic: meetingTopic, 
  type: 2, // Scheduled meeting 
  start_time: meetingStartTime,
  duration: meetingDuration,
}); 

// Copy the meeting join URL to the clipboard
await copy(join_url) 

// Display a confirmation message and the meeting join URL 
await div(md(`
# Zoom Meeting Created 

The join link has been copied to your clipboard:

[${join_url}](${join_url}) 
`))
```


## Download YouTube Video

```typescript
// Name: Download YouTube Video 
// Description: Downloads a YouTube video
// Author: johnlindquist

import "@johnlindquist/kit" 
import ytdl from "ytdl-core"

// Prompt for the YouTube video URL
let youtubeUrl = await arg({
  placeholder: "Enter YouTube video URL:",
})

// Get the video info 
const info = await ytdl.getInfo(youtubeUrl)

// Ask the user to pick a video format 
let format = await arg(
  "Select video format:",
  info.formats
    .filter(f => f.hasVideo)
    .map(f => ({ 
      name: `${f.qualityLabel} - ${f.container}`, 
      value: f,
    })) 
)

// Create a readable stream from the selected video format
const videoStream = ytdl.downloadFromInfo(info, {
  format,
})

// Set the output file path 
const outputPath = tmpPath(`${info.videoDetails.title}.${format.container}`); 

// Pipe the video stream to the output file
videoStream.pipe(createWriteStream(outputPath))

// Wait for the download to finish
await new Promise((resolve, reject) => { 
  videoStream.on("finish", resolve)
  videoStream.on("error", reject)
})

console.log(`YouTube video downloaded to: ${outputPath}`)
```

## Get a List of Top Hacker News Stories

```typescript 
// Name: Top Hacker News Stories 
// Description: Displays the top stories from Hacker News
// Author: johnlindquist

import "@johnlindquist/kit"

// Fetch top story IDs from Hacker News API
const topStoryIds = await get("https://hacker-news.firebaseio.com/v0/topstories.json")
  .then(res => res.data)

// Create an array to store the story details
const topStories = []

// Prompt for the number of top stories to fetch
const numberOfStories = parseInt(await arg("Enter the number of stories to fetch:"), 10)

// Fetch details for the specified number of stories
for (let i = 0; i < numberOfStories; i++) {
  const storyId = topStoryIds[i] 
  const story = await get(`https://hacker-news.firebaseio.com/v0/item/${storyId}.json`) 
    .then(res => res.data)
  topStories.push(story)
}

// Create choices from the top stories 
let storyChoices = topStories.map(story => ({ 
  name: story.title,
  value: story.url, 
  description: `${story.score} points by ${story.by}`, 
}))

// Prompt for story selection and open in browser
let storyUrl = await arg("Top Hacker News stories:", storyChoices)
await open(storyUrl)
```

## Create a New Google Calendar Event with a Reminder

```typescript
// Name: Create Google Calendar Event with Reminder
// Description: Creates a new Google Calendar event with a reminder 
// Author: johnlindquist

import "@johnlindquist/kit"
import { google } from "googleapis";

// Get the Google Calendar API credentials from the environment 
// https://developers.google.com/calendar/api/quickstart/nodejs
const googleCalendarCredentials = JSON.parse(
  await env("GOOGLE_CALENDAR_CREDENTIALS")
) 
// Authorize with the Google Calendar API 
const auth = new google.auth.GoogleAuth({
  credentials: googleCalendarCredentials, 
  scopes: ["https://www.googleapis.com/auth/calendar"],
})
const calendar = google.calendar({ version: "v3", auth }) 

// Prompt for event details
const eventSummary = await arg("Enter event summary:") 
const eventStartTime = await arg(
  "Enter event start time (YYYY-MM-DDTHH:mm:ss):"
); 
const eventEndTime = await arg("Enter event end time (YYYY-MM-DDTHH:mm:ss):") 

// Prompt for reminder time (in minutes) before the event
const reminderMinutes = parseInt(await arg("Enter reminder time (minutes):"), 10)

// Create the event object with a reminder 
const event = {
  summary: eventSummary, 
  start: {
    dateTime: eventStartTime, 
  },
  end: {
    dateTime: eventEndTime, 
  },
  reminders: {
    useDefault: false,
    overrides: [ 
      {
        method: "popup",
        minutes: reminderMinutes, 
      },
    ],
  },
};

// Insert the event into the user's primary calendar 
await calendar.events.insert({
  calendarId: "primary",
  requestBody: event,
});

console.log(`Event "${eventSummary}" created successfully on your Google Calendar with a reminder set for ${reminderMinutes} minutes before the event.`) 
```

##  Clean Up Your Downloads Directory

```typescript
// Name: Downloads Cleanup
// Description: Cleans up your Downloads directory
// Author: johnlindquist 

import "@johnlindquist/kit" 

// Prompt for the file types to remove (comma-separated extensions)
const fileTypesToRemoveString = await arg(
  {
    placeholder: "Enter file types to remove (comma-separated extensions, e.g., .zip,.dmg,.tmp):",
  }
);
const fileTypesToRemove = fileTypesToRemoveString
  .split(",")
  .map(type => type.trim()) 

// Iterate through files in the Downloads directory 
for await (const file of await readdir(home("Downloads"))) {
  // Check if the file has one of the specified extensions
  if (fileTypesToRemove.some(type => file.endsWith(type))) {
    // Move the file to the trash
    await trash(path.join(home("Downloads"), file))
    console.log(`Trashed: ${file}`)
  } 
}

console.log(`Downloads directory cleaned up.`) 
```

## Convert a Website to PDF and Email It

```typescript
// Name: Send Webpage as PDF
// Description: Converts a website to PDF and emails it using Nodemailer
// Author: johnlindquist

import "@johnlindquist/kit"
import puppeteer from "puppeteer"
import nodemailer from "nodemailer" 

// Get email credentials from the environment 
// https://nodemailer.com/about/
const emailUser = await env("EMAIL_USER")
const emailPassword = await env("EMAIL_PASSWORD") 

// Create a transporter using your chosen email provider's settings 
const transporter = nodemailer.createTransport({ 
  service: await arg("Enter email provider (e.g., 'gmail'):"),
  auth: { 
    user: emailUser,
    pass: emailPassword,
  }, 
});

// Prompt for the recipient's email address
const recipientEmail = await arg("Enter recipient's email address:")

// Prompt for the website URL 
const websiteUrl = await arg({ 
  placeholder: "Enter website URL:",
}) 

// Launch a headless Chrome instance
const browser = await puppeteer.launch(); 
const page = await browser.newPage(); 

// Go to the specified URL 
await page.goto(websiteUrl, { waitUntil: "networkidle2" })

// Generate the PDF 
const pdfBuffer = await page.pdf({ format: "A4" })

// Close the browser
await browser.close();

// Compose the email with the PDF attachment 
const mailOptions = {
  from: emailUser,
  to: recipientEmail,
  subject: `PDF of ${websiteUrl}`,
  text: "Please find the attached PDF.", 
  attachments: [
    { 
      filename: `${new URL(websiteUrl).hostname}.pdf`, 
      content: pdfBuffer,
    }, 
  ],
};

// Send the email 
await transporter.sendMail(mailOptions) 

console.log(`Email with PDF sent to ${recipientEmail}`)
```

## Check if a Process is Running

```typescript 
// Name: Process Checker 
// Description: Checks if a process with a given name is running
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt for the process name
const processName = await arg("Enter process name:")

// Get the list of running processes 
const processes = await getProcesses()

// Check if a process with the given name is running 
const isRunning = processes.some(
  p => p.name.toLowerCase() === processName.toLowerCase() 
) 

// Display the result 
if (isRunning) {
  await div(md(`# Process "${processName}" is running.`)); 
} else {
  await div(md(`# Process "${processName}" is not running.`))
}
```

##  Generate a Random Password and Save it to Bitwarden

```typescript
// Name: Generate Password and Save to Bitwarden
// Description: Generates a random password and saves it to Bitwarden
// Author: johnlindquist

import "@johnlindquist/kit"
import { generate } from "generate-password"
import opn from "opn"

// Prompt for the website or service name
const website = await arg("Enter website or service name:");

// Prompt for the username
const username = await arg("Enter username:") 

// Generate a random password
const password = generate({
  length: 20, 
  numbers: true, 
  symbols: true,
  uppercase: true,
  lowercase: true, 
  excludeSimilarCharacters: true,
})

// Copy the generated password to the clipboard 
await copy(password);

// Construct the Bitwarden URI 
const bwUrl = `bw://add/login?url=${encodeURIComponent(website)}&username=${encodeURIComponent(username)}&password=${encodeURIComponent(password)}`

// Open the Bitwarden URI to initiate saving the password 
await opn(bwUrl); 

console.log(`Password generated, copied to clipboard, and Bitwarden URI opened.`) 
```




## Create and Publish a npm Package

```typescript
// Name: Publish npm Package
// Description: Publishes a package to the npm registry
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the package directory 
const packageDir = await path({
  hint: "Select the package directory", 
  onlyDirs: true,
}); 

// Run the `npm publish` command in a terminal, allowing the user to interact with the process
await term({
  command: "npm publish", 
  cwd: packageDir,
  shortcuts: [], 
})
```

## Extract ZIP Archive with Password

```typescript
// Name: Extract Password-Protected ZIP
// Description: Extracts a password-protected ZIP archive 
// Author: johnlindquist

import "@johnlindquist/kit" 
import AdmZip from "adm-zip"

// Prompt for the ZIP file path
const zipFilePath = await path({
  hint: "Select a ZIP file",
}) 

// Prompt for the password (hidden input)
const password = await arg({
  placeholder: "Enter password:", 
  secret: true,
});

// Extract the ZIP archive using AdmZip 
try {
  const zip = new AdmZip(zipFilePath)
  zip.extractAllTo(tmpPath(), true, password) // Extract to the temp directory
  await div(md(`# ZIP archive extracted successfully to:\n\n ${tmpPath()}`))
} catch (error) {
  // Handle incorrect password or other errors 
  await div(md(`# Error extracting ZIP archive:\n\n${error.message}`)) 
}
```

##  Send a Message to a Microsoft Teams Channel

```typescript
// Name: Send Teams Message
// Description: Sends a message to a Microsoft Teams channel
// Author: johnlindquist

import "@johnlindquist/kit"
import { Client } from "@microsoft/microsoft-graph-client" 

// Get the Microsoft Graph API token from the environment
// https://docs.microsoft.com/en-us/graph/auth/
const graphToken = await env("GRAPH_TOKEN") 

// Initialize the Microsoft Graph client
const graphClient = Client.init({
  authProvider: (done) => {
    done(null, graphToken)
  },
});

// Prompt for the Team ID 
const teamId = await arg({ placeholder: "Enter Microsoft Teams Team ID:" })

// Prompt for the Channel ID
const channelId = await arg({ placeholder: "Enter Microsoft Teams Channel ID:" })

// Prompt for the message content
const message = await arg("Enter your message:"); 

// Send the message to the Microsoft Teams channel 
await graphClient
  .api(`/teams/${teamId}/channels/${channelId}/messages`) 
  .post({ 
    body: {
      contentType: "text", 
      content: message, 
    }, 
  });

console.log(`Message sent to Teams channel ${channelId}.`); 
```

##  Check and Update Docker Image

```typescript
// Name: Update Docker Image
// Description: Checks for and updates a Docker image 
// Author: johnlindquist 

import "@johnlindquist/kit" 

// Prompt for the image name 
const imageName = await arg("Enter Docker image name (e.g., nginx:latest):"); 

// Pull the latest version of the image using Docker
await term({
  command: `docker pull ${imageName}`, 
  cwd: home(), 
  height: 140,
  enter: "Exit", 
  shortcuts: [],
}); 
```

## Convert a CSV File to Excel

```typescript
// Name: CSV to Excel Converter 
// Description: Converts a CSV file to an Excel spreadsheet
// Author: johnlindquist 

import "@johnlindquist/kit" 
import { utils, writeFile } from "xlsx"

// Prompt for the CSV file path
const csvFilePath = await path({ 
  hint: "Select a CSV file",
});

// Read the CSV file content
const csvContent = await readFile(csvFilePath, "utf-8");

// Convert the CSV data to a worksheet 
const workSheet = utils.aoa_to_sheet(csvContent.split("\n").map(line => line.split(","))) 

// Create a new workbook and add the worksheet
const workBook = utils.book_new() 
utils.book_append_sheet(workBook, workSheet, "Sheet1")

// Generate the Excel file buffer
const excelBuffer = writeFile(workBook, { bookType: "xlsx", type: "buffer" });

// Construct the output file path with .xlsx extension
const outputPath = csvFilePath.replace(/\.[^/.]+$/, ".xlsx");

// Write the Excel file buffer to the output path
await writeFile(outputPath, excelBuffer) 

console.log(`CSV file converted to Excel: ${outputPath}`)
```

##  Get System Battery Health Information (macOS Only)

```typescript
// Name: Battery Health (macOS)
// Description: Displays battery health information for macOS
// Author: johnlindquist

import "@johnlindquist/kit" 

// Execute the `pmset -g batt` command to get battery information and capture the output
const { stdout: batteryInfo } = await exec("pmset -g batt") 

// Parse the battery information string to extract relevant details 
const batteryHealthPercentage = batteryInfo.match(/ - (\d+)%/)[1]; 
const batteryCondition = batteryInfo.match(/(Normal|.*)/)[1];

// Display the battery health information 
await div(
  md(`
  # Battery Health:

  * Condition: ${batteryCondition} 
  * Capacity: ${batteryHealthPercentage}%
  `)
)
```

## Generate a Random Quote and Post it to a Microsoft Teams Channel

```typescript
// Name: Teams Quote Bot
// Description: Sends a random quote to a Microsoft Teams channel 
// Author: johnlindquist

import "@johnlindquist/kit"
import { Client } from "@microsoft/microsoft-graph-client" 

// Get the Microsoft Graph API token from the environment
// https://docs.microsoft.com/en-us/graph/auth/ 
const graphToken = await env("GRAPH_TOKEN");

// Initialize the Microsoft Graph client
const graphClient = Client.init({ 
  authProvider: (done) => {
    done(null, graphToken)
  },
})

// Prompt for the Team ID
const teamId = await arg({ placeholder: "Enter Microsoft Teams Team ID:" })

// Prompt for the Channel ID
const channelId = await arg({ placeholder: "Enter Microsoft Teams Channel ID:" })

// Fetch a random quote from the Quotable API 
const quoteResponse = await get("https://api.quotable.io/random"); 

// Extract the quote content and author
const { content, author } = quoteResponse.data

// Construct the message with the quote 
const message = `> ${content}\n\n- ${author}`; 

// Send the quote to the Microsoft Teams channel 
await graphClient 
  .api(`/teams/${teamId}/channels/${channelId}/messages`)
  .post({
    body: { 
      contentType: "text",
      content: message, 
    },
  }) 

console.log(`Quote sent to Teams channel: "${content}" - ${author}`);
```




## Resize and Add a Watermark to an Image

```typescript
// Name: Resize and Watermark Image
// Description: Resizes an image and adds a watermark using Sharp
// Author: johnlindquist

import "@johnlindquist/kit"
import sharp from "sharp";

// Prompt for the image path
const imagePath = await path({
  hint: "Select an image file",
});

// Prompt for the new width
const newWidth = parseInt(await arg("Enter new width in pixels:"));

// Prompt for the watermark text 
const watermarkText = await arg("Enter watermark text:"); 

// Load the watermark font (replace with your desired font)
const font = await Jimp.loadFont(Jimp.FONT_SANS_32_BLACK);

// Read the image using Sharp
const image = sharp(imagePath) 

// Get image metadata to calculate watermark position 
const { width, height } = await image.metadata(); 

// Create a Jimp image for the watermark
let watermark = new Jimp(width, height, "#00000000"); // Transparent background 
watermark.print(
  font,
  10, // X position
  height - 40, // Y position (adjust as needed)
  watermarkText, 
); 
const watermarkBuffer = await watermark.getBufferAsync(Jimp.MIME_PNG);

// Resize the image and composite the watermark
const resizedImage = await image
  .resize(newWidth)
  .composite([{ input: watermarkBuffer, gravity: "southeast" }]) 
  .toBuffer(); 

// Overwrite the original file with the watermarked image 
await writeFile(imagePath, resizedImage)

console.log(`Image resized and watermarked.`) 
```

## Get a List of Your GitHub Gists

```typescript
// Name: List My Gists
// Description: Displays a list of your GitHub Gists
// Author: johnlindquist

import "@johnlindquist/kit"
import { Octokit } from "@octokit/rest"

// Get the GitHub API token from the environment
// https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token
const githubToken = await env("GITHUB_TOKEN")

// Initialize GitHub API client
const octokit = new Octokit({ auth: githubToken })

// Fetch the list of your Gists
const gists = await octokit.gists.listForAuthenticatedUser()

// Create choices from the Gists
let gistChoices = gists.data.map(gist => ({
  name: Object.keys(gist.files)[0],
  description: gist.description,
  value: gist.html_url, 
}))

// Prompt for Gist selection and open in browser
let gistUrl = await arg("Your Gists:", gistChoices);
await open(gistUrl)
```

##  Generate and Print a QR Code

```typescript 
// Name: Generate and Print QR Code 
// Description: Generates a QR code from input and prints it
// Author: johnlindquist

import "@johnlindquist/kit"
import QRCode from "qrcode"

// Prompt for the input data for the QR code (e.g., URL, text) 
const inputData = await arg({
  placeholder: "Enter data for QR code (URL, text, etc.):", 
}) 

// Generate the QR code and save to a temporary file
const qrCodeImagePath = tmpPath("qrcode.png")
await QRCode.toFile(qrCodeImagePath, inputData, { errorCorrectionLevel: "H" })

// Print the QR code image 
await exec(`lp "${qrCodeImagePath}"`)

console.log(`QR code generated and printed.`) 
```

## Create a New Event in a Specific Google Calendar

```typescript
// Name: Create Google Calendar Event (Specific Calendar)
// Description: Creates a new Google Calendar event in a specific calendar
// Author: johnlindquist 

import "@johnlindquist/kit"
import { google } from "googleapis";

// Get the Google Calendar API credentials from the environment 
// https://developers.google.com/calendar/api/quickstart/nodejs
const googleCalendarCredentials = JSON.parse(
  await env("GOOGLE_CALENDAR_CREDENTIALS")
) 
// Authorize with the Google Calendar API
const auth = new google.auth.GoogleAuth({ 
  credentials: googleCalendarCredentials,
  scopes: ["https://www.googleapis.com/auth/calendar"], 
}) 
const calendar = google.calendar({ version: "v3", auth })

// Fetch the user's calendar list
const { data: calendarList } = await calendar.calendarList.list();

// Prompt the user to select a calendar from the list
const selectedCalendarId = await arg(
  "Select a calendar:", 
  calendarList.items.map(calendar => ({
    name: calendar.summary, 
    value: calendar.id,
  })) 
);

// Prompt for event details
const eventSummary = await arg("Enter event summary:");
const eventStartTime = await arg("Enter event start time (YYYY-MM-DDTHH:mm:ss):");
const eventEndTime = await arg("Enter event end time (YYYY-MM-DDTHH:mm:ss):");

// Create the event object 
const event = {
  summary: eventSummary,
  start: {
    dateTime: eventStartTime, 
  },
  end: { 
    dateTime: eventEndTime, 
  },
}; 

// Insert the event into the selected calendar
await calendar.events.insert({ 
  calendarId: selectedCalendarId, 
  requestBody: event,
});

console.log(`Event "${eventSummary}" created successfully in calendar ${selectedCalendarId}.`) 
```

## Convert Text to Speech and Upload to Dropbox

```typescript
// Name: Text to Speech and Upload to Dropbox
// Description: Converts text to speech and uploads the audio file to Dropbox
// Author: johnlindquist 

import "@johnlindquist/kit" 
import { Configuration, OpenAIApi } from "openai"; 
import { Dropbox } from "dropbox"; 

// Get the OpenAI API key from the environment 
// https://beta.openai.com/account/api-keys
const openaiApiKey = await env("OPENAI_API_KEY"); 

// Get the Dropbox API token from the environment 
// https://www.dropbox.com/developers/apps
const dropboxToken = await env("DROPBOX_TOKEN");

// Initialize OpenAI API 
const openai = new OpenAIApi(new Configuration({ apiKey: openaiApiKey })) 

// Initialize the Dropbox client
const dbx = new Dropbox({ accessToken: dropboxToken })

// Prompt for text input
let inputText = await arg("Enter text to convert to speech:")

// Generate speech audio 
const response = await openai.audio.speech.create({ 
  model: "tts-1",
  voice: "alloy",
  input: inputText,
});

// Save the audio data as an MP3 file 
const audioFilePath = tmpPath("speech.mp3"); 
const audioArrayBuffer = await response.arrayBuffer();
const audioBuffer = Buffer.from(audioArrayBuffer); 
await writeFile(audioFilePath, audioBuffer)

// Upload the audio file to Dropbox
await dbx.filesUpload({
  path: `/speech-${Date.now()}.mp3`, // Set the file path on Dropbox 
  contents: audioBuffer, 
  mode: { ".tag": "overwrite" }, // Overwrite if file exists
}); 

console.log(`Text converted to speech and uploaded to Dropbox.`) 
```

## Send a Message to a Slack Channel with a Button

```typescript
// Name: Send Slack Message with Button 
// Description: Sends a message with a button to a Slack channel
// Author: johnlindquist

import "@johnlindquist/kit" 

// Get the Slack webhook URL from the environment
// https://api.slack.com/messaging/webhooks
const slackWebhookUrl = await env("SLACK_WEBHOOK_URL");

// Prompt for the message content 
const message = await arg("Enter your message:")

// Prompt for the button text 
const buttonText = await arg("Enter button text:") 

// Prompt for the button URL 
const buttonUrl = await arg("Enter button URL:")

// Send the message to Slack with a button attachment 
await post(slackWebhookUrl, {
  blocks: [
    {
      type: "section", 
      text: {
        type: "mrkdwn",
        text: message,
      },
    }, 
    { 
      type: "actions",
      elements: [
        {
          type: "button",
          text: {
            type: "plain_text",
            text: buttonText, 
          }, 
          url: buttonUrl, 
        },
      ], 
    }, 
  ],
});

console.log(`Message with button sent to Slack channel.`) 
```

##  Create a New Asana Task with Subtasks 

```typescript
// Name: Create Asana Task with Subtasks 
// Description: Creates a new task in Asana with subtasks
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the Asana API token from the environment 
// https://developers.asana.com/docs/personal-access-token
const asanaToken = await env("ASANA_TOKEN")

// Prompt for the workspace ID
const workspaceId = await arg("Enter Asana workspace ID:"); 

// Prompt for the project ID
const projectId = await arg("Enter Asana project ID:");

// Prompt for the task name
const taskName = await arg("Enter task name:") 

// Prompt for subtask names (comma-separated) 
const subtaskNamesString = await arg("Enter subtask names (comma-separated):"); 
const subtaskNames = subtaskNamesString.split(",").map(name => name.trim()) 

// Create the main task in Asana 
const { data: taskData } = await post( 
  `https://app.asana.com/api/1.0/tasks`, 
  {
    data: {
      workspace: workspaceId,
      projects: [projectId],
      name: taskName, 
    },
  },
  { 
    headers: {
      Authorization: `Bearer ${asanaToken}`,
    }, 
  }
); 

// Create subtasks for the main task
for (const subtaskName of subtaskNames) {
  await post( 
    `https://app.asana.com/api/1.0/tasks`,
    { 
      data: {
        workspace: workspaceId,
        projects: [projectId],
        name: subtaskName, 
        parent: taskData.gid, // Set the main task as the parent
      }, 
    },
    { 
      headers: { 
        Authorization: `Bearer ${asanaToken}`, 
      },
    }
  ); 
}

console.log(`Task "${taskName}" with subtasks created successfully in Asana.`);
```




## Create a New Google Docs Document from Text Input

```typescript
// Name: Create Google Doc from Text
// Description: Creates a new Google Docs document from text input
// Author: johnlindquist

import "@johnlindquist/kit"
import { google } from "googleapis"

// Get the Google Docs API credentials from the environment
// https://developers.google.com/docs/api/quickstart/nodejs
const googleDocsCredentials = JSON.parse(await env("GOOGLE_DOCS_CREDENTIALS"))
// Authorize with the Google Docs API 
const auth = new google.auth.GoogleAuth({
  credentials: googleDocsCredentials, 
  scopes: ["https://www.googleapis.com/auth/documents"],
}) 
const docs = google.docs({ version: "v1", auth })

// Prompt for the document title 
const documentTitle = await arg("Enter document title:")

// Prompt for the document content using the editor
const documentContent = await editor({ 
  placeholder: "Enter document content:",
})

// Create a new Google Doc with the provided content
const { data: newDoc } = await docs.documents.create({
  requestBody: {
    title: documentTitle,
    body: {
      content: [
        {
          paragraph: {
            elements: [ 
              {
                textRun: {
                  content: documentContent,
                },
              }, 
            ], 
          },
        },
      ], 
    },
  },
});

// Open the newly created document in the browser 
await open(newDoc.documentId); 

console.log(`New Google Doc created: ${newDoc.documentId}`) 
```

## Generate a Shortened URL with a Custom Domain Using Short.io

```typescript 
// Name: Shorten URL with Custom Domain (Short.io)
// Description: Shortens a URL and uses a custom domain with Short.io
// Author: johnlindquist

import "@johnlindquist/kit" 

// Get the Short.io API key from the environment
// https://app.short.io/settings/integrations/api-key
const shortIoApiKey = await env("SHORT_IO_API_KEY") 

// Prompt for the original URL to shorten 
const originalUrl = await arg("Enter URL to shorten:") 

// Prompt for the custom domain to use
const customDomain = await arg("Enter custom domain (e.g., example.com):"); 

// Shorten the URL using the Short.io API with the custom domain
const { data: shortLinkData } = await post(
  "https://api.short.io/links",
  {
    originalURL: originalUrl,
    domain: customDomain,
  },
  {
    headers: {
      Authorization: shortIoApiKey, 
      "Content-Type": "application/json", 
    }, 
  } 
)

// Extract the shortened URL
const shortenedUrl = shortLinkData.shortURL 

// Display the shortened URL 
await div(md(`# Shortened URL:\n\n[${shortenedUrl}](${shortenedUrl})`)) 
```

## Add an Item to a Todoist Project

```typescript
// Name: Add Todoist Task
// Description: Adds a task to a Todoist project 
// Author: johnlindquist

import "@johnlindquist/kit" 

// Get the Todoist API token from the environment
// https://todoist.com/prefs/integrations
const todoistToken = await env("TODOIST_API_TOKEN"); 

// Prompt for the project name
const projectName = await arg("Enter Todoist project name:") 

// Fetch the user's projects from Todoist
const projectsResponse = await get(
  `https://api.todoist.com/rest/v2/projects`,
  {
    headers: {
      Authorization: `Bearer ${todoistToken}`, 
    }, 
  } 
);
const projects = projectsResponse.data;

// Find the project ID based on the entered name
const projectId = projects.find(
  project => project.name.toLowerCase() === projectName.toLowerCase() 
)?.id 

if (!projectId) {
  console.error(`Project "${projectName}" not found.`)
  exit()
}

// Prompt for the task content 
const taskContent = await arg("Enter task content:") 

// Add the task to the specified project in Todoist
await post(
  `https://api.todoist.com/rest/v2/tasks`, 
  {
    content: taskContent,
    project_id: projectId,
  }, 
  {
    headers: {
      Authorization: `Bearer ${todoistToken}`,
      "Content-Type": "application/json", 
    }, 
  }
);

console.log(`Task "${taskContent}" added to Todoist project "${projectName}".`) 
```

## Download a File from a URL and Display its Size

```typescript
// Name: Download File and Show Size
// Description: Downloads a file and displays its size
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt for the file URL
const url = await arg("Enter file URL:") 

// Download the file
const fileBuffer = await download(url) 

// Calculate and display the file size
await div(md(`# Downloaded file size: ${filesize(fileBuffer.length)}`))
```

##  Get the SHA-256 Checksum of a File

```typescript
// Name: Get File Checksum
// Description: Calculates the SHA-256 checksum of a file
// Author: johnlindquist

import "@johnlindquist/kit"
import { createHash } from "crypto"

// Prompt for the file path
const filePath = await path({
  hint: "Select a file",
}) 

// Calculate the SHA-256 hash of the file
const fileBuffer = await readFile(filePath) 
const hash = createHash("sha256")
hash.update(fileBuffer)
const checksum = hash.digest("hex"); 

// Display the checksum
await div(md(`# SHA-256 Checksum:\n\n${checksum}`))
```

## Create a New Asana Task with a Description

```typescript 
// Name: Create Asana Task (with Description)
// Description: Creates a new task in Asana with a description
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the Asana API token from the environment 
// https://developers.asana.com/docs/personal-access-token
const asanaToken = await env("ASANA_TOKEN");

// Prompt for the workspace ID
const workspaceId = await arg("Enter Asana workspace ID:") 

// Prompt for the project ID
const projectId = await arg("Enter Asana project ID:")

// Prompt for the task name
const taskName = await arg("Enter task name:");

// Prompt for the task description using the editor
const taskDescription = await editor({
  placeholder: "Enter task description:",
});

// Create the task in Asana with the description
await post( 
  `https://app.asana.com/api/1.0/tasks`,
  {
    data: { 
      workspace: workspaceId, 
      projects: [projectId],
      name: taskName,
      notes: taskDescription, // Include the description in the "notes" field
    },
  },
  {
    headers: {
      Authorization: `Bearer ${asanaToken}`, 
    },
  } 
); 

console.log(`Task "${taskName}" with description created successfully in Asana.`) 
```

## Extract Text from a PDF File 

```typescript
// Name: Extract PDF Text
// Description: Extracts text from a PDF file using PDF.js-Extract 
// Author: johnlindquist

import "@johnlindquist/kit"
import { PDFExtract } from "pdf.js-extract"; 

// Prompt for the PDF file path 
const pdfFilePath = await path({
  hint: "Select a PDF file",
}) 

// Extract text from the PDF file
const pdfExtract = new PDFExtract(); 
const data = await pdfExtract.extract(pdfFilePath, {});

// Join the extracted text from all pages
const extractedText = data.pages
  .map(page => page.content.map(c => c.str).join(" "))
  .join(" ")

// Display the extracted text in the editor 
await editor(extractedText);
```






## Create a New Asana Task with Assignee

```typescript
// Name: Create Asana Task with Assignee
// Description: Creates a new task in Asana and assigns it to a user
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the Asana API token from the environment
// https://developers.asana.com/docs/personal-access-token
const asanaToken = await env("ASANA_TOKEN");

// Prompt for the workspace ID
const workspaceId = await arg("Enter Asana workspace ID:")

// Prompt for the project ID
const projectId = await arg("Enter Asana project ID:")

// Prompt for the task name
const taskName = await arg("Enter task name:")

// Fetch the list of users in the workspace
const usersResponse = await get(
  `https://app.asana.com/api/1.0/workspaces/${workspaceId}/users`,
  {
    headers: {
      Authorization: `Bearer ${asanaToken}`,
    },
  }
)

// Prompt the user to select an assignee from the list of users 
const assigneeId = await arg(
  "Select an assignee:",
  usersResponse.data.data.map(user => ({
    name: user.name,
    value: user.gid, // Use the user's GID as the value
  }))
)

// Create the task in Asana and assign it to the selected user
await post(
  `https://app.asana.com/api/1.0/tasks`, 
  {
    data: {
      workspace: workspaceId,
      projects: [projectId],
      name: taskName,
      assignee: assigneeId, // Assign the task to the selected user
    },
  },
  {
    headers: {
      Authorization: `Bearer ${asanaToken}`,
    },
  }
); 

console.log(`Task "${taskName}" created and assigned to user ${assigneeId} in Asana.`)
```

##  Convert Text to Speech Using Google Cloud Text-to-Speech and Save to File

```typescript
// Name: Text to Speech (Google Cloud) - Save to File
// Description: Converts text to speech using Google Cloud Text-to-Speech and saves it to a file
// Author: johnlindquist

import "@johnlindquist/kit"
import textToSpeech from "@google-cloud/text-to-speech"; 

// Get the Google Cloud credentials from the environment 
// https://cloud.google.com/docs/authentication/getting-started 
const googleCloudCredentials = JSON.parse(await env("GOOGLE_CLOUD_CREDENTIALS"))

// Creates a client 
const client = new textToSpeech.TextToSpeechClient({
  credentials: googleCloudCredentials, 
})

// Prompt for text input 
const text = await arg("Enter text:");

// Select the voice (replace with your desired voice name and language code)
const voice = {
  languageCode: "en-US",
  name: "en-US-Wavenet-F",
} 

// Select the audio encoding
const audioConfig = {
  audioEncoding: "MP3",
} 

// Construct the request
const request = {
  input: { text: text },
  voice: voice,
  audioConfig: audioConfig, 
};

// Perform the text-to-speech request
const [response] = await client.synthesizeSpeech(request); 

// Write the audio content to a file
const audioFilePath = tmpPath("output.mp3"); 
await writeFile(audioFilePath, response.audioContent, "binary") 

console.log(`Audio content written to file: ${audioFilePath}`); 
```

## Upload a File to an FTP Server with Progress

```typescript
// Name: Upload to FTP with Progress 
// Description: Uploads a file to an FTP server with a progress bar 
// Author: johnlindquist

import "@johnlindquist/kit"
import { Client } from "basic-ftp" 
import cliProgress from "cli-progress" 

// Prompt for FTP server details
const host = await arg("Enter FTP host:") 
const username = await arg("Enter FTP username:")
const password = await arg({
  placeholder: "Enter FTP password:",
  secret: true, 
});

// Prompt for the local file path 
const localFilePath = await path({
  hint: "Select a file to upload",
})

// Prompt for the remote file path
const remoteFilePath = await arg("Enter remote file path:")

// Create a new progress bar 
const progressBar = new cliProgress.SingleBar({}, cliProgress.Presets.shades_classic)

// Initialize the FTP client 
const client = new Client() 

try {
  // Connect to the FTP server 
  await client.access({
    host,
    user: username, 
    password, 
  }) 

  // Start the progress bar
  progressBar.start((await stat(localFilePath)).size, 0)

  // Upload the file using SFTP with progress updates
  await client.uploadFrom(localFilePath, remoteFilePath, {
    onProgress: (transferredBytes) => {
      // Update the progress bar
      progressBar.update(transferredBytes)
    },
  });

  // Stop the progress bar
  progressBar.stop() 

  console.log(`File "${localFilePath}" uploaded to FTP server as "${remoteFilePath}".`);
} catch (error) { 
  // Stop the progress bar in case of an error
  progressBar.stop()
  console.error(`Error uploading file to FTP server: ${error}`) 
} finally { 
  // Close the FTP connection 
  client.close(); 
}
```

## Get a List of Your Draft GitHub Gists

```typescript
// Name: List Draft Gists 
// Description: Displays a list of your draft Gists on GitHub
// Author: johnlindquist

import "@johnlindquist/kit"
import { Octokit } from "@octokit/rest" 

// Get the GitHub API token from the environment
// https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token
const githubToken = await env("GITHUB_TOKEN") 

// Initialize GitHub API client
const octokit = new Octokit({ auth: githubToken })

// Fetch the list of your draft (unpublished) Gists 
const gists = await octokit.gists.listForAuthenticatedUser({ 
  per_page: 100
})

// Create choices from the draft Gists 
let gistChoices = gists.data
  .filter(gist => !gist.public) // Filter for draft (unpublished) Gists
  .map(gist => ({ 
    name: Object.keys(gist.files)[0], 
    description: gist.description,
    value: gist.html_url,
  })) 

// Prompt for Gist selection and open in browser
let gistUrl = await arg("Your Draft Gists:", gistChoices); 
await open(gistUrl) 
```

## Add an Item to a Specific Todoist List 

```typescript
// Name: Add Todoist Task to List
// Description: Adds a task to a specific Todoist list
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the Todoist API token from the environment
// https://todoist.com/prefs/integrations
const todoistToken = await env("TODOIST_API_TOKEN") 

// Prompt for the project ID
const projectId = await arg({
  placeholder: "Enter Todoist project ID:", 
})

// Fetch the user's tasks in the specified project from Todoist
const tasksResponse = await get(
  `https://api.todoist.com/rest/v2/tasks?project_id=${projectId}`,
  {
    headers: {
      Authorization: `Bearer ${todoistToken}`, 
    },
  }
)
const tasks = tasksResponse.data

// Prompt the user to select a task from the project 
const taskId = await arg(
  "Select a task to add a subtask to:", 
  tasks.map(task => ({
    name: task.content,
    value: task.id, 
  }))
)

// Prompt for the subtask content
const subtaskContent = await arg("Enter subtask content:")

// Add the subtask to the selected task in Todoist
await post(
  `https://api.todoist.com/rest/v2/tasks`,
  {
    content: subtaskContent, 
    parent_id: taskId, // Assign the subtask to the selected task 
  },
  {
    headers: {
      Authorization: `Bearer ${todoistToken}`, 
      "Content-Type": "application/json",
    },
  } 
)

console.log(`Subtask "${subtaskContent}" added to task ${taskId} in Todoist.`)
```

## Generate a Random Joke and Post It to a Microsoft Teams Channel

```typescript
// Name: Teams Joke Bot
// Description: Sends a random joke to a Microsoft Teams channel
// Author: johnlindquist

import "@johnlindquist/kit"
import { Client } from "@microsoft/microsoft-graph-client"

// Get the Microsoft Graph API token from the environment
// https://docs.microsoft.com/en-us/graph/auth/
const graphToken = await env("GRAPH_TOKEN"); 

// Initialize the Microsoft Graph client 
const graphClient = Client.init({
  authProvider: (done) => {
    done(null, graphToken) 
  },
}) 

// Prompt for the Team ID
const teamId = await arg({ placeholder: "Enter Microsoft Teams Team ID:" })

// Prompt for the Channel ID
const channelId = await arg({ placeholder: "Enter Microsoft Teams Channel ID:" })

// Fetch a random joke from the JokeAPI
const jokeResponse = await get("https://v2.jokeapi.dev/joke/Any?safe-mode");

// Extract the joke setup and delivery (if applicable) 
const { setup, delivery, joke } = jokeResponse.data

// Construct the joke string 
const jokeText = setup ? `${setup}\n\n${delivery}` : joke 

// Send the joke to the Microsoft Teams channel
await graphClient
  .api(`/teams/${teamId}/channels/${channelId}/messages`) 
  .post({
    body: { 
      contentType: "text", 
      content: jokeText, 
    }, 
  }) 

console.log(`Joke sent to Teams channel: "${jokeText}"`)
```

## Extract Text from a Scanned Image

```typescript
// Name: Extract Text from Scanned Image
// Description: Extracts text from a scanned image using Tesseract.js
// Author: johnlindquist

import "@johnlindquist/kit"
import Tesseract from "tesseract.js"; 

// Prompt for the scanned image file path 
const imagePath = await path({ 
  hint: "Select a scanned image file", 
})

// Extract text from the image, recognizing it as a single uniform block of text
const { data: { text } } = await Tesseract.recognize(imagePath, "eng", {
  // Use the "single_block" engine for better results with scanned documents
  tessedit_pageseg_mode: Tesseract.PSM.SINGLE_BLOCK, 
});

// Display the extracted text in the editor
await editor({
  value: text,
  language: "text",
}) 
```




## Send a Message to a Specific Slack User

```typescript
// Name: Send Slack Direct Message 
// Description: Sends a direct message to a specific Slack user
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the Slack bot token from the environment
// https://api.slack.com/bot-users 
const slackBotToken = await env("SLACK_BOT_TOKEN") 

// Fetch the list of Slack users
const usersResponse = await get("https://slack.com/api/users.list", {
  headers: {
    Authorization: `Bearer ${slackBotToken}`,
  },
}) 
const users = usersResponse.data.members;

// Prompt the user to select a recipient from the list of users 
const selectedUserId = await arg(
  "Select a user to message:",
  users.map(user => ({
    name: user.real_name,
    value: user.id,
  }))
)

// Prompt for the message content
const message = await arg("Enter your message:") 

// Send the direct message to the selected user
await post(
  "https://slack.com/api/chat.postMessage", 
  { 
    channel: selectedUserId,
    text: message, 
  }, 
  {
    headers: {
      Authorization: `Bearer ${slackBotToken}`, 
      "Content-Type": "application/json",
    },
  }
);

console.log(`Direct message sent to ${selectedUserId} on Slack.`)
```

## Generate a Random Password and Store it in a .env File

```typescript
// Name: Generate and Store Password in .env
// Description: Generates a random password and stores it in a .env file
// Author: johnlindquist

import "@johnlindquist/kit" 
import { generate } from "generate-password";

// Prompt for the environment variable name
const envVarName = await arg("Enter environment variable name (e.g., API_KEY):")

// Generate a random password 
const password = generate({
  length: 20, 
  numbers: true, 
  symbols: true, 
  uppercase: true, 
  lowercase: true,
  excludeSimilarCharacters: true,
}); 

// Update the .env file with the new environment variable
await cli("set-env-var", envVarName, password)

// Display a confirmation message
await div(md(`# Password generated and stored in .env as ${envVarName}.`))
```

## Create a ZIP Archive from Selected Files

```typescript
// Name: Create ZIP from Selection 
// Description: Creates a ZIP archive from selected files
// Author: johnlindquist

import "@johnlindquist/kit"
import { create } from "archiver";
import { createWriteStream } from "fs"

// Prompt for the output file path for the ZIP archive 
const outputPath = await path({
  hint: "Select a location to save the ZIP archive", 
});

// Prompt for the files to include in the archive
const filePaths = await arg(
  {
    placeholder: "Select files to add to ZIP",
    multiple: true, 
  },
  async () => { 
    // Get the selected files from Finder
    const selectedFiles = await getSelectedFile()
    // Split file paths
    return selectedFiles ? selectedFiles.split("\n") : []
  }
); 

// Create a ZIP archive 
const output = createWriteStream(outputPath) 
const archive = create("zip", {
  zlib: { level: 9 } // Set the compression level
})

// Pipe the archive data to the output stream 
archive.pipe(output);

// Add the selected files to the archive 
for (const filePath of filePaths) { 
  const fileName = path.basename(filePath)
  archive.file(filePath, { name: fileName })
}

// Finalize the archive (this will also close the output stream)
await archive.finalize(); 

console.log(`ZIP archive created: ${outputPath}`)
```

## Get System Network Usage

```typescript
// Name: Network Usage Monitor
// Description: Monitors and displays real-time network usage 
// Author: johnlindquist 

import "@johnlindquist/kit"
import { networkStats } from "systeminformation"

// Create a widget to display network usage
const networkWidget = await widget(
  ` 
  <div class="flex flex-col gap-2 p-4">
    <div class="p-2 bg-gray-800 rounded">
      <p class="text-gray-400">Download: {{ downloadSpeed }}</p> 
    </div>
    <div class="p-2 bg-gray-800 rounded">
      <p class="text-gray-400">Upload: {{ uploadSpeed }}</p> 
    </div> 
  </div>
  `,
  {
    width: 300,
    height: 100,
    resizable: true,
    state: { 
      downloadSpeed: "...", 
      uploadSpeed: "...",
    },
  }
)

// Update the widget with network stats every second
setInterval(async () => {
  // Get network statistics
  const stats = await networkStats();

  // Calculate download and upload speeds in Mbps 
  const downloadSpeed = (stats[0].rx_sec / 1024 / 1024).toFixed(2) 
  const uploadSpeed = (stats[0].tx_sec / 1024 / 1024).toFixed(2) 

  // Update the widget state with the new speeds
  networkWidget.setState({ downloadSpeed, uploadSpeed }) 
}, 1000)
```

##  Send an SMS Message with AWS SNS

```typescript
// Name: Send SMS (AWS SNS)
// Description: Sends an SMS message using AWS SNS
// Author: johnlindquist 

import "@johnlindquist/kit"
import AWS from "aws-sdk"

// Get AWS credentials from the environment
// https://docs.aws.amazon.com/sdk-for-javascript/v2/developer-guide/setting-credentials-node.html 
const awsAccessKeyId = await env("AWS_ACCESS_KEY_ID")
const awsSecretAccessKey = await env("AWS_SECRET_ACCESS_KEY")

// Configure AWS SDK
AWS.config.update({
  accessKeyId: awsAccessKeyId,
  secretAccessKey: awsSecretAccessKey,
  region: "us-east-1", // Replace with your desired AWS region 
})

// Create an instance of Amazon SNS
const sns = new AWS.SNS()

// Prompt for the phone number 
const phoneNumber = await arg("Enter phone number (with country code):") 

// Prompt for the message
const message = await arg("Enter your message:") 

// Send the SMS message 
sns.publish( 
  { 
    Message: message,
    PhoneNumber: phoneNumber,
  },
  (err, data) => {
    if (err) { 
      console.error("Error sending SMS:", err) 
    } else {
      console.log("SMS sent successfully.", data) 
    }
  } 
)
```

## Create a Pull Request Between Two Branches in a GitHub Repository

```typescript
// Name: Create GitHub Pull Request (Specific Branches) 
// Description: Creates a pull request between two specific branches in a GitHub repository
// Author: johnlindquist

import "@johnlindquist/kit"
import { Octokit } from "@octokit/rest"

// Get the GitHub API token from the environment 
// https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token
const githubToken = await env("GITHUB_TOKEN");

// Initialize GitHub API client
const octokit = new Octokit({ auth: githubToken })

// Prompt for repository information
const repoOwner = await arg("Enter repository owner:"); 
const repoName = await arg("Enter repository name:")

// Prompt for the base branch
const baseBranch = await arg("Enter base branch:");

// Prompt for the head branch 
const headBranch = await arg("Enter head branch:")

// Prompt for the pull request title
const prTitle = await arg("Enter pull request title:");

// Prompt for the pull request body using the editor 
const prBody = await editor({ 
  placeholder: "Enter pull request body:", 
});

// Create the pull request on GitHub 
await octokit.pulls.create({ 
  owner: repoOwner,
  repo: repoName, 
  title: prTitle, 
  head: headBranch, 
  base: baseBranch,
  body: prBody, 
});

console.log(`Pull request "${prTitle}" created successfully from ${headBranch} to ${baseBranch} in ${repoOwner}/${repoName}.`)
```

## Extract Text from a PDF and Translate It

```typescript
// Name: Translate PDF
// Description: Extracts text from a PDF and translates it using Google Translate API 
// Author: johnlindquist 

import "@johnlindquist/kit" 
import { PDFExtract } from "pdf.js-extract" 

// Get the Google Cloud Translation API key from the environment
// https://cloud.google.com/translate/docs/setup 
const googleTranslateApiKey = await env("GOOGLE_TRANSLATE_API_KEY"); 

// Prompt for the PDF file path
const pdfFilePath = await path({
  hint: "Select a PDF file", 
});

// Prompt for the target language code 
const targetLanguage = await arg("Enter target language code (e.g., 'fr' for French):"); 

// Extract text from the PDF file 
const pdfExtract = new PDFExtract(); 
const data = await pdfExtract.extract(pdfFilePath, {});

// Join the extracted text from all pages 
const extractedText = data.pages
  .map((page) => page.content.map((c) => c.str).join(" "))
  .join(" ")

// Translate the extracted text using the Google Translate API
const response = await get( 
  `https://translation.googleapis.com/language/translate/v2?key=${googleTranslateApiKey}`,
  { 
    params: { 
      q: extractedText, 
      target: targetLanguage,
    },
  }
); 

// Extract the translated text
const translatedText = response.data.data.translations[0].translatedText

// Display the translated text in the editor
await editor(translatedText) 
```




## Check and Update Local Python Packages

```typescript
// Name: Update Local Python Packages
// Description: Checks for and updates outdated locally installed Python packages
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt for the project directory path 
const directoryPath = await path({
  hint: "Select your project directory",
  onlyDirs: true, 
})

// Display a terminal with the `pip list --outdated` command 
await term({
  command: "pip list --outdated",
  cwd: directoryPath, // Set the working directory to the project path
  shortcuts: [], 
})

// Prompt the user to update outdated packages
let updatePackages = await arg("Update outdated packages?", ["yes", "no"]); 

if (updatePackages === "yes") {
  // Update outdated packages using pip
  await term({
    command: "pip install --upgrade -r requirements.txt", // Assuming requirements.txt exists 
    cwd: directoryPath,
    height: 140,
    enter: "Exit", 
    shortcuts: [], 
  }) 
}
```

## Create a Time-lapse Video from Images

```typescript
// Name: Create Time-lapse Video 
// Description: Creates a time-lapse video from a series of images using FFmpeg
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt for the directory containing images 
const directoryPath = await path({
  hint: "Select directory containing images:", 
  onlyDirs: true, 
})

// Prompt for the desired output file name for the video 
const outputFileName = await arg("Enter output file name for video:")

// Prompt for the desired frame rate for the video 
const frameRate = await arg("Enter frame rate (e.g., 25):") 

// Construct the output file path
const outputPath = path.join(directoryPath, `${outputFileName}.mp4`) 

// Execute FFmpeg command to create a time-lapse video from the images
await execa(
  "ffmpeg", 
  [
    "-framerate",
    frameRate, // Set the frame rate 
    "-pattern_type", 
    "glob",
    "-i", 
    `${directoryPath}/*.png`, // Pattern to match image files (adjust as needed)
    "-c:v", 
    "libx264", // Use libx264 video codec
    "-pix_fmt", 
    "yuv420p", // Set pixel format for compatibility
    outputPath,
  ],
  { 
    stdio: "inherit", // Display FFmpeg output in the terminal
  }
);

// Reveal the generated video in Finder 
await revealFile(outputPath) 
```

## Get a List of Trending GIFs on GIPHY

```typescript
// Name: Trending GIFs 
// Description: Fetches and displays trending GIFs from GIPHY
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the GIPHY API key from the environment 
// https://developers.giphy.com/dashboard/ 
const giphyApiKey = await env("GIPHY_API_KEY")

// Fetch trending GIFs from the GIPHY API
const response = await get(`https://api.giphy.com/v1/gifs/trending?api_key=${giphyApiKey}&limit=10`);

// Extract GIF data
const { data: gifs } = response.data; 

// Create choices with GIF titles and URLs
const gifChoices = gifs.map(gif => ({
  name: gif.title,
  value: gif.images.original.url,
  preview: `<img src="${gif.images.fixed_height_small.url}" alt="${gif.title}" />`,
}));

// Prompt for selection and copy the GIF URL to the clipboard
let gifUrl = await arg("Trending GIFs:", gifChoices);
await copy(gifUrl)
```

##  Convert an Image to ASCII Art and Copy to Clipboard

```typescript
// Name: Copy Image as ASCII
// Description: Converts an image to ASCII art and copies it to the clipboard
// Author: johnlindquist

import "@johnlindquist/kit"
import Jimp from "jimp" 

// Prompt for the image path
const imagePath = await path({
  hint: "Select an image file",
}) 

// Read the image using Jimp
const image = await Jimp.read(imagePath)

// Convert the image to ASCII art
const asciiArt = await image
  .resize(80, Jimp.AUTO) // Resize for better ASCII art output
  .toString() // Convert to ASCII 

// Copy the ASCII art to the clipboard 
await copy(asciiArt)

console.log(`ASCII art copied to clipboard.`) 
```

##  Upload a File to a Slack Channel

```typescript
// Name: Upload File to Slack 
// Description: Uploads a file to a Slack channel 
// Author: johnlindquist

import "@johnlindquist/kit"
import FormData from "form-data" 

// Get the Slack bot token from the environment 
// https://api.slack.com/methods/files.upload
const slackBotToken = await env("SLACK_BOT_TOKEN"); 

// Prompt for the Slack channel ID 
const channelId = await arg("Enter Slack channel ID:")

// Prompt for the file path
const filePath = await path({ 
  hint: "Select a file to upload",
}) 

// Read the file content
const fileContent = await readFile(filePath);

// Create a FormData instance to upload the file 
const formData = new FormData();
formData.append("file", fileContent, { filename: path.basename(filePath) });
formData.append("channels", channelId);
formData.append("initial_comment", await arg("Enter an optional comment:")); 

// Upload the file to the Slack channel 
await fetch("https://slack.com/api/files.upload", { 
  method: "POST",
  headers: {
    Authorization: `Bearer ${slackBotToken}`, 
  }, 
  body: formData as any, 
});

console.log(`File "${filePath}" uploaded to Slack channel "${channelId}".`);
```

##  Get a List of Your Draft Trello Cards

```typescript
// Name: List Draft Trello Cards 
// Description: Retrieves and displays a list of your draft Trello cards
// Author: johnlindquist 

import "@johnlindquist/kit"

// Get the Trello API key and token from the environment
// https://developer.atlassian.com/cloud/trello/guides/rest-api/authorization/
const trelloApiKey = await env("TRELLO_API_KEY") 
const trelloToken = await env("TRELLO_TOKEN")

// Get the user's ID
const { data: meData } = await get(`https://api.trello.com/1/members/me?key=${trelloApiKey}&token=${trelloToken}`)

// Fetch the user's cards from Trello
const cardsResponse = await get( 
  `https://api.trello.com/1/members/${meData.id}/cards?key=${trelloApiKey}&token=${trelloToken}`
); 
const cards = cardsResponse.data; 

// Filter for cards that are in lists with the name "Drafts" (case-insensitive)
let draftCards = cards.filter(
  card =>
    card.idList &&
    card.board.lists.find(list => list.id === card.idList).name.toLowerCase() === "drafts" 
);

// Create choices for each draft card, including the card name and board
let draftCardChoices = draftCards.map(card => ({
  name: card.name, 
  description: `Board: ${card.board.name}`, 
  value: card.url, // Use the card's URL as the value
}))

// Prompt for card selection and open in browser
let cardUrl = await arg("Your Draft Trello Cards:", draftCardChoices);
await open(cardUrl)
```

##  Create a Time-lapse Video from Images with FFmpeg

```typescript
// Name: Create Time-lapse (FFmpeg)
// Description: Creates a time-lapse video from a series of images using FFmpeg 
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the directory containing the images
const directoryPath = await path({
  hint: "Select directory containing images:",
  onlyDirs: true, 
})

// Prompt for the desired output file name for the video 
const outputFileName = await arg("Enter output file name for video:");

// Prompt for the desired frame rate for the video
const frameRate = await arg("Enter frame rate (e.g., 25):");

// Construct the output file path
const outputPath = path.join(directoryPath, `${outputFileName}.mp4`);

// Execute FFmpeg command to create a time-lapse video from the images
await execa(
  "ffmpeg",
  [ 
    "-framerate", 
    frameRate, // Set the frame rate
    "-pattern_type",
    "glob", 
    "-i",
    `${directoryPath}/*.jpg`, // Pattern to match image files (adjust if needed)
    "-c:v",
    "libx264", // Use libx264 video codec
    "-pix_fmt",
    "yuv420p", // Set pixel format for compatibility 
    outputPath, 
  ],
  { 
    stdio: "inherit", // Display FFmpeg output in the terminal
  }
); 

// Reveal the generated video in Finder 
await revealFile(outputPath) 
```




## Generate and Print a QR Code with Customizable Options

```typescript 
// Name: Generate and Print QR Code (Customizable)
// Description: Generates and prints a QR code with customizable options
// Author: johnlindquist

import "@johnlindquist/kit" 
import QRCode from "qrcode";

// Prompt for the input data for the QR code
const inputData = await arg("Enter data for QR code:")

// Prompt for the error correction level 
const errorCorrectionLevel = await arg("Select error correction level:", ["L", "M", "Q", "H"]);

// Prompt for the width of the QR code image 
const width = parseInt(await arg("Enter QR code width (pixels):"), 10);

// Generate the QR code and save it to a temporary file 
const qrCodeImagePath = tmpPath("qrcode.png")
await QRCode.toFile(qrCodeImagePath, inputData, {
  errorCorrectionLevel, 
  width,
})

// Print the QR code image
await exec(`lp "${qrCodeImagePath}"`) 

console.log(`QR code with options generated and printed.`)
```

## Get System CPU Temperature

```typescript
// Name: CPU Temperature
// Description: Displays the current CPU temperature
// Author: johnlindquist

import "@johnlindquist/kit" 
import si from "systeminformation"

// Get CPU temperature
const temp = await si.cpuTemperature();

// Display the CPU temperature in a div
await div(md(`
# CPU Temperature: 

* Main: ${temp.main}Â°C
`));
```

## Download and Extract a TAR Archive 

```typescript
// Name: Download and Extract TAR 
// Description: Downloads a TAR archive from a URL and extracts it 
// Author: johnlindquist 

import "@johnlindquist/kit" 
import { extract } from "tar"

// Prompt for the URL of the TAR archive
const url = await arg("Enter TAR archive URL:") 

// Set the output directory for the extracted files
const outputDir = tmpPath() 

// Download the TAR archive using the 'download' function 
const tarFilePath = await download(url, tmpPath())

// Extract the TAR archive
await extract({ 
  file: tarFilePath, 
  cwd: outputDir,
});

// Remove the temporary downloaded archive file
await unlink(tarFilePath) 

console.log(`TAR archive downloaded and extracted to: ${outputDir}`);
```

## Add a File to a GitHub Gist

```typescript
// Name: Add File to Gist 
// Description: Adds a file to an existing GitHub Gist
// Author: johnlindquist

import "@johnlindquist/kit"
import { Octokit } from "@octokit/rest"

// Get the GitHub API token from the environment 
// https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token
const githubToken = await env("GITHUB_TOKEN"); 

// Initialize GitHub API client
const octokit = new Octokit({ auth: githubToken })

// Prompt for the Gist ID
const gistId = await arg("Enter Gist ID:");

// Prompt for the new file name 
const fileName = await arg("Enter new file name:");

// Prompt for the file content using the editor
const fileContent = await editor({
  placeholder: "Enter file content:",
}); 

// Add the new file to the Gist
await octokit.gists.update({
  gist_id: gistId,
  files: { 
    [fileName]: {
      content: fileContent, 
    },
  },
});

console.log(`File "${fileName}" added to Gist ${gistId}`)
```

## Send a WhatsApp Message with a Media Attachment

```typescript
// Name: Send WhatsApp Message with Media 
// Description: Sends a WhatsApp message with a media attachment
// Author: johnlindquist

import "@johnlindquist/kit"
import qrcode from "qrcode-terminal" 
import { Client, LocalAuth } from "whatsapp-web.js" 

// Initialize WhatsApp client with local authentication 
const client = new Client({ 
  authStrategy: new LocalAuth(), 
})

// Generate QR code for authentication 
client.on("qr", (qr) => { 
  qrcode.generate(qr, { small: true }) 
}) 

// Log when the client is ready
client.on("ready", () => { 
  console.log("WhatsApp client is ready!")
})

// Initialize the client
client.initialize()

// Prompt for the recipient's phone number
const phoneNumber = await arg( 
  "Enter recipient's phone number (with country code):" 
);

// Prompt for the message content
const message = await arg("Enter your message:") 

// Prompt for the media file path
const mediaPath = await path({
  hint: "Select a media file to attach", 
})

// Send the message with the media attachment 
client.sendMessage(`${phoneNumber}@c.us`, message, {
  media: fs.readFileSync(mediaPath), 
}); 

console.log(`Message with media attachment sent to ${phoneNumber}.`)
```

##  Create and Edit a New Markdown File in VS Code

```typescript
// Name: Create and Edit Markdown Note (VS Code) 
// Description: Creates a new Markdown file and opens it in VS Code
// Author: johnlindquist 

import "@johnlindquist/kit" 

// Prompt for the file name
const fileName = await arg("Enter file name:")

// Create the file with default content 
await writeFile(fileName, `# ${fileName}\n\n`) 

// Open the file in VS Code
await edit(fileName, undefined, undefined, undefined, "markdown") // Specify "markdown" as the language 
```

## Get System Disk Usage Information

```typescript
// Name: Disk Usage
// Description: Displays system disk usage information 
// Author: johnlindquist 

import "@johnlindquist/kit"
import { diskLayout } from "systeminformation"

// Get disk layout information
const disks = await diskLayout();

// Display disk usage information in a table 
const diskInfo = disks.map(disk => `
## Disk: ${disk.name}

* Type: ${disk.type}
* Filesystem: ${disk.filesystem}
* Total Size: ${filesize(disk.size)}
* Used: ${filesize(disk.used)} 
* Free: ${filesize(disk.free)}`).join("\n")

await div(md(diskInfo));
```




## Check for and Install Missing Homebrew Packages

```typescript
// Name: Install Homebrew Packages
// Description: Checks for and installs missing Homebrew packages
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for a comma-separated list of package names
const packageNamesString = await arg(
  "Enter package names (comma-separated):"
) 
const packageNames = packageNamesString.split(",").map(name => name.trim());

// Check if each package is installed and install if missing
for (const packageName of packageNames) {
  // Check if the package is already installed 
  if (await isBin(packageName)) {
    await div(md(`# Package "${packageName}" is already installed.`));
  } else {
    // Install the package using Homebrew 
    await term({
      command: `brew install ${packageName}`, 
      cwd: home(), 
      height: 140, 
      enter: "Exit", 
      shortcuts: [], 
    }) 
  }
}
```

## Extract Text from a PDF and Summarize it with OpenAI

```typescript
// Name: Summarize PDF with OpenAI
// Description: Extracts text from a PDF and summarizes it using OpenAI
// Author: johnlindquist

import "@johnlindquist/kit"
import { PDFExtract } from "pdf.js-extract";

// Get the OpenAI API key from the environment
// https://platform.openai.com/account/api-keys
const openaiApiKey = await env("OPENAI_API_KEY")

// Prompt for PDF file path
const pdfFilePath = await path({
  hint: "Select a PDF file",
})

// Extract text from the PDF file
const pdfExtract = new PDFExtract(); 
const data = await pdfExtract.extract(pdfFilePath, {})

// Join the extracted text from all pages 
const extractedText = data.pages
  .map(page => page.content.map(c => c.str).join(" ")) 
  .join(" ") 

// Prompt for the desired length of the summary
const summaryLength = parseInt(await arg("Enter desired summary length (words):"), 10) 

// Summarize the extracted text using the OpenAI API
const response = await post(
  "https://api.openai.com/v1/completions", 
  {
    model: "text-davinci-003",
    prompt: `Summarize this text in ${summaryLength} words or less:\n\n${extractedText}`, 
    temperature: 0.7, 
    max_tokens: 500, // Adjust the max tokens based on the desired summary length
  }, 
  {
    headers: {
      Authorization: `Bearer ${openaiApiKey}`, 
      "Content-Type": "application/json",
    }, 
  } 
)
const summary = response.data.choices[0].text.trim() 

// Display the summary in the editor 
await editor(summary)
```

## Create a New GitHub Repository with a .gitignore File

```typescript 
// Name: Create GitHub Repo with .gitignore
// Description: Creates a new GitHub repository with a .gitignore file
// Author: johnlindquist

import "@johnlindquist/kit"
import { Octokit } from "@octokit/rest" 

// Get the GitHub API token from the environment 
// https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token
const githubToken = await env("GITHUB_TOKEN"); 

// Initialize GitHub API client 
const octokit = new Octokit({ auth: githubToken });

// Prompt for the repository name
const repoName = await arg("Enter repository name:") 

// Prompt for the repository description
const repoDescription = await arg("Enter repository description:")

// Prompt for the .gitignore template 
const gitignoreTemplate = await arg(
  "Enter .gitignore template (e.g., Node, Python, Go):" 
);

// Fetch the .gitignore template from GitHub's gitignore repository
const gitignoreContent = await get(`https://raw.githubusercontent.com/github/gitignore/main/${gitignoreTemplate}.gitignore`) 
  .then(res => res.data); 

// Create the repository on GitHub with the .gitignore file 
await octokit.repos.createForAuthenticatedUser({ 
  name: repoName,
  description: repoDescription,
  private: false,
  auto_init: true,
}).then(async (response) => {
  // Get the default branch name
  const defaultBranch = response.data.default_branch;

  // Create the .gitignore file on the default branch 
  await octokit.repos.createOrUpdateFileContents({
    owner: response.data.owner.login, 
    repo: repoName,
    path: ".gitignore", 
    message: "Initial commit",
    content: Buffer.from(gitignoreContent).toString("base64"), 
    branch: defaultBranch,
  });
})

console.log(`Public repository ${repoName} created with .gitignore.`);
```

## Convert Speech to Text Using AssemblyAI

```typescript
// Name: Speech to Text (AssemblyAI)
// Description: Converts speech to text using the AssemblyAI API 
// Author: johnlindquist

import "@johnlindquist/kit"
import axios from "axios";

// Get the AssemblyAI API key from the environment
// https://www.assemblyai.com/dashboard
const assemblyAiApiKey = await env("ASSEMBLYAI_API_KEY") 

// Prompt for audio file path 
const audioFilePath = await path({
  hint: "Select an audio file",
});

// Upload the audio file to AssemblyAI
const uploadResponse = await axios.post(
  "https://api.assemblyai.com/v2/upload", 
  await readFile(audioFilePath),
  { 
    headers: {
      authorization: assemblyAiApiKey, 
      "content-type": "application/octet-stream",
    },
  }
)

// Get the audio URL from the upload response 
const audioUrl = uploadResponse.data.upload_url 

// Transcribe the uploaded audio
const transcriptResponse = await post( 
  "https://api.assemblyai.com/v2/transcript", 
  {
    audio_url: audioUrl, 
  }, 
  { 
    headers: {
      authorization: assemblyAiApiKey,
      "content-type": "application/json",
    }, 
  }
);

// Get the transcript ID from the response
const transcriptId = transcriptResponse.data.id;

// Check the transcription status until it's completed 
let transcript = null
while (transcript === null || transcript.status !== "completed") {
  // Fetch the transcript status 
  const transcriptStatusResponse = await get( 
    `https://api.assemblyai.com/v2/transcript/${transcriptId}`, 
    { 
      headers: {
        authorization: assemblyAiApiKey,
      }, 
    } 
  );

  transcript = transcriptStatusResponse.data;

  // Wait for 5 seconds before checking again
  if (transcript.status !== "completed") {
    await wait(5000); 
  } 
}

// Extract the transcribed text from the response 
const transcribedText = transcript.text

// Display the transcribed text in the editor
await editor(transcribedText) 
```

##  Add a Task to a Specific Asana Section

```typescript
// Name: Add Task to Asana Section
// Description: Adds a task to a specific section in an Asana project 
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the Asana API token from the environment 
// https://developers.asana.com/docs/personal-access-token
const asanaToken = await env("ASANA_TOKEN") 

// Prompt for the project ID
const projectId = await arg("Enter Asana project ID:") 

// Fetch the sections of the project from Asana
const sectionsResponse = await get(
  `https://app.asana.com/api/1.0/projects/${projectId}/sections`,
  {
    headers: { 
      Authorization: `Bearer ${asanaToken}`, 
    }, 
  }
);

// Prompt the user to select a section from the list
const sectionId = await arg(
  "Select a section:",
  sectionsResponse.data.data.map(section => ({
    name: section.name, 
    value: section.gid, // Use the section's GID as the value
  }))
); 

// Prompt for the task name
const taskName = await arg("Enter task name:") 

// Create the task in the selected section 
await post(
  `https://app.asana.com/api/1.0/tasks`,
  { 
    data: {
      projects: [projectId],
      name: taskName,
      memberships: [{ section: sectionId }], // Assign the task to the selected section
    },
  },
  {
    headers: {
      Authorization: `Bearer ${asanaToken}`, 
    },
  }
); 

console.log(`Task "${taskName}" created successfully in section ${sectionId} of Asana project ${projectId}.`)
```

## Check for and Update Node.js Version Using NVM

```typescript
// Name: Node Version Manager (NVM) 
// Description: Checks your current Node.js version and allows updating using NVM
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the current Node.js version 
const currentNodeVersion = process.version; 

// Fetch the latest LTS (Long-Term Support) version of Node.js from the NVM repository
const latestLtsVersion = await exec("nvm ls-remote --lts", { encoding: "utf8" })
  .then(res => res.stdout.split("\n").find(line => line.includes("LTS"))?.trim()) 

// Prompt the user to update to the latest LTS version if the current version is not the latest LTS
if (latestLtsVersion && !currentNodeVersion.includes(latestLtsVersion)) {
  const shouldUpdate = await arg(
    `Current Node.js version: ${currentNodeVersion}\nLatest LTS version: ${latestLtsVersion}\nUpdate to latest LTS?`,
    [
      { name: "Yes", value: true }, 
      { name: "No", value: false },
    ] 
  ); 

  if (shouldUpdate) {
    // Display a terminal and execute the update command using NVM
    await term({ 
      command: `nvm install ${latestLtsVersion}`,
      cwd: home(), 
      height: 140,
      enter: "Exit", 
      shortcuts: [],
    });

    // Prompt to use the newly installed version
    const useNewVersion = await arg("Use the newly installed version?", ["yes", "no"]);

    if (useNewVersion === "yes") {
      // Switch to the newly installed Node.js version
      await execa("nvm", ["use", latestLtsVersion], { stdio: "inherit" });
    } 
  } 
} else {
  // If the current version is already the latest LTS, display a message 
  await div(md(`# You are already using the latest LTS version of Node.js (${latestLtsVersion}).`)) 
}
```

##  Download a File from Google Drive and Open it in the Default Application 

```typescript
// Name: Download and Open from Google Drive 
// Description: Downloads a file from your Google Drive and opens it 
// Author: johnlindquist

import "@johnlindquist/kit" 
import { google } from "googleapis";

// Get the Google Drive API credentials from the environment 
// https://developers.google.com/drive/api/quickstart/nodejs
const googleDriveCredentials = JSON.parse(await env("GOOGLE_DRIVE_CREDENTIALS"));
// Authorize with the Google Drive API 
const auth = new google.auth.GoogleAuth({
  credentials: googleDriveCredentials, 
  scopes: ["https://www.googleapis.com/auth/drive.readonly"],
});
const drive = google.drive({ version: "v3", auth });

// Prompt for the file ID
const fileId = await arg("Enter Google Drive file ID:"); 

// Download the file from Google Drive 
const response = await drive.files.get(
  { 
    fileId: fileId,
    alt: "media",
  },
  { responseType: "stream" }
);

// Construct the output file path 
const outputPath = tmpPath(
  response.data.headers["content-disposition"]
    .split("filename=")[1] 
    .replace(/"/g, "")
); 

// Create a write stream to save the downloaded file 
const writer = createWriteStream(outputPath)

// Pipe the response data to the writer 
response.data.pipe(writer) 

// Wait for the download to finish
await new Promise((resolve, reject) => { 
  writer.on("finish", resolve); 
  writer.on("error", reject); 
}); 

// Open the downloaded file in the default application
await open(outputPath) 
```

## Create a New Slack Channel

```typescript
// Name: Create Slack Channel
// Description: Creates a new channel in Slack
// Author: johnlindquist 

import "@johnlindquist/kit"

// Get the Slack bot token from the environment 
// https://api.slack.com/bot-users
const slackBotToken = await env("SLACK_BOT_TOKEN"); 

// Prompt for the channel name
const channelName = await arg("Enter channel name:"); 

// Create a new public Slack channel 
await post(
  "https://slack.com/api/conversations.create", 
  {
    name: channelName, 
    is_private: false, // Set to true to create a private channel
  }, 
  {
    headers: {
      Authorization: `Bearer ${slackBotToken}`,
      "Content-Type": "application/json",
    }, 
  }
);

console.log(`Slack channel "${channelName}" created successfully.`);
```

## Create a Shortcut to a Website in the Applications Folder (macOS)

```typescript
// Name: Create Website Shortcut
// Description: Creates a shortcut to a website in your Applications folder (macOS) 
// Author: johnlindquist 

import "@johnlindquist/kit"

// Prompt for the website URL
const websiteUrl = await arg("Enter website URL:");

// Prompt for the shortcut name 
const shortcutName = await arg("Enter shortcut name:");

// Construct the path for the shortcut file in the Applications folder 
const shortcutPath = path.join(
  "/Applications", 
  `${shortcutName}.app`
) 

// Create the .app directory for the shortcut
await mkdir(shortcutPath)

// Create the AppleScript content for the shortcut
const appleScriptContent = `
do shell script "open '${websiteUrl}'"
`;

// Create the Applescript file within the .app directory 
await writeFile(path.join(shortcutPath, "Contents/Resources/Scripts/main.scpt"), appleScriptContent) 

// Set permissions for the AppleScript file to be executable
await chmod(755, path.join(shortcutPath, "Contents/Resources/Scripts/main.scpt")) 

console.log(`Website shortcut "${shortcutName}" created in Applications folder.`)
```

## Generate a Random Password and Save it to a Text File

```typescript
// Name: Generate and Save Password (Text File)
// Description: Generates a random password and saves it to a text file
// Author: johnlindquist 

import "@johnlindquist/kit"
import { generate } from "generate-password"

// Prompt for the desired password length
const passwordLength = parseInt(await arg("Enter password length:"))

// Generate a random password
const password = generate({
  length: passwordLength,
  numbers: true, 
  symbols: true,
  uppercase: true,
  lowercase: true, 
  excludeSimilarCharacters: true,
}) 

// Set the output file path for the password 
const outputPath = tmpPath(`password-${Date.now()}.txt`) 

// Write the password to the file
await writeFile(outputPath, password); 

console.log(`Password saved to: ${outputPath}`)
```



## Get User's Public IP Address and Display Location on a Map

```typescript
// Name: My IP Location
// Description: Gets your public IP address and displays your location on a map
// Author: johnlindquist

import "@johnlindquist/kit"

// Fetch public IP address from ipify API
const ipResponse = await get("https://api.ipify.org?format=json");
const ipAddress = ipResponse.data.ip

// Fetch location information based on the IP address using IP-API 
const locationResponse = await get(`http://ip-api.com/json/${ipAddress}`);
const { lat, lon, city, regionName, country } = locationResponse.data

// Construct the Google Maps URL with the location coordinates
const mapsUrl = `https://www.google.com/maps/@${lat},${lon},12z`

// Display the IP address and a map of the location in a widget 
await widget(`
<div class="grid grid-cols-1 gap-4 p-4">
  <div class="p-2 bg-gray-800 rounded">
    <h3 class="text-lg font-bold">Your Public IP:</h3>
    <p class="text-gray-400">${ipAddress}</p>
  </div>
  <iframe
    width="100%"
    height="400"
    style="border:0"
    loading="lazy"
    allowfullscreen
    src="${mapsUrl}"
  ></iframe>
</div>
`, {
  width: 600,
  height: 500,
  resizable: true, 
}) 
```

## Create a New Trello Card with a Due Date

```typescript
// Name: Create Trello Card with Due Date
// Description: Creates a new card on a Trello board with a due date
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the Trello API key and token from the environment
// https://developer.atlassian.com/cloud/trello/guides/rest-api/authorization/
const trelloApiKey = await env("TRELLO_API_KEY") 
const trelloToken = await env("TRELLO_TOKEN") 

// Prompt for the board ID 
const boardId = await arg({
  placeholder: "Enter Trello board ID:",
}); 

// Prompt for the list ID
const listId = await arg({ 
  placeholder: "Enter Trello list ID:", 
});

// Prompt for the card name
const cardName = await arg("Enter card name:")

// Prompt for the due date (YYYY-MM-DD) 
const dueDate = await arg("Enter due date (YYYY-MM-DD):");

// Create the card on Trello
await post(
  `https://api.trello.com/1/cards?key=${trelloApiKey}&token=${trelloToken}`,
  {
    idList: listId, 
    name: cardName,
    due: dueDate, // Set the due date for the card
  } 
)

console.log(`Trello card "${cardName}" created with due date ${dueDate}.`)
```

## Convert Text to Speech with Microsoft Azure and Save to File

```typescript 
// Name: Text to Speech (Azure) - Save to File
// Description: Converts text to speech using Microsoft Azure and saves to a file 
// Author: johnlindquist

import "@johnlindquist/kit" 
import sdk from "microsoft-cognitiveservices-speech-sdk"

// Get the Azure Cognitive Services Speech key and region from the environment 
// https://docs.microsoft.com/en-us/azure/cognitive-services/speech-service/get-started 
const azureSpeechKey = await env("AZURE_SPEECH_KEY");
const azureSpeechRegion = await env("AZURE_SPEECH_REGION") 

// Prompt for text input
const inputText = await arg("Enter text:"); 

// Configure speech synthesis
const speechConfig = sdk.SpeechConfig.fromSubscription(
  azureSpeechKey,
  azureSpeechRegion
);
speechConfig.speechSynthesisVoiceName = "en-US-JennyNeural"; // Set the desired voice

// Create an audio config for saving to file 
const audioConfig = sdk.AudioConfig.fromAudioFileOutput(tmpPath("speech.mp3"))

// Create a speech synthesizer 
const synthesizer = new sdk.SpeechSynthesizer(speechConfig, audioConfig)

// Synthesize speech
synthesizer.speakTextAsync(
  inputText,
  result => {
    if (result.reason === sdk.ResultReason.SynthesizingAudioCompleted) {
      console.log(`Speech synthesized and saved to ${tmpPath("speech.mp3")}.`) 
    } else {
      console.error(`Speech synthesis failed: ${result.errorDetails}`) 
    } 

    // Dispose of the synthesizer
    synthesizer.close();
  },
  error => {
    console.error(`Speech synthesis canceled: ${error}`);
    synthesizer.close();
  }
);
```

##  Clean Up Unused Docker Volumes

```typescript
// Name: Docker Volume Cleanup
// Description: Checks for and removes unused Docker volumes
// Author: johnlindquist

import "@johnlindquist/kit"

// Execute the Docker command to list unused volumes
const { stdout: unusedVolumes } = await exec(
  "docker volume ls -qf dangling=true"
)

// Check if there are any unused volumes
if (unusedVolumes.trim().length > 0) { 
  // Display a message and ask for confirmation before removing the volumes
  let removeVolumes = await arg(
    { 
      placeholder: "Unused Docker volumes found. Remove them?", 
    },
    ["yes", "no"]
  )

  if (removeVolumes === "yes") {
    // Remove the unused Docker volumes
    await term({
      command: `docker volume prune -f`, // Force removal of unused volumes
      cwd: home(), 
      height: 140,
      enter: "Exit", 
      shortcuts: [],
    });
  }
} else {
  // Display a message if no unused volumes are found 
  await div(md(`# No unused Docker volumes found.`)) 
}
```

## Send a WhatsApp Message with a Location

```typescript
// Name: Send WhatsApp Location 
// Description: Sends your current location to a WhatsApp contact
// Author: johnlindquist 

import "@johnlindquist/kit"
import qrcode from "qrcode-terminal"
import { Client, LocalAuth } from "whatsapp-web.js"

// Initialize WhatsApp client with local authentication 
const client = new Client({
  authStrategy: new LocalAuth(), 
});

// Generate QR code for authentication
client.on("qr", (qr) => {
  qrcode.generate(qr, { small: true }) 
})

// Log when the client is ready
client.on("ready", () => {
  console.log("WhatsApp client is ready!")
})

// Initialize the client
client.initialize()

// Prompt for the recipient's phone number 
const phoneNumber = await arg(
  "Enter recipient's phone number (with country code):"
) 

// Get the user's current location
const location = await getLocation()

// Send the location to the WhatsApp contact
client.sendMessage(`${phoneNumber}@c.us`, null, { 
  location: {
    latitude: location.latitude,
    longitude: location.longitude,
    // Optionally include address and name 
    // address: location.address,
    // name: "My Location" 
  },
});

console.log(`Location sent to ${phoneNumber}.`)
```

## Create a New Folder and Open It in VS Code

```typescript 
// Name: Create Folder and Open in VS Code 
// Description: Creates a new folder and opens it in VS Code
// Author: johnlindquist 

import "@johnlindquist/kit" 

// Prompt for the new folder name 
const folderName = await arg("Enter new folder name:") 

// Create the new folder
await mkdir(folderName) 

// Open the folder in VS Code
await exec(`code "${folderName}"`)
```

## Create a Time-Lapse Video from Images with Custom Frame Rate and Duration

```typescript
// Name: Create Time-lapse (Custom) 
// Description: Creates a time-lapse video from images with custom frame rate and duration 
// Author: johnlindquist 

import "@johnlindquist/kit"

// Prompt for the directory containing images
const directoryPath = await path({ 
  hint: "Select directory containing images:",
  onlyDirs: true, 
}) 

// Prompt for the desired output file name for the video 
const outputFileName = await arg("Enter output file name for video:")

// Prompt for the desired frame rate for the video
const frameRate = await arg("Enter frame rate (e.g., 25):")

// Prompt for the desired duration of the video (in seconds) 
const duration = await arg("Enter video duration (seconds):")

// Construct the output file path
const outputPath = path.join(directoryPath, `${outputFileName}.mp4`) 

// Execute FFmpeg command to create a time-lapse video with specified duration and frame rate 
await execa(
  "ffmpeg",
  [
    "-framerate", 
    frameRate,
    "-pattern_type",
    "glob", 
    "-i", 
    `${directoryPath}/*.jpg`, // Pattern to match image files (adjust as needed) 
    "-c:v",
    "libx264", // Use libx264 video codec 
    "-pix_fmt",
    "yuv420p", // Set pixel format for compatibility
    "-t",
    duration, // Set the video duration 
    outputPath, 
  ], 
  {
    stdio: "inherit", // Display FFmpeg output in the terminal
  }
)

// Reveal the generated video in Finder 
await revealFile(outputPath) 
```




## Convert Text to Speech Using AWS Polly and Play in a Widget

```typescript
// Name: Text to Speech (AWS Polly) - Widget Playback
// Description: Converts text to speech using AWS Polly and plays it in a widget
// Author: johnlindquist

import "@johnlindquist/kit"
import AWS from "aws-sdk"; 

// Get the AWS credentials from the environment
// https://docs.aws.amazon.com/sdk-for-javascript/v2/developer-guide/setting-credentials-node.html
const awsAccessKeyId = await env("AWS_ACCESS_KEY_ID") 
const awsSecretAccessKey = await env("AWS_SECRET_ACCESS_KEY")

// Configure AWS SDK 
AWS.config.update({ 
  accessKeyId: awsAccessKeyId,
  secretAccessKey: awsSecretAccessKey,
  region: "us-east-1", // Replace with your desired AWS region 
});

// Create an instance of Amazon Polly
const polly = new AWS.Polly();

// Prompt for text input 
const inputText = await arg("Enter text:")

// Define the parameters for text-to-speech conversion
const params = { 
  OutputFormat: "mp3",
  Text: inputText,
  VoiceId: "Joanna", // Replace with your desired voice ID
};

// Convert the text to speech 
polly.synthesizeSpeech(params, async (err, data) => {
  if (err) {
    console.error(err); 
  } else {
    // Save the audio data to a temporary file
    const audioFilePath = tmpPath("speech.mp3"); 
    const audioBuffer = data.AudioStream as Buffer; 
    await writeFile(audioFilePath, audioBuffer);

    // Display the audio in a widget 
    await widget(`
      <div class="flex items-center justify-center h-full">
        <audio controls autoplay>
          <source src="file://${audioFilePath}" type="audio/mpeg"> 
        </audio>
      </div>
    `, {
      width: 400, 
      height: 100,
      resizable: true, 
    });
  }
});
```

## Search and Open a File on Google Drive

```typescript
// Name: Search Google Drive
// Description: Searches for a file on Google Drive and opens it 
// Author: johnlindquist

import "@johnlindquist/kit" 
import { google } from "googleapis";

// Get the Google Drive API credentials from the environment 
// https://developers.google.com/drive/api/quickstart/nodejs
const googleDriveCredentials = JSON.parse(await env("GOOGLE_DRIVE_CREDENTIALS")) 
// Authorize with the Google Drive API
const auth = new google.auth.GoogleAuth({
  credentials: googleDriveCredentials, 
  scopes: ["https://www.googleapis.com/auth/drive.readonly"], 
})
const drive = google.drive({ version: "v3", auth })

// Prompt for the search query
const query = await arg("Enter your search query:")

// Search for files on Google Drive
const { data: searchResults } = await drive.files.list({ 
  q: `name contains '${query}'`, // Search for files containing the query in their name 
  pageSize: 10, // Limit the number of results
  fields: "nextPageToken, files(id, name, webViewLink)",
})

// Check if any search results were found
if (searchResults.files.length > 0) {
  // Create choices for each search result 
  let fileChoices = searchResults.files.map(file => ({ 
    name: file.name,
    value: file.webViewLink,
    description: file.id,
  }))

  // Prompt for file selection and open in browser
  let fileUrl = await arg("Search Results:", fileChoices) 
  await open(fileUrl)
} else {
  // If no search results were found, display a message 
  await div(md(`# No files found matching your query.`))
}
```

## Get a List of Your Recently Played Tracks on Spotify

```typescript
// Name: Recently Played Tracks (Spotify)
// Description: Displays a list of your recently played tracks on Spotify 
// Author: johnlindquist

import "@johnlindquist/kit" 
import SpotifyWebApi from "spotify-web-api-node" 

// Get the Spotify API client ID and secret from the environment 
// https://developer.spotify.com/dashboard/applications
const spotifyClientId = await env("SPOTIFY_CLIENT_ID")
const spotifyClientSecret = await env("SPOTIFY_CLIENT_SECRET") 

// Initialize the Spotify API client
const spotifyApi = new SpotifyWebApi({
  clientId: spotifyClientId, 
  clientSecret: spotifyClientSecret, 
  redirectUri: "http://localhost:8888/callback", // Replace with your redirect URI 
})
// Authorize with Spotify API (This may require user interaction) 
const authorizeUrl = spotifyApi.createAuthorizeURL( 
  ["user-read-recently-played"],
  // Generate a random state parameter
  Math.random().toString(36).substring(2, 15) +
    Math.random().toString(36).substring(2, 15) 
)
await open(authorizeUrl) 

// Retrieve the authorization code from the URL (This part may require manual input or setting up a local server to handle the redirect)
const authorizationCode = await arg("Enter authorization code:") 

// Get an access token 
spotifyApi.authorizationCodeGrant(authorizationCode).then( 
  (data) => {
    // Set the access token on the API object to use it in later calls 
    spotifyApi.setAccessToken(data.body["access_token"])
    spotifyApi.setRefreshToken(data.body["refresh_token"])
  }, 
  (err) => {
    console.log("Something went wrong!", err) 
  }
)

// Get the user's recently played tracks 
const { body: recentTracksData } = await spotifyApi.getMyRecentlyPlayedTracks({ limit: 10 })

// Create an array of choices for the recently played tracks
const recentTrackChoices = recentTracksData.items.map(item => ({
  // Display the track name and artist
  name: `${item.track.name} by ${item.track.artists.map(artist => artist.name).join(", ")}`, 
  // Open the track on Spotify when selected 
  value: item.track.external_urls.spotify,
  // Display the album name
  description: `Album: ${item.track.album.name}`,
})) 

// Prompt the user to select a track to open in Spotify
let trackUrl = await arg(
  {
    placeholder: "Recently Played Tracks:",
  },
  recentTrackChoices
)

// Open the selected track in Spotify
await open(trackUrl)
```

## Download a File with Wget and Display Progress

```typescript
// Name: Download with Wget
// Description: Downloads a file from a URL using Wget and displays progress
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt for the download URL
const url = await arg("Enter URL to download:") 

// Execute the Wget command to download the file with progress
await exec(`wget -O "${tmpPath(path.basename(url))}" -q --show-progress "${url}"`) 

console.log(`File downloaded.`)
```

##  Get a List of Files Changed in a Specific Git Commit

```typescript
// Name: Get Commit Changes
// Description: Lists files changed in a specific Git commit
// Author: johnlindquist

import "@johnlindquist/kit" 

// Prompt for the commit hash
const commitHash = await arg("Enter commit hash:");

// Execute the Git command to retrieve changed files from the specified commit
const { stdout: changedFiles } = await exec(`git diff-tree --no-commit-id --name-only -r ${commitHash}`); 

// Display the list of changed files in the editor
await editor({
  value: changedFiles,
  language: "text", 
});
```

##  Check if a Domain Name is Available 

```typescript
// Name: Domain Availability Checker
// Description: Checks if a domain name is available
// Author: johnlindquist

import "@johnlindquist/kit"

// Prompt for the domain name to check
const domainName = await arg("Enter domain name (e.g., example.com):")

// Function to check domain availability using the WHOIS API
async function isDomainAvailable(domain: string): Promise<boolean> {
  const response = await get(`https://api.whoisxmlapi.com/whoisserver/WhoisService?apiKey=${await env("WHOISXMLAPI_KEY")}&domainName=${domain}&outputFormat=JSON`)
  return response.data.WhoisRecord.domainAvailability === "AVAILABLE"
}

// Check if the domain is available
const isAvailable = await isDomainAvailable(domainName)

// Display the result
if (isAvailable) {
  await div(md(`# Domain "${domainName}" is available!`));
} else {
  await div(md(`# Domain "${domainName}" is not available.`)) 
}
```

## Create a Time-lapse Video from a Series of Images with Custom Options

```typescript
// Name: Create Time-lapse Video (Custom Options)
// Description: Creates a time-lapse video from a series of images using FFmpeg with custom options
// Author: johnlindquist 

import "@johnlindquist/kit" 

// Prompt for the directory containing images
const directoryPath = await path({
  hint: "Select directory containing images:",
  onlyDirs: true,
}); 

// Prompt for the desired output file name for the video
const outputFileName = await arg("Enter output file name for video:")

// Prompt for the desired frame rate for the video
const frameRate = await arg("Enter frame rate (e.g., 25):"); 

// Prompt for the desired output video resolution 
const resolution = await arg(
  "Enter desired resolution (e.g., 1920x1080):"
) 

// Construct the output file path
const outputPath = path.join(directoryPath, `${outputFileName}.mp4`) 

// Execute FFmpeg command to create a time-lapse video with specified resolution and frame rate
await execa(
  "ffmpeg",
  [
    "-framerate",
    frameRate, // Set the frame rate 
    "-pattern_type",
    "glob",
    "-i",
    `${directoryPath}/*.jpg`, // Pattern to match image files (adjust if needed)
    "-s", 
    resolution,   // Set the output video resolution
    "-c:v",
    "libx264",  // Use libx264 video codec
    "-pix_fmt", 
    "yuv420p", // Set pixel format for compatibility
    outputPath, 
  ], 
  {
    stdio: "inherit", // Display FFmpeg output in the terminal 
  } 
) 

// Reveal the generated video in Finder
await revealFile(outputPath)
```






## Create a New GitHub Issue and Assign it to a User

```typescript
// Name: Create and Assign GitHub Issue 
// Description: Creates a new issue on GitHub and assigns it to a user
// Author: johnlindquist

import "@johnlindquist/kit"
import { Octokit } from "@octokit/rest"

// Get the GitHub API token from the environment
// https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token
const githubToken = await env("GITHUB_TOKEN") 

// Initialize GitHub API client 
const octokit = new Octokit({ auth: githubToken });

// Prompt for repository information 
const repoOwner = await arg("Enter repository owner:");
const repoName = await arg("Enter repository name:");

// Prompt for issue details
const issueTitle = await arg("Enter issue title:")
const issueBody = await editor({
  placeholder: "Enter issue body:",
}) 

// Prompt for the assignee's GitHub username
const assignee = await arg("Enter assignee username:") 

// Create the issue on GitHub and assign it to the specified user 
await octokit.issues.create({
  owner: repoOwner,
  repo: repoName,
  title: issueTitle,
  body: issueBody,
  assignees: [assignee], // Assign the issue to the user
});

console.log(`Issue "${issueTitle}" created and assigned to ${assignee} in ${repoOwner}/${repoName}.`);
```

## Check for and Remove Duplicate Files

```typescript 
// Name: Duplicate File Finder
// Description: Finds and removes duplicate files in a directory
// Author: johnlindquist

import "@johnlindquist/kit"
import { hashElement } from "folder-hash"

// Prompt for the directory to search for duplicates 
const directoryPath = await path({
  hint: "Select directory to check for duplicates:", 
  onlyDirs: true, 
})

// Calculate file hashes to identify duplicates 
const { hash: directoryHash } = await hashElement(directoryPath, {
  folders: { exclude: ["*"] }, // Only hash files, not folders 
  files: { include: ["*"] },    // Hash all files 
}) 
const fileHashes = directoryHash.children.map(child => ({
  path: child.path,
  hash: child.hash,
}))

// Group files with the same hash (potential duplicates)
const duplicateFileGroups = fileHashes.reduce((acc, file) => {
  acc[file.hash] = acc[file.hash] || []
  acc[file.hash].push(file.path)
  return acc
}, {}) 

// Display a list of potential duplicates for the user to review
let duplicateFiles = Object.values(duplicateFileGroups).filter(group => group.length > 1) 
let selectedDuplicates: string[] = []

if (duplicateFiles.length > 0) {
  for (const duplicates of duplicateFiles) {
    let keep = await arg(
      {
        placeholder: "Select files to keep (use cmd/ctrl to select multiple)",
        multiple: true,
      },
      duplicates.map(f => ({
        name: path.basename(f),
        value: f,
        description: f,
      }))
    )

    selectedDuplicates.push(...duplicates.filter(d => !keep.includes(d)))
  }

  // Confirm before deleting
  let deleteDuplicates = await arg(
    {
      placeholder: `Delete ${selectedDuplicates.length} Files?`,
      hint: "This is a dangerous operation, make sure you have a backup of your files",
    },
    ["yes", "no"]
  )

  if (deleteDuplicates === "yes") {
    for (const duplicateFile of selectedDuplicates) {
      await trash(duplicateFile) 
      console.log(`Deleted: ${duplicateFile}`); 
    } 
    console.log(`Deleted ${selectedDuplicates.length} duplicate files.`)
  }
} else { 
  await div(md(`# No duplicate files found.`)) 
}
```

## Create a New Google Calendar Event and Invite Attendees

```typescript
// Name: Create Google Calendar Event and Invite
// Description: Creates a new Google Calendar event and sends invitations to attendees
// Author: johnlindquist

import "@johnlindquist/kit"
import { google } from "googleapis"

// Get the Google Calendar API credentials from the environment 
// https://developers.google.com/calendar/api/quickstart/nodejs
const googleCalendarCredentials = JSON.parse(
  await env("GOOGLE_CALENDAR_CREDENTIALS")
)
// Authorize with the Google Calendar API
const auth = new google.auth.GoogleAuth({
  credentials: googleCalendarCredentials,
  scopes: ["https://www.googleapis.com/auth/calendar"], 
})
const calendar = google.calendar({ version: "v3", auth }); 

// Prompt for event details
const eventSummary = await arg("Enter event summary:") 
const eventStartTime = await arg("Enter event start time (YYYY-MM-DDTHH:mm:ss):")
const eventEndTime = await arg("Enter event end time (YYYY-MM-DDTHH:mm:ss):")
const attendeeEmailsString = await arg("Enter attendee email addresses (comma-separated):")
const attendeeEmails = attendeeEmailsString
  .split(",")
  .map(email => ({ email: email.trim() })) 

// Create the event object with attendees
const event = { 
  summary: eventSummary,
  start: { 
    dateTime: eventStartTime, 
  }, 
  end: { 
    dateTime: eventEndTime,
  }, 
  attendees: attendeeEmails,
}

// Insert the event into the user's primary calendar
calendar.events.insert(
  { 
    calendarId: "primary",
    requestBody: event,
  },
  (err, event) => { 
    if (err) {
      console.log("There was an error contacting the Calendar service: " + err);
      return
    }
    // Display the event's details and a link to join 
    div(
      md(`
# Event Created: ${event.data.summary} 

**Start:** ${new Date(
        event.data.start.dateTime
      ).toLocaleString()}
**End:** ${new Date(event.data.end.dateTime).toLocaleString()}
**Attendees:** ${event.data.attendees.map(attendee => attendee.email).join(", ")}
[Join Event](${event.data.htmlLink})
      `)
    )
  }
);
```

## Generate a Color Palette from an Image and Display It

```typescript
// Name: Image Color Palette
// Description: Generates and displays a color palette from an image
// Author: johnlindquist 

import "@johnlindquist/kit" 
import Vibrant from "node-vibrant"

// Prompt for the image path
const imagePath = await path({
  hint: "Select an image file", 
}) 

// Generate a color palette using Vibrant.js 
const palette = await Vibrant.from(imagePath).getPalette()

// Extract and display the prominent colors with their hex codes
await div(md(`
# Color Palette:

* Vibrant: ${palette.Vibrant?.hex}
* Muted: ${palette.Muted?.hex} 
* Dark Vibrant: ${palette.DarkVibrant?.hex} 
* Light Vibrant: ${palette.LightVibrant?.hex} 
* Dark Muted: ${palette.DarkMuted?.hex} 
* Light Muted: ${palette.LightMuted?.hex}
`))
```

## Create a New Asana Task with a Due Date and Time

```typescript
// Name: Create Asana Task with Due Date and Time
// Description: Creates a new task in Asana with a specific due date and time 
// Author: johnlindquist

import "@johnlindquist/kit"

// Get the Asana API token from the environment
// https://developers.asana.com/docs/personal-access-token
const asanaToken = await env("ASANA_TOKEN") 

// Prompt for the workspace ID 
const workspaceId = await arg("Enter Asana workspace ID:") 

// Prompt for the project ID
const projectId = await arg("Enter Asana project ID:")

// Prompt for the task name 
const taskName = await arg("Enter task name:")

// Prompt for the due date and time (YYYY-MM-DDTHH:mm:ss)
const dueDateTime = await arg("Enter due date and time (YYYY-MM-DDTHH:mm:ss):") 

// Create the task in Asana 
await post(
  `https://app.asana.com/api/1.0/tasks`,
  {
    data: { 
      workspace: workspaceId,
      projects: [projectId],
      name: taskName, 
      due_at: dueDateTime, // Set the due date and time for the task
    },
  },
  {
    headers: { 
      Authorization: `Bearer ${asanaToken}`, 
    }, 
  }
)

console.log(`Task "${taskName}" with due date and time ${dueDateTime} created successfully in Asana.`)
```

## Generate a Random Chuck Norris Joke and Send it to a Telegram Chat

```typescript
// Name: Telegram Chuck Norris Joke Bot
// Description: Fetches a random Chuck Norris joke and sends it to a Telegram chat
// Author: johnlindquist 

import "@johnlindquist/kit"

// Get the Telegram bot token from the environment 
// https://core.telegram.org/bots#6-botfather
const telegramBotToken = await env("TELEGRAM_BOT_TOKEN")

// Prompt for the chat ID 
const chatId = await arg("Enter Telegram chat ID:") 

// Fetch a random Chuck Norris joke from the ICNDb API
const response = await get("https://api.chucknorris.io/jokes/random");

// Extract the joke 
const { value: joke } = response.data 

// Send the joke to the Telegram chat
await get(`https://api.telegram.org/bot${telegramBotToken}/sendMessage`, { 
  params: {
    chat_id: chatId, 
    text: joke, 
  },
}); 

console.log(`Chuck Norris joke sent to Telegram chat ${chatId}.`);
```

##  Create a New File and Append Text to It

```typescript
// Name: Create and Append to File
// Description: Creates a new file and appends text to it 
// Author: johnlindquist 

import "@johnlindquist/kit"

// Prompt for the file name 
const fileName = await arg("Enter file name:")

// Prompt for the text to append to the file
const textToAppend = await arg("Enter text to append:");

// Create the file if it doesn't exist and append the text
await appendFile(fileName, textToAppend) 

console.log(`Text appended to "${fileName}".`)
```

##  Get a List of Available Wi-Fi Networks

```typescript
// Name: Wi-Fi Scanner 
// Description: Scans for available Wi-Fi networks
// Author: johnlindquist 

import "@johnlindquist/kit"

// Execute the `airport -s` command to scan for Wi-Fi networks (macOS only)
let wifiList = "" 
if (isMac) {
  const { stdout } = await exec("airport -s");
  wifiList = stdout
} else {
  // For other operating systems, you'll need to implement alternative logic to scan for Wi-Fi networks
  // ... 
}

// Display the list of available Wi-Fi networks in the editor
await editor({
  value: wifiList, 
  language: "text", 
})
```

## Generate a Random Password and Save to a File with a Timestamp

```typescript
// Name: Generate and Save Password (Timestamped)
// Description: Generates a random password and saves it to a file with a timestamp 
// Author: johnlindquist

import "@johnlindquist/kit"
import { generate } from "generate-password"; 

// Generate a random password
const password = generate({
  length: 20, 
  numbers: true,
  symbols: true, 
  uppercase: true,
  lowercase: true,
  excludeSimilarCharacters: true,
}) 

// Generate a timestamp for the filename 
const timestamp = formatDate(new Date(), "yyyyMMddHHmmss")

// Construct the output file path with the timestamp
const outputPath = tmpPath(`password-${timestamp}.txt`)

// Write the password to the file
await writeFile(outputPath, password); 

console.log(`Password saved to: ${outputPath}`)
```


## Send a Direct Message to a Slack User with a File Attachment 

```typescript
// Name: Send Slack Direct Message with File
// Description: Sends a direct message with a file attachment to a Slack user
// Author: johnlindquist

import "@johnlindquist/kit"
import FormData from "form-data";

// Get the Slack bot token from the environment 
// https://api.slack.com/methods/files.upload
const slackBotToken = await env("SLACK_BOT_TOKEN")

// Fetch the list of Slack users
const usersResponse = await get("https://slack.com/api/users.list", { 
  headers: {
    Authorization: `Bearer ${slackBotToken}`, 
  },
});
const users = usersResponse.data.members; 

// Prompt the user to select a recipient from the list of users
const selectedUserId = await arg( 
  "Select a user to message:",
  users.map(user => ({
    name: user.real_name, 
    value: user.id, 
  }))
);

// Prompt for the file path
const filePath = await path({ 
  hint: "Select a file to attach", 
})

// Prompt for the message content 
const message = await arg("Enter your message:")

// Read the file content
const fileContent = await readFile(filePath); 

// Create a FormData instance to upload the file 
const formData = new FormData();
formData.append("file", fileContent, { filename: path.basename(filePath) }); 
formData.append("channels", selectedUserId) 
formData.append("initial_comment", message); 

// Upload the file and send the message to the Slack user 
await fetch("https://slack.com/api/files.upload", { 
  method: "POST",
  headers: {
    Authorization: `Bearer ${slackBotToken}`,
  },
  body: formData as any,
}); 

console.log(`Direct message with attachment "${filePath}" sent to ${selectedUserId} on Slack.`);
```

## Upload a File to an SFTP Server with a Custom Port

```typescript 
// Name: Upload to SFTP (Custom Port)
// Description: Uploads a file to a remote SFTP server with a custom port 
// Author: johnlindquist

import "@johnlindquist/kit"
import { connect } from "ssh2";

// Prompt for SFTP server details 
const host = await arg("Enter SFTP host:"); 
const username = await arg("Enter SFTP username:")
const password = await arg({ 
  placeholder: "Enter SFTP password:",
  secret: true,
})
const port = parseInt(await arg("Enter SFTP port:"), 10) // Prompt for the port number 

// Prompt for the local file path 
const localFilePath = await path({
  hint: "Select a file to upload",
})

// Prompt for the remote file path 
const remoteFilePath = await arg("Enter remote file path:"); 

// Read the file content 
const fileContent = await readFile(localFilePath);

// Connect to the SFTP server using the specified port 
const sftp = new Promise<any>((resolve, reject) => { 
  const connection = new connect();
  connection.on("ready", () => {
    connection.sftp((err, sftp) => {
      if (err) { 
        reject(err); 
      } else {
        resolve(sftp); 
      }
    }); 
  }).connect({ 
    host,
    port, // Use the custom port number
    username,
    password, 
  }) 
}) 

// Upload the file using SFTP
(await sftp) 
  .fastPut(localFilePath, remoteFilePath) 
  .then(() => {
    console.log(`File "${localFilePath}" uploaded to SFTP server as "${remoteFilePath}".`);
  })
  .catch(error => {
    console.error(`Error uploading file to SFTP server: ${error}`)
  })
```

## Search for a File by Name and Open it 

```typescript
// Name: File Search and Open 
// Description: Searches for a file by name and opens it
// Author: johnlindquist 

import "@johnlindquist/kit" 

// Prompt for the file name to search for
const fileName = await arg("Enter file name:"); 

// Search for the file using the `find` command 
const filePath = await find(fileName, { onlyin: home() }); // Search within the home directory 

// Check if the file was found 
if (filePath) {
  // Open the file in the default application 
  await open(filePath) 
} else {
  // Display a message if the file was not found 
  await div(md(`# File "${fileName}" not found.`))
} 
```

## Create a New Trello Card with a Checklist from a Template

```typescript 
// Name: Create Trello Card with Checklist from Template
// Description: Creates a new card on a Trello board with a checklist from a template card
// Author: johnlindquist 

import "@johnlindquist/kit"

// Get the Trello API key and token from the environment
// https://developer.atlassian.com/cloud/trello/guides/rest-api/authorization/ 
const trelloApiKey = await env("TRELLO_API_KEY") 
const trelloToken = await env("TRELLO_TOKEN")

// Prompt for the template card ID
const templateCardId = await arg({ placeholder: "Enter Trello template card ID:" }) 

// Prompt for the list ID where the new card will be created 
const listId = await arg({ placeholder: "Enter Trello list ID:" }); 

// Fetch the checklist IDs from the template card
const checklistResponse = await get(
  `https://api.trello.com/1/cards/${templateCardId}/checklists?key=${trelloApiKey}&token=${trelloToken}` 
); 

const checklistIds = checklistResponse.data.map(checklist => checklist.id)

// Create the new card on Trello 
const createCardResponse = await post(
  `https://api.trello.com/1/cards?key=${trelloApiKey}&token=${trelloToken}`, 
  {
    idList: listId,
    name: await arg("Enter card name:"), 
  }
) 

// Get the ID of the newly created card 
const newCardId = createCardResponse.data.id

// Copy checklists from the template card to the new card
for (const checklistId of checklistIds) { 
  await post( 
    `https://api.trello.com/1/cards/${newCardId}/checklists?key=${trelloApiKey}&token=${trelloToken}`, 
    {
      idChecklistSource: checklistId, // Copy the checklist from the template
    } 
  )
}

console.log(`Trello card created with checklists from template card.`); 
```

##  Get a List of Available Printers 

```typescript 
// Name: List Printers
// Description: Displays a list of available printers
// Author: johnlindquist

import "@johnlindquist/kit" 

// Execute the `lpstat -p` command to list printers and capture the output
const { stdout: printerList } = await exec("lpstat -p");

// Display the list of printers in the editor 
await editor({
  value: printerList,
  language: "text",
})
```

## Upload a File to an SFTP Server with a Password Prompt

```typescript
// Name: Upload to SFTP (with Password Prompt)
// Description: Uploads a file to a remote SFTP server with a password prompt
// Author: johnlindquist

import "@johnlindquist/kit"
import { connect } from "ssh2"

// Prompt for SFTP server details 
const host = await arg("Enter SFTP host:") 
const username = await arg("Enter SFTP username:")
const password = await arg({ 
  placeholder: "Enter SFTP password:", 
  secret: true, // Hide the password input
}) 

// Prompt for the local file path 
const localFilePath = await path({
  hint: "Select a file to upload",
});

// Prompt for the remote file path 
const remoteFilePath = await arg("Enter remote file path:") 

// Read the file content
const fileContent = await readFile(localFilePath); 

// Connect to the SFTP server
const sftp = new Promise<any>((resolve, reject) => {
  const connection = new connect();
  connection.on("ready", () => { 
    connection.sftp((err, sftp) => {
      if (err) {
        reject(err); 
      } else {
        resolve(sftp);
      }
    });
  }).connect({
    host, 
    port: 22, // Default SFTP port 
    username, 
    password,
  });
});

// Upload the file using SFTP 
(await sftp) 
  .fastPut(localFilePath, remoteFilePath)
  .then(() => { 
    console.log(`File "${localFilePath}" uploaded to SFTP server as "${remoteFilePath}".`); 
  }) 
  .catch(error => { 
    console.error(`Error uploading file to SFTP server: ${error}`); 
  })
```

## Generate a Random Joke and Post it to a Microsoft Teams Channel with a Button

```typescript
// Name: Teams Joke Bot with Button
// Description: Sends a random joke to a Microsoft Teams channel with a button to get another joke 
// Author: johnlindquist

import "@johnlindquist/kit"
import { Client } from "@microsoft/microsoft-graph-client"; 

// Get the Microsoft Graph API token from the environment
// https://docs.microsoft.com/en-us/graph/auth/
const graphToken = await env("GRAPH_TOKEN"); 

// Initialize the Microsoft Graph client
const graphClient = Client.init({
  authProvider: (done) => {
    done(null, graphToken) 
  }, 
})

// Prompt for the Team ID 
const teamId = await arg({ placeholder: "Enter Microsoft Teams Team ID:" }) 

// Prompt for the Channel ID
const channelId = await arg({ placeholder: "Enter Microsoft Teams Channel ID:" })

// Fetch a random joke from the JokeAPI 
const response = await get("https://v2.jokeapi.dev/joke/Any?safe-mode"); 

// Extract the joke setup and delivery (if applicable) 
const { setup, delivery, joke } = response.data

// Construct the joke string
const jokeText = setup ? `${setup}\n\n${delivery}` : joke;

// Send the joke to the Microsoft Teams channel with a button to get another joke
await graphClient 
  .api(`/teams/${teamId}/channels/${channelId}/messages`)
  .post({ 
    body: {
      contentType: "html", // Use HTML content type for the button
      content: `${jokeText}
<br>
<button onclick="location.reload()">Another Joke</button>`, // Add a button that refreshes the widget content
    }, 
  })
``` 

